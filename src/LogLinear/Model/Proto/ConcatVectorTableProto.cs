// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ConcatVectorTable.proto
using System;
using System.Collections.Generic;
using System.IO;
using Com.Google.Protobuf;



namespace Edu.Stanford.Nlp.Loglinear.Model.Proto
{
	public sealed class ConcatVectorTableProto
	{
		private ConcatVectorTableProto()
		{
		}

		public static void RegisterAllExtensions(ExtensionRegistry registry)
		{
		}

		public interface IConcatVectorTableOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
			/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
			IList<int> GetDimensionSizeList();

			/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
			int GetDimensionSizeCount();

			/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
			int GetDimensionSize(int index);

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			IList<ConcatVectorProto.ConcatVector> GetFactorTableList();

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			ConcatVectorProto.ConcatVector GetFactorTable(int index);

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			int GetFactorTableCount();

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			IList<ConcatVectorProto.IConcatVectorOrBuilder> GetFactorTableOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			ConcatVectorProto.IConcatVectorOrBuilder GetFactorTableOrBuilder(int index);
		}

		/// <summary>
		/// Protobuf type
		/// <c>edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable</c>
		/// </summary>
		[System.Serializable]
		public sealed class ConcatVectorTable : GeneratedMessage, ConcatVectorTableProto.IConcatVectorTableOrBuilder
		{
			private ConcatVectorTable(GeneratedMessage.Builder<object> builder)
				: base(builder)
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
				// Use ConcatVectorTable.newBuilder() to construct.
				this.unknownFields = builder.GetUnknownFields();
			}

			private ConcatVectorTable(bool noInit)
			{
				this.unknownFields = UnknownFieldSet.GetDefaultInstance();
			}

			private static readonly ConcatVectorTableProto.ConcatVectorTable defaultInstance;

			public static ConcatVectorTableProto.ConcatVectorTable GetDefaultInstance()
			{
				return defaultInstance;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return defaultInstance;
			}

			private readonly UnknownFieldSet unknownFields;

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private ConcatVectorTable(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				InitFields();
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									dimensionSize_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								dimensionSize_.Add(input.ReadInt32());
								break;
							}

							case 10:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))) && input.GetBytesUntilLimit() > 0)
								{
									dimensionSize_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									dimensionSize_.Add(input.ReadInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 18:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									factorTable_ = new List<ConcatVectorProto.ConcatVector>();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								factorTable_.Add(input.ReadMessage(ConcatVectorProto.ConcatVector.Parser, extensionRegistry));
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e.Message).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						dimensionSize_ = Java.Util.Collections.UnmodifiableList(dimensionSize_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						factorTable_ = Java.Util.Collections.UnmodifiableList(factorTable_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;
			}

			protected override GeneratedMessage.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(ConcatVectorTableProto.ConcatVectorTable), typeof(ConcatVectorTableProto.ConcatVectorTable.Builder
					));
			}

			private sealed class _AbstractParser_166 : AbstractParser<ConcatVectorTableProto.ConcatVectorTable>
			{
				public _AbstractParser_166()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override ConcatVectorTableProto.ConcatVectorTable ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new ConcatVectorTableProto.ConcatVectorTable(input, extensionRegistry);
				}
			}

			public static IParser<ConcatVectorTableProto.ConcatVectorTable> Parser = new _AbstractParser_166();

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public const int DimensionsizeFieldNumber = 1;

			private IList<int> dimensionSize_;

			/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
			public IList<int> GetDimensionSizeList()
			{
				return dimensionSize_;
			}

			/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
			public int GetDimensionSizeCount()
			{
				return dimensionSize_.Count;
			}

			/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
			public int GetDimensionSize(int index)
			{
				return dimensionSize_[index];
			}

			public const int FactortableFieldNumber = 2;

			private IList<ConcatVectorProto.ConcatVector> factorTable_;

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			public IList<ConcatVectorProto.ConcatVector> GetFactorTableList()
			{
				return factorTable_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			public IList<ConcatVectorProto.IConcatVectorOrBuilder> GetFactorTableOrBuilderList()
			{
				return factorTable_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			public int GetFactorTableCount()
			{
				return factorTable_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			public ConcatVectorProto.ConcatVector GetFactorTable(int index)
			{
				return factorTable_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
			public ConcatVectorProto.IConcatVectorOrBuilder GetFactorTableOrBuilder(int index)
			{
				return factorTable_[index];
			}

			private void InitFields()
			{
				dimensionSize_ = Java.Util.Collections.EmptyList();
				factorTable_ = Java.Util.Collections.EmptyList();
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				for (int i = 0; i < GetFactorTableCount(); i++)
				{
					if (!GetFactorTable(i).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				GetSerializedSize();
				foreach (int aDimensionSize_ in dimensionSize_)
				{
					output.WriteInt32(1, aDimensionSize_);
				}
				foreach (ConcatVectorProto.ConcatVector aFactorTable_ in factorTable_)
				{
					output.WriteMessage(2, aFactorTable_);
				}
				GetUnknownFields().WriteTo(output);
			}

			private int memoizedSerializedSize = -1;

			public override int GetSerializedSize()
			{
				int size = memoizedSerializedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				{
					int dataSize = 0;
					foreach (int aDimensionSize_ in dimensionSize_)
					{
						dataSize += CodedOutputStream.ComputeInt32SizeNoTag(aDimensionSize_);
					}
					size += dataSize;
					size += 1 * GetDimensionSizeList().Count;
				}
				foreach (ConcatVectorProto.ConcatVector aFactorTable_ in factorTable_)
				{
					size += CodedOutputStream.ComputeMessageSize(2, aFactorTable_);
				}
				size += GetUnknownFields().GetSerializedSize();
				memoizedSerializedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			/// <exception cref="Java.IO.ObjectStreamException"/>
			protected override object WriteReplace()
			{
				return base.WriteReplace();
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(InputStream input)
			{
				return Parser.ParseFrom(input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseDelimitedFrom(InputStream input)
			{
				return Parser.ParseDelimitedFrom(input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseDelimitedFrom(input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(CodedInputStream input)
			{
				return Parser.ParseFrom(input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static ConcatVectorTableProto.ConcatVectorTable ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(input, extensionRegistry);
			}

			public static ConcatVectorTableProto.ConcatVectorTable.Builder NewBuilder()
			{
				return ConcatVectorTableProto.ConcatVectorTable.Builder.Create();
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static ConcatVectorTableProto.ConcatVectorTable.Builder NewBuilder(ConcatVectorTableProto.ConcatVectorTable prototype)
			{
				return NewBuilder().MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return NewBuilder(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessage.IBuilderParent parent)
			{
				ConcatVectorTableProto.ConcatVectorTable.Builder builder = new ConcatVectorTableProto.ConcatVectorTable.Builder(parent);
				return builder;
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable</c>
			/// </summary>
			public sealed class Builder : GeneratedMessage.Builder<ConcatVectorTableProto.ConcatVectorTable.Builder>, ConcatVectorTableProto.IConcatVectorTableOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;
				}

				protected override GeneratedMessage.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(ConcatVectorTableProto.ConcatVectorTable), typeof(ConcatVectorTableProto.ConcatVectorTable.Builder
						));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessage.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessage.alwaysUseFieldBuilders)
					{
						GetFactorTableFieldBuilder();
					}
				}

				private static ConcatVectorTableProto.ConcatVectorTable.Builder Create()
				{
					return new ConcatVectorTableProto.ConcatVectorTable.Builder();
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					dimensionSize_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					if (factorTableBuilder_ == null)
					{
						factorTable_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					else
					{
						factorTableBuilder_.Clear();
					}
					return this;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return Create().MergeFrom(((ConcatVectorTableProto.ConcatVectorTable)BuildPartial()));
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return ConcatVectorTableProto.ConcatVectorTable.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					ConcatVectorTableProto.ConcatVectorTable result = ((ConcatVectorTableProto.ConcatVectorTable)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					ConcatVectorTableProto.ConcatVectorTable result = new ConcatVectorTableProto.ConcatVectorTable(this);
					int from_bitField0_ = bitField0_;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						dimensionSize_ = Java.Util.Collections.UnmodifiableList(dimensionSize_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					result.dimensionSize_ = dimensionSize_;
					if (factorTableBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							factorTable_ = Java.Util.Collections.UnmodifiableList(factorTable_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						result.factorTable_ = factorTable_;
					}
					else
					{
						result.factorTable_ = factorTableBuilder_.Build();
					}
					OnBuilt();
					return result;
				}

				public override ConcatVectorTableProto.ConcatVectorTable.Builder MergeFrom(IMessage other)
				{
					if (other is ConcatVectorTableProto.ConcatVectorTable)
					{
						return MergeFrom((ConcatVectorTableProto.ConcatVectorTable)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public ConcatVectorTableProto.ConcatVectorTable.Builder MergeFrom(ConcatVectorTableProto.ConcatVectorTable other)
				{
					if (other == ConcatVectorTableProto.ConcatVectorTable.GetDefaultInstance())
					{
						return this;
					}
					if (!other.dimensionSize_.IsEmpty())
					{
						if (dimensionSize_.IsEmpty())
						{
							dimensionSize_ = other.dimensionSize_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						else
						{
							EnsureDimensionSizeIsMutable();
							Sharpen.Collections.AddAll(dimensionSize_, other.dimensionSize_);
						}
						OnChanged();
					}
					if (factorTableBuilder_ == null)
					{
						if (!other.factorTable_.IsEmpty())
						{
							if (factorTable_.IsEmpty())
							{
								factorTable_ = other.factorTable_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
							}
							else
							{
								EnsureFactorTableIsMutable();
								Sharpen.Collections.AddAll(factorTable_, other.factorTable_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.factorTable_.IsEmpty())
						{
							if (factorTableBuilder_.IsEmpty())
							{
								factorTableBuilder_.Dispose();
								factorTableBuilder_ = null;
								factorTable_ = other.factorTable_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
								factorTableBuilder_ = GeneratedMessage.alwaysUseFieldBuilders ? GetFactorTableFieldBuilder() : null;
							}
							else
							{
								factorTableBuilder_.AddAllMessages(other.factorTable_);
							}
						}
					}
					this.MergeUnknownFields(other.GetUnknownFields());
					return this;
				}

				public sealed override bool IsInitialized()
				{
					for (int i = 0; i < GetFactorTableCount(); i++)
					{
						if (!GetFactorTable(i).IsInitialized())
						{
							return false;
						}
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					ConcatVectorTableProto.ConcatVectorTable parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (ConcatVectorTableProto.ConcatVectorTable)e.GetUnfinishedMessage();
						throw;
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private IList<int> dimensionSize_ = Java.Util.Collections.EmptyList();

				private void EnsureDimensionSizeIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						dimensionSize_ = new List<int>(dimensionSize_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
				public IList<int> GetDimensionSizeList()
				{
					return Java.Util.Collections.UnmodifiableList(dimensionSize_);
				}

				/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
				public int GetDimensionSizeCount()
				{
					return dimensionSize_.Count;
				}

				/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
				public int GetDimensionSize(int index)
				{
					return dimensionSize_[index];
				}

				/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder SetDimensionSize(int index, int value)
				{
					EnsureDimensionSizeIsMutable();
					dimensionSize_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder AddDimensionSize(int value)
				{
					EnsureDimensionSizeIsMutable();
					dimensionSize_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder AddAllDimensionSize<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureDimensionSizeIsMutable();
					AbstractMessageLite.Builder.AddAll(values, dimensionSize_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 dimensionSize = 1;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder ClearDimensionSize()
				{
					dimensionSize_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					OnChanged();
					return this;
				}

				private IList<ConcatVectorProto.ConcatVector> factorTable_ = Java.Util.Collections.EmptyList();

				private void EnsureFactorTableIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						factorTable_ = new List<ConcatVectorProto.ConcatVector>(factorTable_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				private RepeatedFieldBuilder<ConcatVectorProto.ConcatVector, ConcatVectorProto.ConcatVector.Builder, ConcatVectorProto.IConcatVectorOrBuilder> factorTableBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public IList<ConcatVectorProto.ConcatVector> GetFactorTableList()
				{
					if (factorTableBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(factorTable_);
					}
					else
					{
						return factorTableBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public int GetFactorTableCount()
				{
					if (factorTableBuilder_ == null)
					{
						return factorTable_.Count;
					}
					else
					{
						return factorTableBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorProto.ConcatVector GetFactorTable(int index)
				{
					if (factorTableBuilder_ == null)
					{
						return factorTable_[index];
					}
					else
					{
						return factorTableBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder SetFactorTable(int index, ConcatVectorProto.ConcatVector value)
				{
					if (factorTableBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureFactorTableIsMutable();
						factorTable_.Set(index, value);
						OnChanged();
					}
					else
					{
						factorTableBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder SetFactorTable(int index, ConcatVectorProto.ConcatVector.Builder builderForValue)
				{
					if (factorTableBuilder_ == null)
					{
						EnsureFactorTableIsMutable();
						factorTable_.Set(index, ((ConcatVectorProto.ConcatVector)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						factorTableBuilder_.SetMessage(index, ((ConcatVectorProto.ConcatVector)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder AddFactorTable(ConcatVectorProto.ConcatVector value)
				{
					if (factorTableBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureFactorTableIsMutable();
						factorTable_.Add(value);
						OnChanged();
					}
					else
					{
						factorTableBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder AddFactorTable(int index, ConcatVectorProto.ConcatVector value)
				{
					if (factorTableBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureFactorTableIsMutable();
						factorTable_.Add(index, value);
						OnChanged();
					}
					else
					{
						factorTableBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder AddFactorTable(ConcatVectorProto.ConcatVector.Builder builderForValue)
				{
					if (factorTableBuilder_ == null)
					{
						EnsureFactorTableIsMutable();
						factorTable_.Add(((ConcatVectorProto.ConcatVector)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						factorTableBuilder_.AddMessage(((ConcatVectorProto.ConcatVector)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder AddFactorTable(int index, ConcatVectorProto.ConcatVector.Builder builderForValue)
				{
					if (factorTableBuilder_ == null)
					{
						EnsureFactorTableIsMutable();
						factorTable_.Add(index, ((ConcatVectorProto.ConcatVector)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						factorTableBuilder_.AddMessage(index, ((ConcatVectorProto.ConcatVector)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder AddAllFactorTable<_T0>(IEnumerable<_T0> values)
					where _T0 : ConcatVectorProto.ConcatVector
				{
					if (factorTableBuilder_ == null)
					{
						EnsureFactorTableIsMutable();
						AbstractMessageLite.Builder.AddAll(values, factorTable_);
						OnChanged();
					}
					else
					{
						factorTableBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder ClearFactorTable()
				{
					if (factorTableBuilder_ == null)
					{
						factorTable_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						OnChanged();
					}
					else
					{
						factorTableBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorTableProto.ConcatVectorTable.Builder RemoveFactorTable(int index)
				{
					if (factorTableBuilder_ == null)
					{
						EnsureFactorTableIsMutable();
						factorTable_.Remove(index);
						OnChanged();
					}
					else
					{
						factorTableBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorProto.ConcatVector.Builder GetFactorTableBuilder(int index)
				{
					return GetFactorTableFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorProto.IConcatVectorOrBuilder GetFactorTableOrBuilder(int index)
				{
					if (factorTableBuilder_ == null)
					{
						return factorTable_[index];
					}
					else
					{
						return factorTableBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public IList<ConcatVectorProto.IConcatVectorOrBuilder> GetFactorTableOrBuilderList()
				{
					if (factorTableBuilder_ != null)
					{
						return factorTableBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(factorTable_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorProto.ConcatVector.Builder AddFactorTableBuilder()
				{
					return GetFactorTableFieldBuilder().AddBuilder(ConcatVectorProto.ConcatVector.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public ConcatVectorProto.ConcatVector.Builder AddFactorTableBuilder(int index)
				{
					return GetFactorTableFieldBuilder().AddBuilder(index, ConcatVectorProto.ConcatVector.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;</code></summary>
				public IList<ConcatVectorProto.ConcatVector.Builder> GetFactorTableBuilderList()
				{
					return GetFactorTableFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilder<ConcatVectorProto.ConcatVector, ConcatVectorProto.ConcatVector.Builder, ConcatVectorProto.IConcatVectorOrBuilder> GetFactorTableFieldBuilder()
				{
					if (factorTableBuilder_ == null)
					{
						factorTableBuilder_ = new RepeatedFieldBuilder<ConcatVectorProto.ConcatVector, ConcatVectorProto.ConcatVector.Builder, ConcatVectorProto.IConcatVectorOrBuilder>(factorTable_, ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002
							))), GetParentForChildren(), IsClean());
						factorTable_ = null;
					}
					return factorTableBuilder_;
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
			}

			static ConcatVectorTable()
			{
				defaultInstance = new ConcatVectorTableProto.ConcatVectorTable(true);
				defaultInstance.InitFields();
			}
			// @@protoc_insertion_point(class_scope:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
		}

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;

		private static GeneratedMessage.FieldAccessorTable internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable;

		public static Descriptors.FileDescriptor GetDescriptor()
		{
			return descriptor;
		}

		private static Descriptors.FileDescriptor descriptor;

		static ConcatVectorTableProto()
		{
			string[] descriptorData = new string[] { "\n\x1bConcatVectorTable.proto\x16&edu.stanford." + "nlp.loglinear.model.proto\x20\x16ConcatVector." + "proto\"u\n\x15ConcatVectorTable\x16\x19\n\rdimensionS" + "ize\x1e\x1 \x3(\x5\x16I\n\xdfactorTable\x1e\x2 \x3(\x52c.edu.sta"
				 + "nford.nlp.loglinear.model.proto.ConcatVe" + "ctorB@\n&edu.stanford.nlp.loglinear.model" + ".protoB\x1aConcatVectorTableProto" };
			Descriptors.FileDescriptor.IInternalDescriptorAssigner assigner = new _IInternalDescriptorAssigner_878();
			Descriptors.FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData, new Descriptors.FileDescriptor[] { ConcatVectorProto.GetDescriptor() }, assigner);
			internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor = GetDescriptor().GetMessageTypes()[0];
			internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable = new GeneratedMessage.FieldAccessorTable(internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor, new string[] { "DimensionSize"
				, "FactorTable" });
			ConcatVectorProto.GetDescriptor();
		}

		private sealed class _IInternalDescriptorAssigner_878 : Descriptors.FileDescriptor.IInternalDescriptorAssigner
		{
			public _IInternalDescriptorAssigner_878()
			{
			}

			public ExtensionRegistry AssignDescriptors(Descriptors.FileDescriptor root)
			{
				ConcatVectorTableProto.descriptor = root;
				return null;
			}
		}
		// @@protoc_insertion_point(outer_class_scope)
	}
}
