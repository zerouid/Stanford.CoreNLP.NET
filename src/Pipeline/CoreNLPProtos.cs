// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CoreNLP.proto
using System;
using System.Collections.Generic;
using System.IO;
using Com.Google.Protobuf;



namespace Edu.Stanford.Nlp.Pipeline
{
	public sealed class CoreNLPProtos
	{
		private CoreNLPProtos()
		{
		}

		public static void RegisterAllExtensions(ExtensionRegistryLite registry)
		{
		}

		public static void RegisterAllExtensions(ExtensionRegistry registry)
		{
			RegisterAllExtensions((ExtensionRegistryLite)registry);
		}

		/// <summary>
		/// <pre>
		/// An enumeration for the valid languages allowed in CoreNLP
		/// </pre>
		/// Protobuf enum
		/// <c>edu.stanford.nlp.pipeline.Language</c>
		/// </summary>
		[System.Serializable]
		public sealed class Language : IProtocolMessageEnum
		{
			/// <summary><code>Unknown = 0;</code></summary>
			public static readonly CoreNLPProtos.Language Unknown = new CoreNLPProtos.Language(0);

			/// <summary><code>Any = 1;</code></summary>
			public static readonly CoreNLPProtos.Language Any = new CoreNLPProtos.Language(1);

			/// <summary><code>Arabic = 2;</code></summary>
			public static readonly CoreNLPProtos.Language Arabic = new CoreNLPProtos.Language(2);

			/// <summary><code>Chinese = 3;</code></summary>
			public static readonly CoreNLPProtos.Language Chinese = new CoreNLPProtos.Language(3);

			/// <summary><code>English = 4;</code></summary>
			public static readonly CoreNLPProtos.Language English = new CoreNLPProtos.Language(4);

			/// <summary><code>German = 5;</code></summary>
			public static readonly CoreNLPProtos.Language German = new CoreNLPProtos.Language(5);

			/// <summary><code>French = 6;</code></summary>
			public static readonly CoreNLPProtos.Language French = new CoreNLPProtos.Language(6);

			/// <summary><code>Hebrew = 7;</code></summary>
			public static readonly CoreNLPProtos.Language Hebrew = new CoreNLPProtos.Language(7);

			/// <summary><code>Spanish = 8;</code></summary>
			public static readonly CoreNLPProtos.Language Spanish = new CoreNLPProtos.Language(8);

			/// <summary><code>UniversalEnglish = 9;</code></summary>
			public static readonly CoreNLPProtos.Language UniversalEnglish = new CoreNLPProtos.Language(9);

			/// <summary><code>UniversalChinese = 10;</code></summary>
			public static readonly CoreNLPProtos.Language UniversalChinese = new CoreNLPProtos.Language(10);

			/// <summary><code>Unknown = 0;</code></summary>
			public const int Unknown_VALUE = 0;

			/// <summary><code>Any = 1;</code></summary>
			public const int Any_VALUE = 1;

			/// <summary><code>Arabic = 2;</code></summary>
			public const int Arabic_VALUE = 2;

			/// <summary><code>Chinese = 3;</code></summary>
			public const int Chinese_VALUE = 3;

			/// <summary><code>English = 4;</code></summary>
			public const int English_VALUE = 4;

			/// <summary><code>German = 5;</code></summary>
			public const int German_VALUE = 5;

			/// <summary><code>French = 6;</code></summary>
			public const int French_VALUE = 6;

			/// <summary><code>Hebrew = 7;</code></summary>
			public const int Hebrew_VALUE = 7;

			/// <summary><code>Spanish = 8;</code></summary>
			public const int Spanish_VALUE = 8;

			/// <summary><code>UniversalEnglish = 9;</code></summary>
			public const int UniversalEnglish_VALUE = 9;

			/// <summary><code>UniversalChinese = 10;</code></summary>
			public const int UniversalChinese_VALUE = 10;

			public int GetNumber()
			{
				return CoreNLPProtos.Language.value;
			}

			[System.ObsoleteAttribute(@"Use ForNumber(int) instead.")]
			public static CoreNLPProtos.Language ValueOf(int value)
			{
				return ForNumber(value);
			}

			public static CoreNLPProtos.Language ForNumber(int value)
			{
				switch (value)
				{
					case 0:
					{
						return CoreNLPProtos.Language.Unknown;
					}

					case 1:
					{
						return CoreNLPProtos.Language.Any;
					}

					case 2:
					{
						return CoreNLPProtos.Language.Arabic;
					}

					case 3:
					{
						return CoreNLPProtos.Language.Chinese;
					}

					case 4:
					{
						return CoreNLPProtos.Language.English;
					}

					case 5:
					{
						return CoreNLPProtos.Language.German;
					}

					case 6:
					{
						return CoreNLPProtos.Language.French;
					}

					case 7:
					{
						return CoreNLPProtos.Language.Hebrew;
					}

					case 8:
					{
						return CoreNLPProtos.Language.Spanish;
					}

					case 9:
					{
						return CoreNLPProtos.Language.UniversalEnglish;
					}

					case 10:
					{
						return CoreNLPProtos.Language.UniversalChinese;
					}

					default:
					{
						return null;
					}
				}
			}

			public static Internal.IEnumLiteMap<CoreNLPProtos.Language> InternalGetValueMap()
			{
				return CoreNLPProtos.Language.internalValueMap;
			}

			private sealed class _IEnumLiteMap_153 : Internal.IEnumLiteMap<CoreNLPProtos.Language>
			{
				public _IEnumLiteMap_153()
				{
				}

				public CoreNLPProtos.Language FindValueByNumber(int number)
				{
					return CoreNLPProtos.Language.ForNumber(number);
				}
			}

			private static readonly Internal.IEnumLiteMap<CoreNLPProtos.Language> internalValueMap = new _IEnumLiteMap_153();

			public Descriptors.EnumValueDescriptor GetValueDescriptor()
			{
				return GetDescriptor().GetValues()[Ordinal()];
			}

			public Descriptors.EnumDescriptor GetDescriptorForType()
			{
				return GetDescriptor();
			}

			public static Descriptors.EnumDescriptor GetDescriptor()
			{
				return CoreNLPProtos.GetDescriptor().GetEnumTypes()[0];
			}

			private static readonly CoreNLPProtos.Language[] Values = Values();

			public static CoreNLPProtos.Language ValueOf(Descriptors.EnumValueDescriptor desc)
			{
				if (desc.GetType() != GetDescriptor())
				{
					throw new ArgumentException("EnumValueDescriptor is not for this type.");
				}
				return CoreNLPProtos.Language.Values[desc.GetIndex()];
			}

			private readonly int value;

			private Language(int value)
			{
				this.value = value;
			}
			// @@protoc_insertion_point(enum_scope:edu.stanford.nlp.pipeline.Language)
		}

		/// <summary>
		/// <pre>
		/// An enumeration of valid sentiment values for the sentiment classifier.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// An enumeration of valid sentiment values for the sentiment classifier.
		/// </pre>
		/// Protobuf enum
		/// <c>edu.stanford.nlp.pipeline.Sentiment</c>
		/// </remarks>
		[System.Serializable]
		public sealed class Sentiment : IProtocolMessageEnum
		{
			/// <summary><code>STRONG_NEGATIVE = 0;</code></summary>
			public static readonly CoreNLPProtos.Sentiment StrongNegative = new CoreNLPProtos.Sentiment(0);

			/// <summary><code>WEAK_NEGATIVE = 1;</code></summary>
			public static readonly CoreNLPProtos.Sentiment WeakNegative = new CoreNLPProtos.Sentiment(1);

			/// <summary><code>NEUTRAL = 2;</code></summary>
			public static readonly CoreNLPProtos.Sentiment Neutral = new CoreNLPProtos.Sentiment(2);

			/// <summary><code>WEAK_POSITIVE = 3;</code></summary>
			public static readonly CoreNLPProtos.Sentiment WeakPositive = new CoreNLPProtos.Sentiment(3);

			/// <summary><code>STRONG_POSITIVE = 4;</code></summary>
			public static readonly CoreNLPProtos.Sentiment StrongPositive = new CoreNLPProtos.Sentiment(4);

			/// <summary><code>STRONG_NEGATIVE = 0;</code></summary>
			public const int StrongNegativeValue = 0;

			/// <summary><code>WEAK_NEGATIVE = 1;</code></summary>
			public const int WeakNegativeValue = 1;

			/// <summary><code>NEUTRAL = 2;</code></summary>
			public const int NeutralValue = 2;

			/// <summary><code>WEAK_POSITIVE = 3;</code></summary>
			public const int WeakPositiveValue = 3;

			/// <summary><code>STRONG_POSITIVE = 4;</code></summary>
			public const int StrongPositiveValue = 4;

			public int GetNumber()
			{
				return CoreNLPProtos.Sentiment.value;
			}

			[System.ObsoleteAttribute(@"Use ForNumber(int) instead.")]
			public static CoreNLPProtos.Sentiment ValueOf(int value)
			{
				return ForNumber(value);
			}

			public static CoreNLPProtos.Sentiment ForNumber(int value)
			{
				switch (value)
				{
					case 0:
					{
						return CoreNLPProtos.Sentiment.StrongNegative;
					}

					case 1:
					{
						return CoreNLPProtos.Sentiment.WeakNegative;
					}

					case 2:
					{
						return CoreNLPProtos.Sentiment.Neutral;
					}

					case 3:
					{
						return CoreNLPProtos.Sentiment.WeakPositive;
					}

					case 4:
					{
						return CoreNLPProtos.Sentiment.StrongPositive;
					}

					default:
					{
						return null;
					}
				}
			}

			public static Internal.IEnumLiteMap<CoreNLPProtos.Sentiment> InternalGetValueMap()
			{
				return CoreNLPProtos.Sentiment.internalValueMap;
			}

			private sealed class _IEnumLiteMap_274 : Internal.IEnumLiteMap<CoreNLPProtos.Sentiment>
			{
				public _IEnumLiteMap_274()
				{
				}

				public CoreNLPProtos.Sentiment FindValueByNumber(int number)
				{
					return CoreNLPProtos.Sentiment.ForNumber(number);
				}
			}

			private static readonly Internal.IEnumLiteMap<CoreNLPProtos.Sentiment> internalValueMap = new _IEnumLiteMap_274();

			public Descriptors.EnumValueDescriptor GetValueDescriptor()
			{
				return GetDescriptor().GetValues()[Ordinal()];
			}

			public Descriptors.EnumDescriptor GetDescriptorForType()
			{
				return GetDescriptor();
			}

			public static Descriptors.EnumDescriptor GetDescriptor()
			{
				return CoreNLPProtos.GetDescriptor().GetEnumTypes()[1];
			}

			private static readonly CoreNLPProtos.Sentiment[] Values = Values();

			public static CoreNLPProtos.Sentiment ValueOf(Descriptors.EnumValueDescriptor desc)
			{
				if (desc.GetType() != GetDescriptor())
				{
					throw new ArgumentException("EnumValueDescriptor is not for this type.");
				}
				return CoreNLPProtos.Sentiment.Values[desc.GetIndex()];
			}

			private readonly int value;

			private Sentiment(int value)
			{
				this.value = value;
			}
			// @@protoc_insertion_point(enum_scope:edu.stanford.nlp.pipeline.Sentiment)
		}

		/// <summary>
		/// <pre>
		/// The seven informative Natural Logic relations
		/// </pre>
		/// Protobuf enum
		/// <c>edu.stanford.nlp.pipeline.NaturalLogicRelation</c>
		/// </summary>
		[System.Serializable]
		public sealed class NaturalLogicRelation : IProtocolMessageEnum
		{
			/// <summary><code>EQUIVALENCE = 0;</code></summary>
			public static readonly CoreNLPProtos.NaturalLogicRelation Equivalence = new CoreNLPProtos.NaturalLogicRelation(0);

			/// <summary><code>FORWARD_ENTAILMENT = 1;</code></summary>
			public static readonly CoreNLPProtos.NaturalLogicRelation ForwardEntailment = new CoreNLPProtos.NaturalLogicRelation(1);

			/// <summary><code>REVERSE_ENTAILMENT = 2;</code></summary>
			public static readonly CoreNLPProtos.NaturalLogicRelation ReverseEntailment = new CoreNLPProtos.NaturalLogicRelation(2);

			/// <summary><code>NEGATION = 3;</code></summary>
			public static readonly CoreNLPProtos.NaturalLogicRelation Negation = new CoreNLPProtos.NaturalLogicRelation(3);

			/// <summary><code>ALTERNATION = 4;</code></summary>
			public static readonly CoreNLPProtos.NaturalLogicRelation Alternation = new CoreNLPProtos.NaturalLogicRelation(4);

			/// <summary><code>COVER = 5;</code></summary>
			public static readonly CoreNLPProtos.NaturalLogicRelation Cover = new CoreNLPProtos.NaturalLogicRelation(5);

			/// <summary><code>INDEPENDENCE = 6;</code></summary>
			public static readonly CoreNLPProtos.NaturalLogicRelation Independence = new CoreNLPProtos.NaturalLogicRelation(6);

			/// <summary><code>EQUIVALENCE = 0;</code></summary>
			public const int EquivalenceValue = 0;

			/// <summary><code>FORWARD_ENTAILMENT = 1;</code></summary>
			public const int ForwardEntailmentValue = 1;

			/// <summary><code>REVERSE_ENTAILMENT = 2;</code></summary>
			public const int ReverseEntailmentValue = 2;

			/// <summary><code>NEGATION = 3;</code></summary>
			public const int NegationValue = 3;

			/// <summary><code>ALTERNATION = 4;</code></summary>
			public const int AlternationValue = 4;

			/// <summary><code>COVER = 5;</code></summary>
			public const int CoverValue = 5;

			/// <summary><code>INDEPENDENCE = 6;</code></summary>
			public const int IndependenceValue = 6;

			public int GetNumber()
			{
				return CoreNLPProtos.NaturalLogicRelation.value;
			}

			[System.ObsoleteAttribute(@"Use ForNumber(int) instead.")]
			public static CoreNLPProtos.NaturalLogicRelation ValueOf(int value)
			{
				return ForNumber(value);
			}

			public static CoreNLPProtos.NaturalLogicRelation ForNumber(int value)
			{
				switch (value)
				{
					case 0:
					{
						return CoreNLPProtos.NaturalLogicRelation.Equivalence;
					}

					case 1:
					{
						return CoreNLPProtos.NaturalLogicRelation.ForwardEntailment;
					}

					case 2:
					{
						return CoreNLPProtos.NaturalLogicRelation.ReverseEntailment;
					}

					case 3:
					{
						return CoreNLPProtos.NaturalLogicRelation.Negation;
					}

					case 4:
					{
						return CoreNLPProtos.NaturalLogicRelation.Alternation;
					}

					case 5:
					{
						return CoreNLPProtos.NaturalLogicRelation.Cover;
					}

					case 6:
					{
						return CoreNLPProtos.NaturalLogicRelation.Independence;
					}

					default:
					{
						return null;
					}
				}
			}

			public static Internal.IEnumLiteMap<CoreNLPProtos.NaturalLogicRelation> InternalGetValueMap()
			{
				return CoreNLPProtos.NaturalLogicRelation.internalValueMap;
			}

			private sealed class _IEnumLiteMap_413 : Internal.IEnumLiteMap<CoreNLPProtos.NaturalLogicRelation>
			{
				public _IEnumLiteMap_413()
				{
				}

				public CoreNLPProtos.NaturalLogicRelation FindValueByNumber(int number)
				{
					return CoreNLPProtos.NaturalLogicRelation.ForNumber(number);
				}
			}

			private static readonly Internal.IEnumLiteMap<CoreNLPProtos.NaturalLogicRelation> internalValueMap = new _IEnumLiteMap_413();

			public Descriptors.EnumValueDescriptor GetValueDescriptor()
			{
				return GetDescriptor().GetValues()[Ordinal()];
			}

			public Descriptors.EnumDescriptor GetDescriptorForType()
			{
				return GetDescriptor();
			}

			public static Descriptors.EnumDescriptor GetDescriptor()
			{
				return CoreNLPProtos.GetDescriptor().GetEnumTypes()[2];
			}

			private static readonly CoreNLPProtos.NaturalLogicRelation[] Values = Values();

			public static CoreNLPProtos.NaturalLogicRelation ValueOf(Descriptors.EnumValueDescriptor desc)
			{
				if (desc.GetType() != GetDescriptor())
				{
					throw new ArgumentException("EnumValueDescriptor is not for this type.");
				}
				return CoreNLPProtos.NaturalLogicRelation.Values[desc.GetIndex()];
			}

			private readonly int value;

			private NaturalLogicRelation(int value)
			{
				this.value = value;
			}
			// @@protoc_insertion_point(enum_scope:edu.stanford.nlp.pipeline.NaturalLogicRelation)
		}

		public interface IDocumentOrBuilder : GeneratedMessageV3.IExtendableMessageOrBuilder<CoreNLPProtos.Document>
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Document)
			/// <summary><code>required string text = 1;</code></summary>
			bool HasText();

			/// <summary><code>required string text = 1;</code></summary>
			string GetText();

			/// <summary><code>required string text = 1;</code></summary>
			ByteString GetTextBytes();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			IList<CoreNLPProtos.Sentence> GetSentenceList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			CoreNLPProtos.Sentence GetSentence(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			int GetSentenceCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			IList<CoreNLPProtos.ISentenceOrBuilder> GetSentenceOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			CoreNLPProtos.ISentenceOrBuilder GetSentenceOrBuilder(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			IList<CoreNLPProtos.CorefChain> GetCorefChainList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			CoreNLPProtos.CorefChain GetCorefChain(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			int GetCorefChainCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			IList<CoreNLPProtos.ICorefChainOrBuilder> GetCorefChainOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			CoreNLPProtos.ICorefChainOrBuilder GetCorefChainOrBuilder(int index);

			/// <summary><code>optional string docID = 4;</code></summary>
			bool HasDocID();

			/// <summary><code>optional string docID = 4;</code></summary>
			string GetDocID();

			/// <summary><code>optional string docID = 4;</code></summary>
			ByteString GetDocIDBytes();

			/// <summary><code>optional string docDate = 7;</code></summary>
			bool HasDocDate();

			/// <summary><code>optional string docDate = 7;</code></summary>
			string GetDocDate();

			/// <summary><code>optional string docDate = 7;</code></summary>
			ByteString GetDocDateBytes();

			/// <summary><code>optional uint64 calendar = 8;</code></summary>
			bool HasCalendar();

			/// <summary><code>optional uint64 calendar = 8;</code></summary>
			long GetCalendar();

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			IList<CoreNLPProtos.Token> GetSentencelessTokenList();

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			CoreNLPProtos.Token GetSentencelessToken(int index);

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			int GetSentencelessTokenCount();

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			IList<CoreNLPProtos.ITokenOrBuilder> GetSentencelessTokenOrBuilderList();

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			CoreNLPProtos.ITokenOrBuilder GetSentencelessTokenOrBuilder(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			IList<CoreNLPProtos.Token> GetCharacterList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			CoreNLPProtos.Token GetCharacter(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			int GetCharacterCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			IList<CoreNLPProtos.ITokenOrBuilder> GetCharacterOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			CoreNLPProtos.ITokenOrBuilder GetCharacterOrBuilder(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			IList<CoreNLPProtos.Quote> GetQuoteList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			CoreNLPProtos.Quote GetQuote(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			int GetQuoteCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			IList<CoreNLPProtos.IQuoteOrBuilder> GetQuoteOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			CoreNLPProtos.IQuoteOrBuilder GetQuoteOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			IList<CoreNLPProtos.NERMention> GetMentionsList();

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			CoreNLPProtos.NERMention GetMentions(int index);

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			int GetMentionsCount();

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			IList<CoreNLPProtos.INERMentionOrBuilder> GetMentionsOrBuilderList();

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			CoreNLPProtos.INERMentionOrBuilder GetMentionsOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// used to differentiate between null and empty list
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
			/// </summary>
			bool HasHasEntityMentionsAnnotation();

			/// <summary>
			/// <pre>
			/// used to differentiate between null and empty list
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
			/// </summary>
			bool GetHasEntityMentionsAnnotation();

			/// <summary>
			/// <pre>
			/// xml information
			/// </pre>
			/// <code>optional bool xmlDoc = 11;</code>
			/// </summary>
			bool HasXmlDoc();

			/// <summary>
			/// <pre>
			/// xml information
			/// </pre>
			/// <code>optional bool xmlDoc = 11;</code>
			/// </summary>
			bool GetXmlDoc();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			IList<CoreNLPProtos.Section> GetSectionsList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			CoreNLPProtos.Section GetSections(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			int GetSectionsCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			IList<CoreNLPProtos.ISectionOrBuilder> GetSectionsOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			CoreNLPProtos.ISectionOrBuilder GetSectionsOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			IList<CoreNLPProtos.Mention> GetMentionsForCorefList();

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			CoreNLPProtos.Mention GetMentionsForCoref(int index);

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			int GetMentionsForCorefCount();

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			IList<CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefOrBuilderList();

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			CoreNLPProtos.IMentionOrBuilder GetMentionsForCorefOrBuilder(int index);

			/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
			bool HasHasCorefMentionAnnotation();

			/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
			bool GetHasCorefMentionAnnotation();

			/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
			bool HasHasCorefAnnotation();

			/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
			bool GetHasCorefAnnotation();

			/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
			IList<int> GetCorefMentionToEntityMentionMappingsList();

			/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
			int GetCorefMentionToEntityMentionMappingsCount();

			/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
			int GetCorefMentionToEntityMentionMappings(int index);

			/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
			IList<int> GetEntityMentionToCorefMentionMappingsList();

			/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
			int GetEntityMentionToCorefMentionMappingsCount();

			/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
			int GetEntityMentionToCorefMentionMappings(int index);
		}

		/// <summary>
		/// <pre>
		/// A document; that is, the equivalent of an Annotation.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A document; that is, the equivalent of an Annotation.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Document</c>
		/// </remarks>
		[System.Serializable]
		public sealed class Document : GeneratedMessageV3.ExtendableMessage<CoreNLPProtos.Document>, CoreNLPProtos.IDocumentOrBuilder
		{
			private Document(GeneratedMessageV3.ExtendableBuilder<CoreNLPProtos.Document, object> builder)
				: base(builder)
			{
			}

			private Document()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Document)
				// Use Document.newBuilder() to construct.
				text_ = string.Empty;
				sentence_ = Java.Util.Collections.EmptyList();
				corefChain_ = Java.Util.Collections.EmptyList();
				docID_ = string.Empty;
				docDate_ = string.Empty;
				calendar_ = 0L;
				sentencelessToken_ = Java.Util.Collections.EmptyList();
				character_ = Java.Util.Collections.EmptyList();
				quote_ = Java.Util.Collections.EmptyList();
				mentions_ = Java.Util.Collections.EmptyList();
				hasEntityMentionsAnnotation_ = false;
				xmlDoc_ = false;
				sections_ = Java.Util.Collections.EmptyList();
				mentionsForCoref_ = Java.Util.Collections.EmptyList();
				hasCorefMentionAnnotation_ = false;
				hasCorefAnnotation_ = false;
				corefMentionToEntityMentionMappings_ = Java.Util.Collections.EmptyList();
				entityMentionToCorefMentionMappings_ = Java.Util.Collections.EmptyList();
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Document(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								text_ = bs;
								break;
							}

							case 18:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									sentence_ = new List<CoreNLPProtos.Sentence>();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								sentence_.Add(input.ReadMessage(CoreNLPProtos.Sentence.Parser, extensionRegistry));
								break;
							}

							case 26:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
								{
									corefChain_ = new List<CoreNLPProtos.CorefChain>();
									mutable_bitField0_ |= unchecked((int)(0x00000004));
								}
								corefChain_.Add(input.ReadMessage(CoreNLPProtos.CorefChain.Parser, extensionRegistry));
								break;
							}

							case 34:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000002));
								docID_ = bs;
								break;
							}

							case 42:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
								{
									sentencelessToken_ = new List<CoreNLPProtos.Token>();
									mutable_bitField0_ |= unchecked((int)(0x00000040));
								}
								sentencelessToken_.Add(input.ReadMessage(CoreNLPProtos.Token.Parser, extensionRegistry));
								break;
							}

							case 50:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
								{
									quote_ = new List<CoreNLPProtos.Quote>();
									mutable_bitField0_ |= unchecked((int)(0x00000100));
								}
								quote_.Add(input.ReadMessage(CoreNLPProtos.Quote.Parser, extensionRegistry));
								break;
							}

							case 58:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000004));
								docDate_ = bs;
								break;
							}

							case 64:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								calendar_ = input.ReadUInt64();
								break;
							}

							case 74:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
								{
									mentions_ = new List<CoreNLPProtos.NERMention>();
									mutable_bitField0_ |= unchecked((int)(0x00000200));
								}
								mentions_.Add(input.ReadMessage(CoreNLPProtos.NERMention.Parser, extensionRegistry));
								break;
							}

							case 82:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
								{
									character_ = new List<CoreNLPProtos.Token>();
									mutable_bitField0_ |= unchecked((int)(0x00000080));
								}
								character_.Add(input.ReadMessage(CoreNLPProtos.Token.Parser, extensionRegistry));
								break;
							}

							case 88:
							{
								bitField0_ |= unchecked((int)(0x00000020));
								xmlDoc_ = input.ReadBool();
								break;
							}

							case 98:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
								{
									sections_ = new List<CoreNLPProtos.Section>();
									mutable_bitField0_ |= unchecked((int)(0x00001000));
								}
								sections_.Add(input.ReadMessage(CoreNLPProtos.Section.Parser, extensionRegistry));
								break;
							}

							case 104:
							{
								bitField0_ |= unchecked((int)(0x00000010));
								hasEntityMentionsAnnotation_ = input.ReadBool();
								break;
							}

							case 114:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
								{
									mentionsForCoref_ = new List<CoreNLPProtos.Mention>();
									mutable_bitField0_ |= unchecked((int)(0x00002000));
								}
								mentionsForCoref_.Add(input.ReadMessage(CoreNLPProtos.Mention.Parser, extensionRegistry));
								break;
							}

							case 120:
							{
								bitField0_ |= unchecked((int)(0x00000040));
								hasCorefMentionAnnotation_ = input.ReadBool();
								break;
							}

							case 128:
							{
								bitField0_ |= unchecked((int)(0x00000080));
								hasCorefAnnotation_ = input.ReadBool();
								break;
							}

							case 136:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
								{
									corefMentionToEntityMentionMappings_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00010000));
								}
								corefMentionToEntityMentionMappings_.Add(input.ReadUInt32());
								break;
							}

							case 138:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))) && input.GetBytesUntilLimit() > 0)
								{
									corefMentionToEntityMentionMappings_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00010000));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									corefMentionToEntityMentionMappings_.Add(input.ReadUInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 144:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
								{
									entityMentionToCorefMentionMappings_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00020000));
								}
								entityMentionToCorefMentionMappings_.Add(input.ReadUInt32());
								break;
							}

							case 146:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))) && input.GetBytesUntilLimit() > 0)
								{
									entityMentionToCorefMentionMappings_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00020000));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									entityMentionToCorefMentionMappings_.Add(input.ReadUInt32());
								}
								input.PopLimit(limit);
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						sentence_ = Java.Util.Collections.UnmodifiableList(sentence_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						corefChain_ = Java.Util.Collections.UnmodifiableList(corefChain_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						sentencelessToken_ = Java.Util.Collections.UnmodifiableList(sentencelessToken_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						quote_ = Java.Util.Collections.UnmodifiableList(quote_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						mentions_ = Java.Util.Collections.UnmodifiableList(mentions_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						character_ = Java.Util.Collections.UnmodifiableList(character_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
					{
						sections_ = Java.Util.Collections.UnmodifiableList(sections_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
					{
						mentionsForCoref_ = Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						corefMentionToEntityMentionMappings_ = Java.Util.Collections.UnmodifiableList(corefMentionToEntityMentionMappings_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						entityMentionToCorefMentionMappings_ = Java.Util.Collections.UnmodifiableList(entityMentionToCorefMentionMappings_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Document_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Document_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Document), typeof(CoreNLPProtos.Document.Builder));
			}

			private int bitField0_;

			public const int TextFieldNumber = 1;

			private volatile object text_;

			/// <summary><code>required string text = 1;</code></summary>
			public bool HasText()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>required string text = 1;</code></summary>
			public string GetText()
			{
				object @ref = text_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						text_ = s;
					}
					return s;
				}
			}

			/// <summary><code>required string text = 1;</code></summary>
			public ByteString GetTextBytes()
			{
				object @ref = text_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					text_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SentenceFieldNumber = 2;

			private IList<CoreNLPProtos.Sentence> sentence_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			public IList<CoreNLPProtos.Sentence> GetSentenceList()
			{
				return sentence_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			public IList<CoreNLPProtos.ISentenceOrBuilder> GetSentenceOrBuilderList()
			{
				return sentence_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			public int GetSentenceCount()
			{
				return sentence_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			public CoreNLPProtos.Sentence GetSentence(int index)
			{
				return sentence_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
			public CoreNLPProtos.ISentenceOrBuilder GetSentenceOrBuilder(int index)
			{
				return sentence_[index];
			}

			public const int CorefchainFieldNumber = 3;

			private IList<CoreNLPProtos.CorefChain> corefChain_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			public IList<CoreNLPProtos.CorefChain> GetCorefChainList()
			{
				return corefChain_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			public IList<CoreNLPProtos.ICorefChainOrBuilder> GetCorefChainOrBuilderList()
			{
				return corefChain_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			public int GetCorefChainCount()
			{
				return corefChain_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			public CoreNLPProtos.CorefChain GetCorefChain(int index)
			{
				return corefChain_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
			public CoreNLPProtos.ICorefChainOrBuilder GetCorefChainOrBuilder(int index)
			{
				return corefChain_[index];
			}

			public const int DocidFieldNumber = 4;

			private volatile object docID_;

			/// <summary><code>optional string docID = 4;</code></summary>
			public bool HasDocID()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional string docID = 4;</code></summary>
			public string GetDocID()
			{
				object @ref = docID_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						docID_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string docID = 4;</code></summary>
			public ByteString GetDocIDBytes()
			{
				object @ref = docID_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					docID_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int DocdateFieldNumber = 7;

			private volatile object docDate_;

			/// <summary><code>optional string docDate = 7;</code></summary>
			public bool HasDocDate()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional string docDate = 7;</code></summary>
			public string GetDocDate()
			{
				object @ref = docDate_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						docDate_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string docDate = 7;</code></summary>
			public ByteString GetDocDateBytes()
			{
				object @ref = docDate_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					docDate_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int CalendarFieldNumber = 8;

			private long calendar_;

			/// <summary><code>optional uint64 calendar = 8;</code></summary>
			public bool HasCalendar()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional uint64 calendar = 8;</code></summary>
			public long GetCalendar()
			{
				return calendar_;
			}

			public const int SentencelesstokenFieldNumber = 5;

			private IList<CoreNLPProtos.Token> sentencelessToken_;

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			public IList<CoreNLPProtos.Token> GetSentencelessTokenList()
			{
				return sentencelessToken_;
			}

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			public IList<CoreNLPProtos.ITokenOrBuilder> GetSentencelessTokenOrBuilderList()
			{
				return sentencelessToken_;
			}

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			public int GetSentencelessTokenCount()
			{
				return sentencelessToken_.Count;
			}

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			public CoreNLPProtos.Token GetSentencelessToken(int index)
			{
				return sentencelessToken_[index];
			}

			/// <summary>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A peculiar field, for the corner case when a Document is
			/// serialized without any sentences. Otherwise
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
			/// </remarks>
			public CoreNLPProtos.ITokenOrBuilder GetSentencelessTokenOrBuilder(int index)
			{
				return sentencelessToken_[index];
			}

			public const int CharacterFieldNumber = 10;

			private IList<CoreNLPProtos.Token> character_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			public IList<CoreNLPProtos.Token> GetCharacterList()
			{
				return character_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			public IList<CoreNLPProtos.ITokenOrBuilder> GetCharacterOrBuilderList()
			{
				return character_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			public int GetCharacterCount()
			{
				return character_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			public CoreNLPProtos.Token GetCharacter(int index)
			{
				return character_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
			public CoreNLPProtos.ITokenOrBuilder GetCharacterOrBuilder(int index)
			{
				return character_[index];
			}

			public const int QuoteFieldNumber = 6;

			private IList<CoreNLPProtos.Quote> quote_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			public IList<CoreNLPProtos.Quote> GetQuoteList()
			{
				return quote_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			public IList<CoreNLPProtos.IQuoteOrBuilder> GetQuoteOrBuilderList()
			{
				return quote_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			public int GetQuoteCount()
			{
				return quote_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			public CoreNLPProtos.Quote GetQuote(int index)
			{
				return quote_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
			public CoreNLPProtos.IQuoteOrBuilder GetQuoteOrBuilder(int index)
			{
				return quote_[index];
			}

			public const int MentionsFieldNumber = 9;

			private IList<CoreNLPProtos.NERMention> mentions_;

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			public IList<CoreNLPProtos.NERMention> GetMentionsList()
			{
				return mentions_;
			}

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			public IList<CoreNLPProtos.INERMentionOrBuilder> GetMentionsOrBuilderList()
			{
				return mentions_;
			}

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			public int GetMentionsCount()
			{
				return mentions_.Count;
			}

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			public CoreNLPProtos.NERMention GetMentions(int index)
			{
				return mentions_[index];
			}

			/// <summary>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// This field is for entity mentions across the document.
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
			/// </remarks>
			public CoreNLPProtos.INERMentionOrBuilder GetMentionsOrBuilder(int index)
			{
				return mentions_[index];
			}

			public const int HasentitymentionsannotationFieldNumber = 13;

			private bool hasEntityMentionsAnnotation_;

			/// <summary>
			/// <pre>
			/// used to differentiate between null and empty list
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
			/// </summary>
			public bool HasHasEntityMentionsAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary>
			/// <pre>
			/// used to differentiate between null and empty list
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
			/// </summary>
			public bool GetHasEntityMentionsAnnotation()
			{
				return hasEntityMentionsAnnotation_;
			}

			public const int XmldocFieldNumber = 11;

			private bool xmlDoc_;

			/// <summary>
			/// <pre>
			/// xml information
			/// </pre>
			/// <code>optional bool xmlDoc = 11;</code>
			/// </summary>
			public bool HasXmlDoc()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary>
			/// <pre>
			/// xml information
			/// </pre>
			/// <code>optional bool xmlDoc = 11;</code>
			/// </summary>
			public bool GetXmlDoc()
			{
				return xmlDoc_;
			}

			public const int SectionsFieldNumber = 12;

			private IList<CoreNLPProtos.Section> sections_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			public IList<CoreNLPProtos.Section> GetSectionsList()
			{
				return sections_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			public IList<CoreNLPProtos.ISectionOrBuilder> GetSectionsOrBuilderList()
			{
				return sections_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			public int GetSectionsCount()
			{
				return sections_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			public CoreNLPProtos.Section GetSections(int index)
			{
				return sections_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
			public CoreNLPProtos.ISectionOrBuilder GetSectionsOrBuilder(int index)
			{
				return sections_[index];
			}

			public const int MentionsforcorefFieldNumber = 14;

			private IList<CoreNLPProtos.Mention> mentionsForCoref_;

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			public IList<CoreNLPProtos.Mention> GetMentionsForCorefList()
			{
				return mentionsForCoref_;
			}

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			public IList<CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefOrBuilderList()
			{
				return mentionsForCoref_;
			}

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			public int GetMentionsForCorefCount()
			{
				return mentionsForCoref_.Count;
			}

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			public CoreNLPProtos.Mention GetMentionsForCoref(int index)
			{
				return mentionsForCoref_[index];
			}

			/// <summary>
			/// <pre>
			/// coref mentions for entire document
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
			/// </summary>
			public CoreNLPProtos.IMentionOrBuilder GetMentionsForCorefOrBuilder(int index)
			{
				return mentionsForCoref_[index];
			}

			public const int HascorefmentionannotationFieldNumber = 15;

			private bool hasCorefMentionAnnotation_;

			/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
			public bool HasHasCorefMentionAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
			public bool GetHasCorefMentionAnnotation()
			{
				return hasCorefMentionAnnotation_;
			}

			public const int HascorefannotationFieldNumber = 16;

			private bool hasCorefAnnotation_;

			/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
			public bool HasHasCorefAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
			public bool GetHasCorefAnnotation()
			{
				return hasCorefAnnotation_;
			}

			public const int CorefmentiontoentitymentionmappingsFieldNumber = 17;

			private IList<int> corefMentionToEntityMentionMappings_;

			/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
			public IList<int> GetCorefMentionToEntityMentionMappingsList()
			{
				return corefMentionToEntityMentionMappings_;
			}

			/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
			public int GetCorefMentionToEntityMentionMappingsCount()
			{
				return corefMentionToEntityMentionMappings_.Count;
			}

			/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
			public int GetCorefMentionToEntityMentionMappings(int index)
			{
				return corefMentionToEntityMentionMappings_[index];
			}

			public const int EntitymentiontocorefmentionmappingsFieldNumber = 18;

			private IList<int> entityMentionToCorefMentionMappings_;

			/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
			public IList<int> GetEntityMentionToCorefMentionMappingsList()
			{
				return entityMentionToCorefMentionMappings_;
			}

			/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
			public int GetEntityMentionToCorefMentionMappingsCount()
			{
				return entityMentionToCorefMentionMappings_.Count;
			}

			/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
			public int GetEntityMentionToCorefMentionMappings(int index)
			{
				return entityMentionToCorefMentionMappings_[index];
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasText())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				for (int i = 0; i < GetSentenceCount(); i++)
				{
					if (!GetSentence(i).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_1 = 0; i_1 < GetCorefChainCount(); i_1++)
				{
					if (!GetCorefChain(i_1).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_2 = 0; i_2 < GetSentencelessTokenCount(); i_2++)
				{
					if (!GetSentencelessToken(i_2).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_3 = 0; i_3 < GetCharacterCount(); i_3++)
				{
					if (!GetCharacter(i_3).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_4 = 0; i_4 < GetQuoteCount(); i_4++)
				{
					if (!GetQuote(i_4).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_5 = 0; i_5 < GetMentionsCount(); i_5++)
				{
					if (!GetMentions(i_5).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_6 = 0; i_6 < GetSectionsCount(); i_6++)
				{
					if (!GetSections(i_6).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (!ExtensionsAreInitialized())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				GeneratedMessageV3.ExtendableMessage.ExtensionWriter extensionWriter = NewExtensionWriter();
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 1, text_);
				}
				for (int i = 0; i < sentence_.Count; i++)
				{
					output.WriteMessage(2, sentence_[i]);
				}
				for (int i_1 = 0; i_1 < corefChain_.Count; i_1++)
				{
					output.WriteMessage(3, corefChain_[i_1]);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					GeneratedMessageV3.WriteString(output, 4, docID_);
				}
				for (int i_2 = 0; i_2 < sentencelessToken_.Count; i_2++)
				{
					output.WriteMessage(5, sentencelessToken_[i_2]);
				}
				for (int i_3 = 0; i_3 < quote_.Count; i_3++)
				{
					output.WriteMessage(6, quote_[i_3]);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 7, docDate_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteUInt64(8, calendar_);
				}
				for (int i_4 = 0; i_4 < mentions_.Count; i_4++)
				{
					output.WriteMessage(9, mentions_[i_4]);
				}
				for (int i_5 = 0; i_5 < character_.Count; i_5++)
				{
					output.WriteMessage(10, character_[i_5]);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteBool(11, xmlDoc_);
				}
				for (int i_6 = 0; i_6 < sections_.Count; i_6++)
				{
					output.WriteMessage(12, sections_[i_6]);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteBool(13, hasEntityMentionsAnnotation_);
				}
				for (int i_7 = 0; i_7 < mentionsForCoref_.Count; i_7++)
				{
					output.WriteMessage(14, mentionsForCoref_[i_7]);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteBool(15, hasCorefMentionAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					output.WriteBool(16, hasCorefAnnotation_);
				}
				for (int i_8 = 0; i_8 < corefMentionToEntityMentionMappings_.Count; i_8++)
				{
					output.WriteUInt32(17, corefMentionToEntityMentionMappings_[i_8]);
				}
				for (int i_9 = 0; i_9 < entityMentionToCorefMentionMappings_.Count; i_9++)
				{
					output.WriteUInt32(18, entityMentionToCorefMentionMappings_[i_9]);
				}
				extensionWriter.WriteUntil(256, output);
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, text_);
				}
				for (int i = 0; i < sentence_.Count; i++)
				{
					size += CodedOutputStream.ComputeMessageSize(2, sentence_[i]);
				}
				for (int i_1 = 0; i_1 < corefChain_.Count; i_1++)
				{
					size += CodedOutputStream.ComputeMessageSize(3, corefChain_[i_1]);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += GeneratedMessageV3.ComputeStringSize(4, docID_);
				}
				for (int i_2 = 0; i_2 < sentencelessToken_.Count; i_2++)
				{
					size += CodedOutputStream.ComputeMessageSize(5, sentencelessToken_[i_2]);
				}
				for (int i_3 = 0; i_3 < quote_.Count; i_3++)
				{
					size += CodedOutputStream.ComputeMessageSize(6, quote_[i_3]);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(7, docDate_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeUInt64Size(8, calendar_);
				}
				for (int i_4 = 0; i_4 < mentions_.Count; i_4++)
				{
					size += CodedOutputStream.ComputeMessageSize(9, mentions_[i_4]);
				}
				for (int i_5 = 0; i_5 < character_.Count; i_5++)
				{
					size += CodedOutputStream.ComputeMessageSize(10, character_[i_5]);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeBoolSize(11, xmlDoc_);
				}
				for (int i_6 = 0; i_6 < sections_.Count; i_6++)
				{
					size += CodedOutputStream.ComputeMessageSize(12, sections_[i_6]);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeBoolSize(13, hasEntityMentionsAnnotation_);
				}
				for (int i_7 = 0; i_7 < mentionsForCoref_.Count; i_7++)
				{
					size += CodedOutputStream.ComputeMessageSize(14, mentionsForCoref_[i_7]);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeBoolSize(15, hasCorefMentionAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += CodedOutputStream.ComputeBoolSize(16, hasCorefAnnotation_);
				}
				{
					int dataSize = 0;
					for (int i_8 = 0; i_8 < corefMentionToEntityMentionMappings_.Count; i_8++)
					{
						dataSize += CodedOutputStream.ComputeUInt32SizeNoTag(corefMentionToEntityMentionMappings_[i_8]);
					}
					size += dataSize;
					size += 2 * GetCorefMentionToEntityMentionMappingsList().Count;
				}
				{
					int dataSize = 0;
					for (int i_8 = 0; i_8 < entityMentionToCorefMentionMappings_.Count; i_8++)
					{
						dataSize += CodedOutputStream.ComputeUInt32SizeNoTag(entityMentionToCorefMentionMappings_[i_8]);
					}
					size += dataSize;
					size += 2 * GetEntityMentionToCorefMentionMappingsList().Count;
				}
				size += ExtensionsSerializedSize();
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Document))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Document other = (CoreNLPProtos.Document)obj;
				bool result = true;
				result = result && (HasText() == other.HasText());
				if (HasText())
				{
					result = result && GetText().Equals(other.GetText());
				}
				result = result && GetSentenceList().Equals(other.GetSentenceList());
				result = result && GetCorefChainList().Equals(other.GetCorefChainList());
				result = result && (HasDocID() == other.HasDocID());
				if (HasDocID())
				{
					result = result && GetDocID().Equals(other.GetDocID());
				}
				result = result && (HasDocDate() == other.HasDocDate());
				if (HasDocDate())
				{
					result = result && GetDocDate().Equals(other.GetDocDate());
				}
				result = result && (HasCalendar() == other.HasCalendar());
				if (HasCalendar())
				{
					result = result && (GetCalendar() == other.GetCalendar());
				}
				result = result && GetSentencelessTokenList().Equals(other.GetSentencelessTokenList());
				result = result && GetCharacterList().Equals(other.GetCharacterList());
				result = result && GetQuoteList().Equals(other.GetQuoteList());
				result = result && GetMentionsList().Equals(other.GetMentionsList());
				result = result && (HasHasEntityMentionsAnnotation() == other.HasHasEntityMentionsAnnotation());
				if (HasHasEntityMentionsAnnotation())
				{
					result = result && (GetHasEntityMentionsAnnotation() == other.GetHasEntityMentionsAnnotation());
				}
				result = result && (HasXmlDoc() == other.HasXmlDoc());
				if (HasXmlDoc())
				{
					result = result && (GetXmlDoc() == other.GetXmlDoc());
				}
				result = result && GetSectionsList().Equals(other.GetSectionsList());
				result = result && GetMentionsForCorefList().Equals(other.GetMentionsForCorefList());
				result = result && (HasHasCorefMentionAnnotation() == other.HasHasCorefMentionAnnotation());
				if (HasHasCorefMentionAnnotation())
				{
					result = result && (GetHasCorefMentionAnnotation() == other.GetHasCorefMentionAnnotation());
				}
				result = result && (HasHasCorefAnnotation() == other.HasHasCorefAnnotation());
				if (HasHasCorefAnnotation())
				{
					result = result && (GetHasCorefAnnotation() == other.GetHasCorefAnnotation());
				}
				result = result && GetCorefMentionToEntityMentionMappingsList().Equals(other.GetCorefMentionToEntityMentionMappingsList());
				result = result && GetEntityMentionToCorefMentionMappingsList().Equals(other.GetEntityMentionToCorefMentionMappingsList());
				result = result && unknownFields.Equals(other.unknownFields);
				result = result && GetExtensionFields().Equals(other.GetExtensionFields());
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasText())
				{
					hash = (37 * hash) + TextFieldNumber;
					hash = (53 * hash) + GetText().GetHashCode();
				}
				if (GetSentenceCount() > 0)
				{
					hash = (37 * hash) + SentenceFieldNumber;
					hash = (53 * hash) + GetSentenceList().GetHashCode();
				}
				if (GetCorefChainCount() > 0)
				{
					hash = (37 * hash) + CorefchainFieldNumber;
					hash = (53 * hash) + GetCorefChainList().GetHashCode();
				}
				if (HasDocID())
				{
					hash = (37 * hash) + DocidFieldNumber;
					hash = (53 * hash) + GetDocID().GetHashCode();
				}
				if (HasDocDate())
				{
					hash = (37 * hash) + DocdateFieldNumber;
					hash = (53 * hash) + GetDocDate().GetHashCode();
				}
				if (HasCalendar())
				{
					hash = (37 * hash) + CalendarFieldNumber;
					hash = (53 * hash) + Internal.HashLong(GetCalendar());
				}
				if (GetSentencelessTokenCount() > 0)
				{
					hash = (37 * hash) + SentencelesstokenFieldNumber;
					hash = (53 * hash) + GetSentencelessTokenList().GetHashCode();
				}
				if (GetCharacterCount() > 0)
				{
					hash = (37 * hash) + CharacterFieldNumber;
					hash = (53 * hash) + GetCharacterList().GetHashCode();
				}
				if (GetQuoteCount() > 0)
				{
					hash = (37 * hash) + QuoteFieldNumber;
					hash = (53 * hash) + GetQuoteList().GetHashCode();
				}
				if (GetMentionsCount() > 0)
				{
					hash = (37 * hash) + MentionsFieldNumber;
					hash = (53 * hash) + GetMentionsList().GetHashCode();
				}
				if (HasHasEntityMentionsAnnotation())
				{
					hash = (37 * hash) + HasentitymentionsannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasEntityMentionsAnnotation());
				}
				if (HasXmlDoc())
				{
					hash = (37 * hash) + XmldocFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetXmlDoc());
				}
				if (GetSectionsCount() > 0)
				{
					hash = (37 * hash) + SectionsFieldNumber;
					hash = (53 * hash) + GetSectionsList().GetHashCode();
				}
				if (GetMentionsForCorefCount() > 0)
				{
					hash = (37 * hash) + MentionsforcorefFieldNumber;
					hash = (53 * hash) + GetMentionsForCorefList().GetHashCode();
				}
				if (HasHasCorefMentionAnnotation())
				{
					hash = (37 * hash) + HascorefmentionannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasCorefMentionAnnotation());
				}
				if (HasHasCorefAnnotation())
				{
					hash = (37 * hash) + HascorefannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasCorefAnnotation());
				}
				if (GetCorefMentionToEntityMentionMappingsCount() > 0)
				{
					hash = (37 * hash) + CorefmentiontoentitymentionmappingsFieldNumber;
					hash = (53 * hash) + GetCorefMentionToEntityMentionMappingsList().GetHashCode();
				}
				if (GetEntityMentionToCorefMentionMappingsCount() > 0)
				{
					hash = (37 * hash) + EntitymentiontocorefmentionmappingsFieldNumber;
					hash = (53 * hash) + GetEntityMentionToCorefMentionMappingsList().GetHashCode();
				}
				hash = HashFields(hash, GetExtensionFields());
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Document ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Document ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Document ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Document ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Document ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Document ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Document ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Document ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Document ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Document ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Document.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Document.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Document.Builder NewBuilder(CoreNLPProtos.Document prototype)
			{
				return ((CoreNLPProtos.Document.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Document.Builder() : new CoreNLPProtos.Document.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Document.Builder builder = new CoreNLPProtos.Document.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A document; that is, the equivalent of an Annotation.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A document; that is, the equivalent of an Annotation.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Document</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.ExtendableBuilder<CoreNLPProtos.Document, CoreNLPProtos.Document.Builder>, CoreNLPProtos.IDocumentOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Document)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Document_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Document_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Document), typeof(CoreNLPProtos.Document.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Document.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetSentenceFieldBuilder();
						GetCorefChainFieldBuilder();
						GetSentencelessTokenFieldBuilder();
						GetCharacterFieldBuilder();
						GetQuoteFieldBuilder();
						GetMentionsFieldBuilder();
						GetSectionsFieldBuilder();
						GetMentionsForCorefFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					text_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					if (sentenceBuilder_ == null)
					{
						sentence_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					else
					{
						sentenceBuilder_.Clear();
					}
					if (corefChainBuilder_ == null)
					{
						corefChain_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					}
					else
					{
						corefChainBuilder_.Clear();
					}
					docID_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					docDate_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					calendar_ = 0L;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					if (sentencelessTokenBuilder_ == null)
					{
						sentencelessToken_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					}
					else
					{
						sentencelessTokenBuilder_.Clear();
					}
					if (characterBuilder_ == null)
					{
						character_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					}
					else
					{
						characterBuilder_.Clear();
					}
					if (quoteBuilder_ == null)
					{
						quote_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					}
					else
					{
						quoteBuilder_.Clear();
					}
					if (mentionsBuilder_ == null)
					{
						mentions_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					}
					else
					{
						mentionsBuilder_.Clear();
					}
					hasEntityMentionsAnnotation_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					xmlDoc_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					if (sectionsBuilder_ == null)
					{
						sections_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					}
					else
					{
						sectionsBuilder_.Clear();
					}
					if (mentionsForCorefBuilder_ == null)
					{
						mentionsForCoref_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					}
					else
					{
						mentionsForCorefBuilder_.Clear();
					}
					hasCorefMentionAnnotation_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					hasCorefAnnotation_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					corefMentionToEntityMentionMappings_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					entityMentionToCorefMentionMappings_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Document_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Document.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Document result = ((CoreNLPProtos.Document)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Document result = new CoreNLPProtos.Document(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.text_ = text_;
					if (sentenceBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							sentence_ = Java.Util.Collections.UnmodifiableList(sentence_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						result.sentence_ = sentence_;
					}
					else
					{
						result.sentence_ = sentenceBuilder_.Build();
					}
					if (corefChainBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
						{
							corefChain_ = Java.Util.Collections.UnmodifiableList(corefChain_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						}
						result.corefChain_ = corefChain_;
					}
					else
					{
						result.corefChain_ = corefChainBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.docID_ = docID_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.docDate_ = docDate_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.calendar_ = calendar_;
					if (sentencelessTokenBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
						{
							sentencelessToken_ = Java.Util.Collections.UnmodifiableList(sentencelessToken_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						}
						result.sentencelessToken_ = sentencelessToken_;
					}
					else
					{
						result.sentencelessToken_ = sentencelessTokenBuilder_.Build();
					}
					if (characterBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
						{
							character_ = Java.Util.Collections.UnmodifiableList(character_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
						}
						result.character_ = character_;
					}
					else
					{
						result.character_ = characterBuilder_.Build();
					}
					if (quoteBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
						{
							quote_ = Java.Util.Collections.UnmodifiableList(quote_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
						}
						result.quote_ = quote_;
					}
					else
					{
						result.quote_ = quoteBuilder_.Build();
					}
					if (mentionsBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
						{
							mentions_ = Java.Util.Collections.UnmodifiableList(mentions_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
						}
						result.mentions_ = mentions_;
					}
					else
					{
						result.mentions_ = mentionsBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.hasEntityMentionsAnnotation_ = hasEntityMentionsAnnotation_;
					if (((from_bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.xmlDoc_ = xmlDoc_;
					if (sectionsBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
						{
							sections_ = Java.Util.Collections.UnmodifiableList(sections_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
						}
						result.sections_ = sections_;
					}
					else
					{
						result.sections_ = sectionsBuilder_.Build();
					}
					if (mentionsForCorefBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
						{
							mentionsForCoref_ = Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
						}
						result.mentionsForCoref_ = mentionsForCoref_;
					}
					else
					{
						result.mentionsForCoref_ = mentionsForCorefBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.hasCorefMentionAnnotation_ = hasCorefMentionAnnotation_;
					if (((from_bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					result.hasCorefAnnotation_ = hasCorefAnnotation_;
					if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						corefMentionToEntityMentionMappings_ = Java.Util.Collections.UnmodifiableList(corefMentionToEntityMentionMappings_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					}
					result.corefMentionToEntityMentionMappings_ = corefMentionToEntityMentionMappings_;
					if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						entityMentionToCorefMentionMappings_ = Java.Util.Collections.UnmodifiableList(entityMentionToCorefMentionMappings_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					}
					result.entityMentionToCorefMentionMappings_ = entityMentionToCorefMentionMappings_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Document.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Document.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Document.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Document.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Document.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Document.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Document.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Document.Builder SetExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Document, Type> extension, Type value)
				{
					return (CoreNLPProtos.Document.Builder)base.SetExtension(extension, value);
				}

				public override CoreNLPProtos.Document.Builder SetExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Document, IList<Type>> extension, int index, Type value)
				{
					return (CoreNLPProtos.Document.Builder)base.SetExtension(extension, index, value);
				}

				public override CoreNLPProtos.Document.Builder AddExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Document, IList<Type>> extension, Type value)
				{
					return (CoreNLPProtos.Document.Builder)base.AddExtension(extension, value);
				}

				public override CoreNLPProtos.Document.Builder ClearExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Document, object> extension)
				{
					return (CoreNLPProtos.Document.Builder)base.ClearExtension(extension);
				}

				public override CoreNLPProtos.Document.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Document)
					{
						return MergeFrom((CoreNLPProtos.Document)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Document.Builder MergeFrom(CoreNLPProtos.Document other)
				{
					if (other == CoreNLPProtos.Document.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasText())
					{
						bitField0_ |= unchecked((int)(0x00000001));
						text_ = other.text_;
						OnChanged();
					}
					if (sentenceBuilder_ == null)
					{
						if (!other.sentence_.IsEmpty())
						{
							if (sentence_.IsEmpty())
							{
								sentence_ = other.sentence_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
							}
							else
							{
								EnsureSentenceIsMutable();
								Sharpen.Collections.AddAll(sentence_, other.sentence_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.sentence_.IsEmpty())
						{
							if (sentenceBuilder_.IsEmpty())
							{
								sentenceBuilder_.Dispose();
								sentenceBuilder_ = null;
								sentence_ = other.sentence_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
								sentenceBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetSentenceFieldBuilder() : null;
							}
							else
							{
								sentenceBuilder_.AddAllMessages(other.sentence_);
							}
						}
					}
					if (corefChainBuilder_ == null)
					{
						if (!other.corefChain_.IsEmpty())
						{
							if (corefChain_.IsEmpty())
							{
								corefChain_ = other.corefChain_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
							}
							else
							{
								EnsureCorefChainIsMutable();
								Sharpen.Collections.AddAll(corefChain_, other.corefChain_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.corefChain_.IsEmpty())
						{
							if (corefChainBuilder_.IsEmpty())
							{
								corefChainBuilder_.Dispose();
								corefChainBuilder_ = null;
								corefChain_ = other.corefChain_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
								corefChainBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetCorefChainFieldBuilder() : null;
							}
							else
							{
								corefChainBuilder_.AddAllMessages(other.corefChain_);
							}
						}
					}
					if (other.HasDocID())
					{
						bitField0_ |= unchecked((int)(0x00000008));
						docID_ = other.docID_;
						OnChanged();
					}
					if (other.HasDocDate())
					{
						bitField0_ |= unchecked((int)(0x00000010));
						docDate_ = other.docDate_;
						OnChanged();
					}
					if (other.HasCalendar())
					{
						SetCalendar(other.GetCalendar());
					}
					if (sentencelessTokenBuilder_ == null)
					{
						if (!other.sentencelessToken_.IsEmpty())
						{
							if (sentencelessToken_.IsEmpty())
							{
								sentencelessToken_ = other.sentencelessToken_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
							}
							else
							{
								EnsureSentencelessTokenIsMutable();
								Sharpen.Collections.AddAll(sentencelessToken_, other.sentencelessToken_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.sentencelessToken_.IsEmpty())
						{
							if (sentencelessTokenBuilder_.IsEmpty())
							{
								sentencelessTokenBuilder_.Dispose();
								sentencelessTokenBuilder_ = null;
								sentencelessToken_ = other.sentencelessToken_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
								sentencelessTokenBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetSentencelessTokenFieldBuilder() : null;
							}
							else
							{
								sentencelessTokenBuilder_.AddAllMessages(other.sentencelessToken_);
							}
						}
					}
					if (characterBuilder_ == null)
					{
						if (!other.character_.IsEmpty())
						{
							if (character_.IsEmpty())
							{
								character_ = other.character_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
							}
							else
							{
								EnsureCharacterIsMutable();
								Sharpen.Collections.AddAll(character_, other.character_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.character_.IsEmpty())
						{
							if (characterBuilder_.IsEmpty())
							{
								characterBuilder_.Dispose();
								characterBuilder_ = null;
								character_ = other.character_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
								characterBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetCharacterFieldBuilder() : null;
							}
							else
							{
								characterBuilder_.AddAllMessages(other.character_);
							}
						}
					}
					if (quoteBuilder_ == null)
					{
						if (!other.quote_.IsEmpty())
						{
							if (quote_.IsEmpty())
							{
								quote_ = other.quote_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
							}
							else
							{
								EnsureQuoteIsMutable();
								Sharpen.Collections.AddAll(quote_, other.quote_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.quote_.IsEmpty())
						{
							if (quoteBuilder_.IsEmpty())
							{
								quoteBuilder_.Dispose();
								quoteBuilder_ = null;
								quote_ = other.quote_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
								quoteBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetQuoteFieldBuilder() : null;
							}
							else
							{
								quoteBuilder_.AddAllMessages(other.quote_);
							}
						}
					}
					if (mentionsBuilder_ == null)
					{
						if (!other.mentions_.IsEmpty())
						{
							if (mentions_.IsEmpty())
							{
								mentions_ = other.mentions_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
							}
							else
							{
								EnsureMentionsIsMutable();
								Sharpen.Collections.AddAll(mentions_, other.mentions_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.mentions_.IsEmpty())
						{
							if (mentionsBuilder_.IsEmpty())
							{
								mentionsBuilder_.Dispose();
								mentionsBuilder_ = null;
								mentions_ = other.mentions_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
								mentionsBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetMentionsFieldBuilder() : null;
							}
							else
							{
								mentionsBuilder_.AddAllMessages(other.mentions_);
							}
						}
					}
					if (other.HasHasEntityMentionsAnnotation())
					{
						SetHasEntityMentionsAnnotation(other.GetHasEntityMentionsAnnotation());
					}
					if (other.HasXmlDoc())
					{
						SetXmlDoc(other.GetXmlDoc());
					}
					if (sectionsBuilder_ == null)
					{
						if (!other.sections_.IsEmpty())
						{
							if (sections_.IsEmpty())
							{
								sections_ = other.sections_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
							}
							else
							{
								EnsureSectionsIsMutable();
								Sharpen.Collections.AddAll(sections_, other.sections_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.sections_.IsEmpty())
						{
							if (sectionsBuilder_.IsEmpty())
							{
								sectionsBuilder_.Dispose();
								sectionsBuilder_ = null;
								sections_ = other.sections_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
								sectionsBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetSectionsFieldBuilder() : null;
							}
							else
							{
								sectionsBuilder_.AddAllMessages(other.sections_);
							}
						}
					}
					if (mentionsForCorefBuilder_ == null)
					{
						if (!other.mentionsForCoref_.IsEmpty())
						{
							if (mentionsForCoref_.IsEmpty())
							{
								mentionsForCoref_ = other.mentionsForCoref_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
							}
							else
							{
								EnsureMentionsForCorefIsMutable();
								Sharpen.Collections.AddAll(mentionsForCoref_, other.mentionsForCoref_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.mentionsForCoref_.IsEmpty())
						{
							if (mentionsForCorefBuilder_.IsEmpty())
							{
								mentionsForCorefBuilder_.Dispose();
								mentionsForCorefBuilder_ = null;
								mentionsForCoref_ = other.mentionsForCoref_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
								mentionsForCorefBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetMentionsForCorefFieldBuilder() : null;
							}
							else
							{
								mentionsForCorefBuilder_.AddAllMessages(other.mentionsForCoref_);
							}
						}
					}
					if (other.HasHasCorefMentionAnnotation())
					{
						SetHasCorefMentionAnnotation(other.GetHasCorefMentionAnnotation());
					}
					if (other.HasHasCorefAnnotation())
					{
						SetHasCorefAnnotation(other.GetHasCorefAnnotation());
					}
					if (!other.corefMentionToEntityMentionMappings_.IsEmpty())
					{
						if (corefMentionToEntityMentionMappings_.IsEmpty())
						{
							corefMentionToEntityMentionMappings_ = other.corefMentionToEntityMentionMappings_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
						}
						else
						{
							EnsureCorefMentionToEntityMentionMappingsIsMutable();
							Sharpen.Collections.AddAll(corefMentionToEntityMentionMappings_, other.corefMentionToEntityMentionMappings_);
						}
						OnChanged();
					}
					if (!other.entityMentionToCorefMentionMappings_.IsEmpty())
					{
						if (entityMentionToCorefMentionMappings_.IsEmpty())
						{
							entityMentionToCorefMentionMappings_ = other.entityMentionToCorefMentionMappings_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
						}
						else
						{
							EnsureEntityMentionToCorefMentionMappingsIsMutable();
							Sharpen.Collections.AddAll(entityMentionToCorefMentionMappings_, other.entityMentionToCorefMentionMappings_);
						}
						OnChanged();
					}
					this.MergeExtensionFields(other);
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasText())
					{
						return false;
					}
					for (int i = 0; i < GetSentenceCount(); i++)
					{
						if (!GetSentence(i).IsInitialized())
						{
							return false;
						}
					}
					for (int i_1 = 0; i_1 < GetCorefChainCount(); i_1++)
					{
						if (!GetCorefChain(i_1).IsInitialized())
						{
							return false;
						}
					}
					for (int i_2 = 0; i_2 < GetSentencelessTokenCount(); i_2++)
					{
						if (!GetSentencelessToken(i_2).IsInitialized())
						{
							return false;
						}
					}
					for (int i_3 = 0; i_3 < GetCharacterCount(); i_3++)
					{
						if (!GetCharacter(i_3).IsInitialized())
						{
							return false;
						}
					}
					for (int i_4 = 0; i_4 < GetQuoteCount(); i_4++)
					{
						if (!GetQuote(i_4).IsInitialized())
						{
							return false;
						}
					}
					for (int i_5 = 0; i_5 < GetMentionsCount(); i_5++)
					{
						if (!GetMentions(i_5).IsInitialized())
						{
							return false;
						}
					}
					for (int i_6 = 0; i_6 < GetSectionsCount(); i_6++)
					{
						if (!GetSections(i_6).IsInitialized())
						{
							return false;
						}
					}
					if (!ExtensionsAreInitialized())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Document parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Document)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private object text_ = string.Empty;

				/// <summary><code>required string text = 1;</code></summary>
				public bool HasText()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required string text = 1;</code></summary>
				public string GetText()
				{
					object @ref = text_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							text_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>required string text = 1;</code></summary>
				public ByteString GetTextBytes()
				{
					object @ref = text_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						text_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>required string text = 1;</code></summary>
				public CoreNLPProtos.Document.Builder SetText(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					text_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required string text = 1;</code></summary>
				public CoreNLPProtos.Document.Builder ClearText()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					text_ = GetDefaultInstance().GetText();
					OnChanged();
					return this;
				}

				/// <summary><code>required string text = 1;</code></summary>
				public CoreNLPProtos.Document.Builder SetTextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					text_ = value;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.Sentence> sentence_ = Java.Util.Collections.EmptyList();

				private void EnsureSentenceIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						sentence_ = new List<CoreNLPProtos.Sentence>(sentence_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Sentence, CoreNLPProtos.Sentence.Builder, CoreNLPProtos.ISentenceOrBuilder> sentenceBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public IList<CoreNLPProtos.Sentence> GetSentenceList()
				{
					if (sentenceBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(sentence_);
					}
					else
					{
						return sentenceBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public int GetSentenceCount()
				{
					if (sentenceBuilder_ == null)
					{
						return sentence_.Count;
					}
					else
					{
						return sentenceBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Sentence GetSentence(int index)
				{
					if (sentenceBuilder_ == null)
					{
						return sentence_[index];
					}
					else
					{
						return sentenceBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder SetSentence(int index, CoreNLPProtos.Sentence value)
				{
					if (sentenceBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentenceIsMutable();
						sentence_.Set(index, value);
						OnChanged();
					}
					else
					{
						sentenceBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder SetSentence(int index, CoreNLPProtos.Sentence.Builder builderForValue)
				{
					if (sentenceBuilder_ == null)
					{
						EnsureSentenceIsMutable();
						sentence_.Set(index, ((CoreNLPProtos.Sentence)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentenceBuilder_.SetMessage(index, ((CoreNLPProtos.Sentence)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder AddSentence(CoreNLPProtos.Sentence value)
				{
					if (sentenceBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentenceIsMutable();
						sentence_.Add(value);
						OnChanged();
					}
					else
					{
						sentenceBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder AddSentence(int index, CoreNLPProtos.Sentence value)
				{
					if (sentenceBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentenceIsMutable();
						sentence_.Add(index, value);
						OnChanged();
					}
					else
					{
						sentenceBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder AddSentence(CoreNLPProtos.Sentence.Builder builderForValue)
				{
					if (sentenceBuilder_ == null)
					{
						EnsureSentenceIsMutable();
						sentence_.Add(((CoreNLPProtos.Sentence)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentenceBuilder_.AddMessage(((CoreNLPProtos.Sentence)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder AddSentence(int index, CoreNLPProtos.Sentence.Builder builderForValue)
				{
					if (sentenceBuilder_ == null)
					{
						EnsureSentenceIsMutable();
						sentence_.Add(index, ((CoreNLPProtos.Sentence)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentenceBuilder_.AddMessage(index, ((CoreNLPProtos.Sentence)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder AddAllSentence<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Sentence
				{
					if (sentenceBuilder_ == null)
					{
						EnsureSentenceIsMutable();
						AbstractMessageLite.Builder.AddAll(values, sentence_);
						OnChanged();
					}
					else
					{
						sentenceBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder ClearSentence()
				{
					if (sentenceBuilder_ == null)
					{
						sentence_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						OnChanged();
					}
					else
					{
						sentenceBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Document.Builder RemoveSentence(int index)
				{
					if (sentenceBuilder_ == null)
					{
						EnsureSentenceIsMutable();
						sentence_.Remove(index);
						OnChanged();
					}
					else
					{
						sentenceBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Sentence.Builder GetSentenceBuilder(int index)
				{
					return GetSentenceFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.ISentenceOrBuilder GetSentenceOrBuilder(int index)
				{
					if (sentenceBuilder_ == null)
					{
						return sentence_[index];
					}
					else
					{
						return sentenceBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public IList<CoreNLPProtos.ISentenceOrBuilder> GetSentenceOrBuilderList()
				{
					if (sentenceBuilder_ != null)
					{
						return sentenceBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(sentence_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddSentenceBuilder()
				{
					return GetSentenceFieldBuilder().AddBuilder(CoreNLPProtos.Sentence.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddSentenceBuilder(int index)
				{
					return GetSentenceFieldBuilder().AddBuilder(index, CoreNLPProtos.Sentence.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;</code></summary>
				public IList<CoreNLPProtos.Sentence.Builder> GetSentenceBuilderList()
				{
					return GetSentenceFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Sentence, CoreNLPProtos.Sentence.Builder, CoreNLPProtos.ISentenceOrBuilder> GetSentenceFieldBuilder()
				{
					if (sentenceBuilder_ == null)
					{
						sentenceBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Sentence, CoreNLPProtos.Sentence.Builder, CoreNLPProtos.ISentenceOrBuilder>(sentence_, ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))), GetParentForChildren
							(), IsClean());
						sentence_ = null;
					}
					return sentenceBuilder_;
				}

				private IList<CoreNLPProtos.CorefChain> corefChain_ = Java.Util.Collections.EmptyList();

				private void EnsureCorefChainIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						corefChain_ = new List<CoreNLPProtos.CorefChain>(corefChain_);
						bitField0_ |= unchecked((int)(0x00000004));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.CorefChain, CoreNLPProtos.CorefChain.Builder, CoreNLPProtos.ICorefChainOrBuilder> corefChainBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public IList<CoreNLPProtos.CorefChain> GetCorefChainList()
				{
					if (corefChainBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(corefChain_);
					}
					else
					{
						return corefChainBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public int GetCorefChainCount()
				{
					if (corefChainBuilder_ == null)
					{
						return corefChain_.Count;
					}
					else
					{
						return corefChainBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.CorefChain GetCorefChain(int index)
				{
					if (corefChainBuilder_ == null)
					{
						return corefChain_[index];
					}
					else
					{
						return corefChainBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder SetCorefChain(int index, CoreNLPProtos.CorefChain value)
				{
					if (corefChainBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCorefChainIsMutable();
						corefChain_.Set(index, value);
						OnChanged();
					}
					else
					{
						corefChainBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder SetCorefChain(int index, CoreNLPProtos.CorefChain.Builder builderForValue)
				{
					if (corefChainBuilder_ == null)
					{
						EnsureCorefChainIsMutable();
						corefChain_.Set(index, ((CoreNLPProtos.CorefChain)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						corefChainBuilder_.SetMessage(index, ((CoreNLPProtos.CorefChain)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder AddCorefChain(CoreNLPProtos.CorefChain value)
				{
					if (corefChainBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCorefChainIsMutable();
						corefChain_.Add(value);
						OnChanged();
					}
					else
					{
						corefChainBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder AddCorefChain(int index, CoreNLPProtos.CorefChain value)
				{
					if (corefChainBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCorefChainIsMutable();
						corefChain_.Add(index, value);
						OnChanged();
					}
					else
					{
						corefChainBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder AddCorefChain(CoreNLPProtos.CorefChain.Builder builderForValue)
				{
					if (corefChainBuilder_ == null)
					{
						EnsureCorefChainIsMutable();
						corefChain_.Add(((CoreNLPProtos.CorefChain)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						corefChainBuilder_.AddMessage(((CoreNLPProtos.CorefChain)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder AddCorefChain(int index, CoreNLPProtos.CorefChain.Builder builderForValue)
				{
					if (corefChainBuilder_ == null)
					{
						EnsureCorefChainIsMutable();
						corefChain_.Add(index, ((CoreNLPProtos.CorefChain)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						corefChainBuilder_.AddMessage(index, ((CoreNLPProtos.CorefChain)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder AddAllCorefChain<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.CorefChain
				{
					if (corefChainBuilder_ == null)
					{
						EnsureCorefChainIsMutable();
						AbstractMessageLite.Builder.AddAll(values, corefChain_);
						OnChanged();
					}
					else
					{
						corefChainBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder ClearCorefChain()
				{
					if (corefChainBuilder_ == null)
					{
						corefChain_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						OnChanged();
					}
					else
					{
						corefChainBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.Document.Builder RemoveCorefChain(int index)
				{
					if (corefChainBuilder_ == null)
					{
						EnsureCorefChainIsMutable();
						corefChain_.Remove(index);
						OnChanged();
					}
					else
					{
						corefChainBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.CorefChain.Builder GetCorefChainBuilder(int index)
				{
					return GetCorefChainFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.ICorefChainOrBuilder GetCorefChainOrBuilder(int index)
				{
					if (corefChainBuilder_ == null)
					{
						return corefChain_[index];
					}
					else
					{
						return corefChainBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public IList<CoreNLPProtos.ICorefChainOrBuilder> GetCorefChainOrBuilderList()
				{
					if (corefChainBuilder_ != null)
					{
						return corefChainBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(corefChain_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.CorefChain.Builder AddCorefChainBuilder()
				{
					return GetCorefChainFieldBuilder().AddBuilder(CoreNLPProtos.CorefChain.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public CoreNLPProtos.CorefChain.Builder AddCorefChainBuilder(int index)
				{
					return GetCorefChainFieldBuilder().AddBuilder(index, CoreNLPProtos.CorefChain.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;</code></summary>
				public IList<CoreNLPProtos.CorefChain.Builder> GetCorefChainBuilderList()
				{
					return GetCorefChainFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.CorefChain, CoreNLPProtos.CorefChain.Builder, CoreNLPProtos.ICorefChainOrBuilder> GetCorefChainFieldBuilder()
				{
					if (corefChainBuilder_ == null)
					{
						corefChainBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.CorefChain, CoreNLPProtos.CorefChain.Builder, CoreNLPProtos.ICorefChainOrBuilder>(corefChain_, ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))), GetParentForChildren
							(), IsClean());
						corefChain_ = null;
					}
					return corefChainBuilder_;
				}

				private object docID_ = string.Empty;

				/// <summary><code>optional string docID = 4;</code></summary>
				public bool HasDocID()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional string docID = 4;</code></summary>
				public string GetDocID()
				{
					object @ref = docID_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							docID_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string docID = 4;</code></summary>
				public ByteString GetDocIDBytes()
				{
					object @ref = docID_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						docID_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string docID = 4;</code></summary>
				public CoreNLPProtos.Document.Builder SetDocID(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					docID_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string docID = 4;</code></summary>
				public CoreNLPProtos.Document.Builder ClearDocID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					docID_ = GetDefaultInstance().GetDocID();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string docID = 4;</code></summary>
				public CoreNLPProtos.Document.Builder SetDocIDBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					docID_ = value;
					OnChanged();
					return this;
				}

				private object docDate_ = string.Empty;

				/// <summary><code>optional string docDate = 7;</code></summary>
				public bool HasDocDate()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional string docDate = 7;</code></summary>
				public string GetDocDate()
				{
					object @ref = docDate_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							docDate_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string docDate = 7;</code></summary>
				public ByteString GetDocDateBytes()
				{
					object @ref = docDate_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						docDate_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string docDate = 7;</code></summary>
				public CoreNLPProtos.Document.Builder SetDocDate(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					docDate_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string docDate = 7;</code></summary>
				public CoreNLPProtos.Document.Builder ClearDocDate()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					docDate_ = GetDefaultInstance().GetDocDate();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string docDate = 7;</code></summary>
				public CoreNLPProtos.Document.Builder SetDocDateBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					docDate_ = value;
					OnChanged();
					return this;
				}

				private long calendar_;

				/// <summary><code>optional uint64 calendar = 8;</code></summary>
				public bool HasCalendar()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional uint64 calendar = 8;</code></summary>
				public long GetCalendar()
				{
					return calendar_;
				}

				/// <summary><code>optional uint64 calendar = 8;</code></summary>
				public CoreNLPProtos.Document.Builder SetCalendar(long value)
				{
					bitField0_ |= unchecked((int)(0x00000020));
					calendar_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint64 calendar = 8;</code></summary>
				public CoreNLPProtos.Document.Builder ClearCalendar()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					calendar_ = 0L;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.Token> sentencelessToken_ = Java.Util.Collections.EmptyList();

				private void EnsureSentencelessTokenIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						sentencelessToken_ = new List<CoreNLPProtos.Token>(sentencelessToken_);
						bitField0_ |= unchecked((int)(0x00000040));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> sentencelessTokenBuilder_;

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public IList<CoreNLPProtos.Token> GetSentencelessTokenList()
				{
					if (sentencelessTokenBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(sentencelessToken_);
					}
					else
					{
						return sentencelessTokenBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public int GetSentencelessTokenCount()
				{
					if (sentencelessTokenBuilder_ == null)
					{
						return sentencelessToken_.Count;
					}
					else
					{
						return sentencelessTokenBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Token GetSentencelessToken(int index)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						return sentencelessToken_[index];
					}
					else
					{
						return sentencelessTokenBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder SetSentencelessToken(int index, CoreNLPProtos.Token value)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentencelessTokenIsMutable();
						sentencelessToken_.Set(index, value);
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder SetSentencelessToken(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						EnsureSentencelessTokenIsMutable();
						sentencelessToken_.Set(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.SetMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddSentencelessToken(CoreNLPProtos.Token value)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentencelessTokenIsMutable();
						sentencelessToken_.Add(value);
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddSentencelessToken(int index, CoreNLPProtos.Token value)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentencelessTokenIsMutable();
						sentencelessToken_.Add(index, value);
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddSentencelessToken(CoreNLPProtos.Token.Builder builderForValue)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						EnsureSentencelessTokenIsMutable();
						sentencelessToken_.Add(((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.AddMessage(((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddSentencelessToken(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						EnsureSentencelessTokenIsMutable();
						sentencelessToken_.Add(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.AddMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddAllSentencelessToken<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Token
				{
					if (sentencelessTokenBuilder_ == null)
					{
						EnsureSentencelessTokenIsMutable();
						AbstractMessageLite.Builder.AddAll(values, sentencelessToken_);
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder ClearSentencelessToken()
				{
					if (sentencelessTokenBuilder_ == null)
					{
						sentencelessToken_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder RemoveSentencelessToken(int index)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						EnsureSentencelessTokenIsMutable();
						sentencelessToken_.Remove(index);
						OnChanged();
					}
					else
					{
						sentencelessTokenBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Token.Builder GetSentencelessTokenBuilder(int index)
				{
					return GetSentencelessTokenFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.ITokenOrBuilder GetSentencelessTokenOrBuilder(int index)
				{
					if (sentencelessTokenBuilder_ == null)
					{
						return sentencelessToken_[index];
					}
					else
					{
						return sentencelessTokenBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public IList<CoreNLPProtos.ITokenOrBuilder> GetSentencelessTokenOrBuilderList()
				{
					if (sentencelessTokenBuilder_ != null)
					{
						return sentencelessTokenBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(sentencelessToken_);
					}
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Token.Builder AddSentencelessTokenBuilder()
				{
					return GetSentencelessTokenFieldBuilder().AddBuilder(CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public CoreNLPProtos.Token.Builder AddSentencelessTokenBuilder(int index)
				{
					return GetSentencelessTokenFieldBuilder().AddBuilder(index, CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// A peculiar field, for the corner case when a Document is
				/// serialized without any sentences. Otherwise
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;</code>
				/// </remarks>
				public IList<CoreNLPProtos.Token.Builder> GetSentencelessTokenBuilderList()
				{
					return GetSentencelessTokenFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> GetSentencelessTokenFieldBuilder()
				{
					if (sentencelessTokenBuilder_ == null)
					{
						sentencelessTokenBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder>(sentencelessToken_, ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))), GetParentForChildren
							(), IsClean());
						sentencelessToken_ = null;
					}
					return sentencelessTokenBuilder_;
				}

				private IList<CoreNLPProtos.Token> character_ = Java.Util.Collections.EmptyList();

				private void EnsureCharacterIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						character_ = new List<CoreNLPProtos.Token>(character_);
						bitField0_ |= unchecked((int)(0x00000080));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> characterBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public IList<CoreNLPProtos.Token> GetCharacterList()
				{
					if (characterBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(character_);
					}
					else
					{
						return characterBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public int GetCharacterCount()
				{
					if (characterBuilder_ == null)
					{
						return character_.Count;
					}
					else
					{
						return characterBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Token GetCharacter(int index)
				{
					if (characterBuilder_ == null)
					{
						return character_[index];
					}
					else
					{
						return characterBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder SetCharacter(int index, CoreNLPProtos.Token value)
				{
					if (characterBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCharacterIsMutable();
						character_.Set(index, value);
						OnChanged();
					}
					else
					{
						characterBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder SetCharacter(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Set(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						characterBuilder_.SetMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder AddCharacter(CoreNLPProtos.Token value)
				{
					if (characterBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCharacterIsMutable();
						character_.Add(value);
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder AddCharacter(int index, CoreNLPProtos.Token value)
				{
					if (characterBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCharacterIsMutable();
						character_.Add(index, value);
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder AddCharacter(CoreNLPProtos.Token.Builder builderForValue)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Add(((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder AddCharacter(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Add(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder AddAllCharacter<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Token
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						AbstractMessageLite.Builder.AddAll(values, character_);
						OnChanged();
					}
					else
					{
						characterBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder ClearCharacter()
				{
					if (characterBuilder_ == null)
					{
						character_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
						OnChanged();
					}
					else
					{
						characterBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Document.Builder RemoveCharacter(int index)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Remove(index);
						OnChanged();
					}
					else
					{
						characterBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Token.Builder GetCharacterBuilder(int index)
				{
					return GetCharacterFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.ITokenOrBuilder GetCharacterOrBuilder(int index)
				{
					if (characterBuilder_ == null)
					{
						return character_[index];
					}
					else
					{
						return characterBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public IList<CoreNLPProtos.ITokenOrBuilder> GetCharacterOrBuilderList()
				{
					if (characterBuilder_ != null)
					{
						return characterBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(character_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Token.Builder AddCharacterBuilder()
				{
					return GetCharacterFieldBuilder().AddBuilder(CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public CoreNLPProtos.Token.Builder AddCharacterBuilder(int index)
				{
					return GetCharacterFieldBuilder().AddBuilder(index, CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 10;</code></summary>
				public IList<CoreNLPProtos.Token.Builder> GetCharacterBuilderList()
				{
					return GetCharacterFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> GetCharacterFieldBuilder()
				{
					if (characterBuilder_ == null)
					{
						characterBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder>(character_, ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))), GetParentForChildren()
							, IsClean());
						character_ = null;
					}
					return characterBuilder_;
				}

				private IList<CoreNLPProtos.Quote> quote_ = Java.Util.Collections.EmptyList();

				private void EnsureQuoteIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						quote_ = new List<CoreNLPProtos.Quote>(quote_);
						bitField0_ |= unchecked((int)(0x00000100));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Quote, CoreNLPProtos.Quote.Builder, CoreNLPProtos.IQuoteOrBuilder> quoteBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public IList<CoreNLPProtos.Quote> GetQuoteList()
				{
					if (quoteBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(quote_);
					}
					else
					{
						return quoteBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public int GetQuoteCount()
				{
					if (quoteBuilder_ == null)
					{
						return quote_.Count;
					}
					else
					{
						return quoteBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Quote GetQuote(int index)
				{
					if (quoteBuilder_ == null)
					{
						return quote_[index];
					}
					else
					{
						return quoteBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder SetQuote(int index, CoreNLPProtos.Quote value)
				{
					if (quoteBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureQuoteIsMutable();
						quote_.Set(index, value);
						OnChanged();
					}
					else
					{
						quoteBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder SetQuote(int index, CoreNLPProtos.Quote.Builder builderForValue)
				{
					if (quoteBuilder_ == null)
					{
						EnsureQuoteIsMutable();
						quote_.Set(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						quoteBuilder_.SetMessage(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder AddQuote(CoreNLPProtos.Quote value)
				{
					if (quoteBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureQuoteIsMutable();
						quote_.Add(value);
						OnChanged();
					}
					else
					{
						quoteBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder AddQuote(int index, CoreNLPProtos.Quote value)
				{
					if (quoteBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureQuoteIsMutable();
						quote_.Add(index, value);
						OnChanged();
					}
					else
					{
						quoteBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder AddQuote(CoreNLPProtos.Quote.Builder builderForValue)
				{
					if (quoteBuilder_ == null)
					{
						EnsureQuoteIsMutable();
						quote_.Add(((CoreNLPProtos.Quote)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						quoteBuilder_.AddMessage(((CoreNLPProtos.Quote)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder AddQuote(int index, CoreNLPProtos.Quote.Builder builderForValue)
				{
					if (quoteBuilder_ == null)
					{
						EnsureQuoteIsMutable();
						quote_.Add(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						quoteBuilder_.AddMessage(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder AddAllQuote<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Quote
				{
					if (quoteBuilder_ == null)
					{
						EnsureQuoteIsMutable();
						AbstractMessageLite.Builder.AddAll(values, quote_);
						OnChanged();
					}
					else
					{
						quoteBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder ClearQuote()
				{
					if (quoteBuilder_ == null)
					{
						quote_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
						OnChanged();
					}
					else
					{
						quoteBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Document.Builder RemoveQuote(int index)
				{
					if (quoteBuilder_ == null)
					{
						EnsureQuoteIsMutable();
						quote_.Remove(index);
						OnChanged();
					}
					else
					{
						quoteBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder GetQuoteBuilder(int index)
				{
					return GetQuoteFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.IQuoteOrBuilder GetQuoteOrBuilder(int index)
				{
					if (quoteBuilder_ == null)
					{
						return quote_[index];
					}
					else
					{
						return quoteBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public IList<CoreNLPProtos.IQuoteOrBuilder> GetQuoteOrBuilderList()
				{
					if (quoteBuilder_ != null)
					{
						return quoteBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(quote_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder AddQuoteBuilder()
				{
					return GetQuoteFieldBuilder().AddBuilder(CoreNLPProtos.Quote.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder AddQuoteBuilder(int index)
				{
					return GetQuoteFieldBuilder().AddBuilder(index, CoreNLPProtos.Quote.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quote = 6;</code></summary>
				public IList<CoreNLPProtos.Quote.Builder> GetQuoteBuilderList()
				{
					return GetQuoteFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Quote, CoreNLPProtos.Quote.Builder, CoreNLPProtos.IQuoteOrBuilder> GetQuoteFieldBuilder()
				{
					if (quoteBuilder_ == null)
					{
						quoteBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Quote, CoreNLPProtos.Quote.Builder, CoreNLPProtos.IQuoteOrBuilder>(quote_, ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))), GetParentForChildren(), IsClean
							());
						quote_ = null;
					}
					return quoteBuilder_;
				}

				private IList<CoreNLPProtos.NERMention> mentions_ = Java.Util.Collections.EmptyList();

				private void EnsureMentionsIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						mentions_ = new List<CoreNLPProtos.NERMention>(mentions_);
						bitField0_ |= unchecked((int)(0x00000200));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.NERMention, CoreNLPProtos.NERMention.Builder, CoreNLPProtos.INERMentionOrBuilder> mentionsBuilder_;

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public IList<CoreNLPProtos.NERMention> GetMentionsList()
				{
					if (mentionsBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(mentions_);
					}
					else
					{
						return mentionsBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public int GetMentionsCount()
				{
					if (mentionsBuilder_ == null)
					{
						return mentions_.Count;
					}
					else
					{
						return mentionsBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.NERMention GetMentions(int index)
				{
					if (mentionsBuilder_ == null)
					{
						return mentions_[index];
					}
					else
					{
						return mentionsBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder SetMentions(int index, CoreNLPProtos.NERMention value)
				{
					if (mentionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsIsMutable();
						mentions_.Set(index, value);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder SetMentions(int index, CoreNLPProtos.NERMention.Builder builderForValue)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Set(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.SetMessage(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddMentions(CoreNLPProtos.NERMention value)
				{
					if (mentionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsIsMutable();
						mentions_.Add(value);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddMentions(int index, CoreNLPProtos.NERMention value)
				{
					if (mentionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsIsMutable();
						mentions_.Add(index, value);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddMentions(CoreNLPProtos.NERMention.Builder builderForValue)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Add(((CoreNLPProtos.NERMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(((CoreNLPProtos.NERMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddMentions(int index, CoreNLPProtos.NERMention.Builder builderForValue)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Add(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder AddAllMentions<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.NERMention
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						AbstractMessageLite.Builder.AddAll(values, mentions_);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder ClearMentions()
				{
					if (mentionsBuilder_ == null)
					{
						mentions_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.Document.Builder RemoveMentions(int index)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Remove(index);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.NERMention.Builder GetMentionsBuilder(int index)
				{
					return GetMentionsFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.INERMentionOrBuilder GetMentionsOrBuilder(int index)
				{
					if (mentionsBuilder_ == null)
					{
						return mentions_[index];
					}
					else
					{
						return mentionsBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public IList<CoreNLPProtos.INERMentionOrBuilder> GetMentionsOrBuilderList()
				{
					if (mentionsBuilder_ != null)
					{
						return mentionsBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(mentions_);
					}
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.NERMention.Builder AddMentionsBuilder()
				{
					return GetMentionsFieldBuilder().AddBuilder(CoreNLPProtos.NERMention.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public CoreNLPProtos.NERMention.Builder AddMentionsBuilder(int index)
				{
					return GetMentionsFieldBuilder().AddBuilder(index, CoreNLPProtos.NERMention.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// This field is for entity mentions across the document.
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 9;</code>
				/// </remarks>
				public IList<CoreNLPProtos.NERMention.Builder> GetMentionsBuilderList()
				{
					return GetMentionsFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.NERMention, CoreNLPProtos.NERMention.Builder, CoreNLPProtos.INERMentionOrBuilder> GetMentionsFieldBuilder()
				{
					if (mentionsBuilder_ == null)
					{
						mentionsBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.NERMention, CoreNLPProtos.NERMention.Builder, CoreNLPProtos.INERMentionOrBuilder>(mentions_, ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))), GetParentForChildren
							(), IsClean());
						mentions_ = null;
					}
					return mentionsBuilder_;
				}

				private bool hasEntityMentionsAnnotation_;

				/// <summary>
				/// <pre>
				/// used to differentiate between null and empty list
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
				/// </summary>
				public bool HasHasEntityMentionsAnnotation()
				{
					return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary>
				/// <pre>
				/// used to differentiate between null and empty list
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
				/// </summary>
				public bool GetHasEntityMentionsAnnotation()
				{
					return hasEntityMentionsAnnotation_;
				}

				/// <summary>
				/// <pre>
				/// used to differentiate between null and empty list
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder SetHasEntityMentionsAnnotation(bool value)
				{
					bitField0_ |= unchecked((int)(0x00000400));
					hasEntityMentionsAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// used to differentiate between null and empty list
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 13;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder ClearHasEntityMentionsAnnotation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					hasEntityMentionsAnnotation_ = false;
					OnChanged();
					return this;
				}

				private bool xmlDoc_;

				/// <summary>
				/// <pre>
				/// xml information
				/// </pre>
				/// <code>optional bool xmlDoc = 11;</code>
				/// </summary>
				public bool HasXmlDoc()
				{
					return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary>
				/// <pre>
				/// xml information
				/// </pre>
				/// <code>optional bool xmlDoc = 11;</code>
				/// </summary>
				public bool GetXmlDoc()
				{
					return xmlDoc_;
				}

				/// <summary>
				/// <pre>
				/// xml information
				/// </pre>
				/// <code>optional bool xmlDoc = 11;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder SetXmlDoc(bool value)
				{
					bitField0_ |= unchecked((int)(0x00000800));
					xmlDoc_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// xml information
				/// </pre>
				/// <code>optional bool xmlDoc = 11;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder ClearXmlDoc()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					xmlDoc_ = false;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.Section> sections_ = Java.Util.Collections.EmptyList();

				private void EnsureSectionsIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
					{
						sections_ = new List<CoreNLPProtos.Section>(sections_);
						bitField0_ |= unchecked((int)(0x00001000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Section, CoreNLPProtos.Section.Builder, CoreNLPProtos.ISectionOrBuilder> sectionsBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public IList<CoreNLPProtos.Section> GetSectionsList()
				{
					if (sectionsBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(sections_);
					}
					else
					{
						return sectionsBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public int GetSectionsCount()
				{
					if (sectionsBuilder_ == null)
					{
						return sections_.Count;
					}
					else
					{
						return sectionsBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Section GetSections(int index)
				{
					if (sectionsBuilder_ == null)
					{
						return sections_[index];
					}
					else
					{
						return sectionsBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder SetSections(int index, CoreNLPProtos.Section value)
				{
					if (sectionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSectionsIsMutable();
						sections_.Set(index, value);
						OnChanged();
					}
					else
					{
						sectionsBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder SetSections(int index, CoreNLPProtos.Section.Builder builderForValue)
				{
					if (sectionsBuilder_ == null)
					{
						EnsureSectionsIsMutable();
						sections_.Set(index, ((CoreNLPProtos.Section)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sectionsBuilder_.SetMessage(index, ((CoreNLPProtos.Section)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder AddSections(CoreNLPProtos.Section value)
				{
					if (sectionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSectionsIsMutable();
						sections_.Add(value);
						OnChanged();
					}
					else
					{
						sectionsBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder AddSections(int index, CoreNLPProtos.Section value)
				{
					if (sectionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSectionsIsMutable();
						sections_.Add(index, value);
						OnChanged();
					}
					else
					{
						sectionsBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder AddSections(CoreNLPProtos.Section.Builder builderForValue)
				{
					if (sectionsBuilder_ == null)
					{
						EnsureSectionsIsMutable();
						sections_.Add(((CoreNLPProtos.Section)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sectionsBuilder_.AddMessage(((CoreNLPProtos.Section)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder AddSections(int index, CoreNLPProtos.Section.Builder builderForValue)
				{
					if (sectionsBuilder_ == null)
					{
						EnsureSectionsIsMutable();
						sections_.Add(index, ((CoreNLPProtos.Section)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sectionsBuilder_.AddMessage(index, ((CoreNLPProtos.Section)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder AddAllSections<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Section
				{
					if (sectionsBuilder_ == null)
					{
						EnsureSectionsIsMutable();
						AbstractMessageLite.Builder.AddAll(values, sections_);
						OnChanged();
					}
					else
					{
						sectionsBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder ClearSections()
				{
					if (sectionsBuilder_ == null)
					{
						sections_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
						OnChanged();
					}
					else
					{
						sectionsBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Document.Builder RemoveSections(int index)
				{
					if (sectionsBuilder_ == null)
					{
						EnsureSectionsIsMutable();
						sections_.Remove(index);
						OnChanged();
					}
					else
					{
						sectionsBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Section.Builder GetSectionsBuilder(int index)
				{
					return GetSectionsFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.ISectionOrBuilder GetSectionsOrBuilder(int index)
				{
					if (sectionsBuilder_ == null)
					{
						return sections_[index];
					}
					else
					{
						return sectionsBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public IList<CoreNLPProtos.ISectionOrBuilder> GetSectionsOrBuilderList()
				{
					if (sectionsBuilder_ != null)
					{
						return sectionsBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(sections_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Section.Builder AddSectionsBuilder()
				{
					return GetSectionsFieldBuilder().AddBuilder(CoreNLPProtos.Section.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public CoreNLPProtos.Section.Builder AddSectionsBuilder(int index)
				{
					return GetSectionsFieldBuilder().AddBuilder(index, CoreNLPProtos.Section.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Section sections = 12;</code></summary>
				public IList<CoreNLPProtos.Section.Builder> GetSectionsBuilderList()
				{
					return GetSectionsFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Section, CoreNLPProtos.Section.Builder, CoreNLPProtos.ISectionOrBuilder> GetSectionsFieldBuilder()
				{
					if (sectionsBuilder_ == null)
					{
						sectionsBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Section, CoreNLPProtos.Section.Builder, CoreNLPProtos.ISectionOrBuilder>(sections_, ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))), GetParentForChildren
							(), IsClean());
						sections_ = null;
					}
					return sectionsBuilder_;
				}

				private IList<CoreNLPProtos.Mention> mentionsForCoref_ = Java.Util.Collections.EmptyList();

				private void EnsureMentionsForCorefIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
					{
						mentionsForCoref_ = new List<CoreNLPProtos.Mention>(mentionsForCoref_);
						bitField0_ |= unchecked((int)(0x00002000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Mention, CoreNLPProtos.Mention.Builder, CoreNLPProtos.IMentionOrBuilder> mentionsForCorefBuilder_;

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.Mention> GetMentionsForCorefList()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
					}
					else
					{
						return mentionsForCorefBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public int GetMentionsForCorefCount()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return mentionsForCoref_.Count;
					}
					else
					{
						return mentionsForCorefBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Mention GetMentionsForCoref(int index)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return mentionsForCoref_[index];
					}
					else
					{
						return mentionsForCorefBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder SetMentionsForCoref(int index, CoreNLPProtos.Mention value)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Set(index, value);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder SetMentionsForCoref(int index, CoreNLPProtos.Mention.Builder builderForValue)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Set(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.SetMessage(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder AddMentionsForCoref(CoreNLPProtos.Mention value)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(value);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder AddMentionsForCoref(int index, CoreNLPProtos.Mention value)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(index, value);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder AddMentionsForCoref(CoreNLPProtos.Mention.Builder builderForValue)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(((CoreNLPProtos.Mention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(((CoreNLPProtos.Mention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder AddMentionsForCoref(int index, CoreNLPProtos.Mention.Builder builderForValue)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder AddAllMentionsForCoref<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Mention
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						AbstractMessageLite.Builder.AddAll(values, mentionsForCoref_);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder ClearMentionsForCoref()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						mentionsForCoref_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Document.Builder RemoveMentionsForCoref(int index)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Remove(index);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Mention.Builder GetMentionsForCorefBuilder(int index)
				{
					return GetMentionsForCorefFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.IMentionOrBuilder GetMentionsForCorefOrBuilder(int index)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return mentionsForCoref_[index];
					}
					else
					{
						return mentionsForCorefBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefOrBuilderList()
				{
					if (mentionsForCorefBuilder_ != null)
					{
						return mentionsForCorefBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
					}
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Mention.Builder AddMentionsForCorefBuilder()
				{
					return GetMentionsForCorefFieldBuilder().AddBuilder(CoreNLPProtos.Mention.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public CoreNLPProtos.Mention.Builder AddMentionsForCorefBuilder(int index)
				{
					return GetMentionsForCorefFieldBuilder().AddBuilder(index, CoreNLPProtos.Mention.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// coref mentions for entire document
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.Mention.Builder> GetMentionsForCorefBuilderList()
				{
					return GetMentionsForCorefFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Mention, CoreNLPProtos.Mention.Builder, CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefFieldBuilder()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						mentionsForCorefBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Mention, CoreNLPProtos.Mention.Builder, CoreNLPProtos.IMentionOrBuilder>(mentionsForCoref_, ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))), GetParentForChildren
							(), IsClean());
						mentionsForCoref_ = null;
					}
					return mentionsForCorefBuilder_;
				}

				private bool hasCorefMentionAnnotation_;

				/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
				public bool HasHasCorefMentionAnnotation()
				{
					return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
				}

				/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
				public bool GetHasCorefMentionAnnotation()
				{
					return hasCorefMentionAnnotation_;
				}

				/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
				public CoreNLPProtos.Document.Builder SetHasCorefMentionAnnotation(bool value)
				{
					bitField0_ |= unchecked((int)(0x00004000));
					hasCorefMentionAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasCorefMentionAnnotation = 15;</code></summary>
				public CoreNLPProtos.Document.Builder ClearHasCorefMentionAnnotation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					hasCorefMentionAnnotation_ = false;
					OnChanged();
					return this;
				}

				private bool hasCorefAnnotation_;

				/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
				public bool HasHasCorefAnnotation()
				{
					return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
				}

				/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
				public bool GetHasCorefAnnotation()
				{
					return hasCorefAnnotation_;
				}

				/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
				public CoreNLPProtos.Document.Builder SetHasCorefAnnotation(bool value)
				{
					bitField0_ |= unchecked((int)(0x00008000));
					hasCorefAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasCorefAnnotation = 16;</code></summary>
				public CoreNLPProtos.Document.Builder ClearHasCorefAnnotation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					hasCorefAnnotation_ = false;
					OnChanged();
					return this;
				}

				private IList<int> corefMentionToEntityMentionMappings_ = Java.Util.Collections.EmptyList();

				private void EnsureCorefMentionToEntityMentionMappingsIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						corefMentionToEntityMentionMappings_ = new List<int>(corefMentionToEntityMentionMappings_);
						bitField0_ |= unchecked((int)(0x00010000));
					}
				}

				/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
				public IList<int> GetCorefMentionToEntityMentionMappingsList()
				{
					return Java.Util.Collections.UnmodifiableList(corefMentionToEntityMentionMappings_);
				}

				/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
				public int GetCorefMentionToEntityMentionMappingsCount()
				{
					return corefMentionToEntityMentionMappings_.Count;
				}

				/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
				public int GetCorefMentionToEntityMentionMappings(int index)
				{
					return corefMentionToEntityMentionMappings_[index];
				}

				/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
				public CoreNLPProtos.Document.Builder SetCorefMentionToEntityMentionMappings(int index, int value)
				{
					EnsureCorefMentionToEntityMentionMappingsIsMutable();
					corefMentionToEntityMentionMappings_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
				public CoreNLPProtos.Document.Builder AddCorefMentionToEntityMentionMappings(int value)
				{
					EnsureCorefMentionToEntityMentionMappingsIsMutable();
					corefMentionToEntityMentionMappings_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
				public CoreNLPProtos.Document.Builder AddAllCorefMentionToEntityMentionMappings<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureCorefMentionToEntityMentionMappingsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, corefMentionToEntityMentionMappings_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 corefMentionToEntityMentionMappings = 17;</code></summary>
				public CoreNLPProtos.Document.Builder ClearCorefMentionToEntityMentionMappings()
				{
					corefMentionToEntityMentionMappings_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					OnChanged();
					return this;
				}

				private IList<int> entityMentionToCorefMentionMappings_ = Java.Util.Collections.EmptyList();

				private void EnsureEntityMentionToCorefMentionMappingsIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						entityMentionToCorefMentionMappings_ = new List<int>(entityMentionToCorefMentionMappings_);
						bitField0_ |= unchecked((int)(0x00020000));
					}
				}

				/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
				public IList<int> GetEntityMentionToCorefMentionMappingsList()
				{
					return Java.Util.Collections.UnmodifiableList(entityMentionToCorefMentionMappings_);
				}

				/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
				public int GetEntityMentionToCorefMentionMappingsCount()
				{
					return entityMentionToCorefMentionMappings_.Count;
				}

				/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
				public int GetEntityMentionToCorefMentionMappings(int index)
				{
					return entityMentionToCorefMentionMappings_[index];
				}

				/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
				public CoreNLPProtos.Document.Builder SetEntityMentionToCorefMentionMappings(int index, int value)
				{
					EnsureEntityMentionToCorefMentionMappingsIsMutable();
					entityMentionToCorefMentionMappings_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
				public CoreNLPProtos.Document.Builder AddEntityMentionToCorefMentionMappings(int value)
				{
					EnsureEntityMentionToCorefMentionMappingsIsMutable();
					entityMentionToCorefMentionMappings_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
				public CoreNLPProtos.Document.Builder AddAllEntityMentionToCorefMentionMappings<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureEntityMentionToCorefMentionMappingsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, entityMentionToCorefMentionMappings_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 entityMentionToCorefMentionMappings = 18;</code></summary>
				public CoreNLPProtos.Document.Builder ClearEntityMentionToCorefMentionMappings()
				{
					entityMentionToCorefMentionMappings_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Document.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Document)
			}

			private static readonly CoreNLPProtos.Document DefaultInstance;

			static Document()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Document)
				DefaultInstance = new CoreNLPProtos.Document();
			}

			public static CoreNLPProtos.Document GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_5626 : AbstractParser<CoreNLPProtos.Document>
			{
				public _AbstractParser_5626()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Document ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Document(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Document> Parser = new _AbstractParser_5626();

			public static IParser<CoreNLPProtos.Document> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ISentenceOrBuilder : GeneratedMessageV3.IExtendableMessageOrBuilder<CoreNLPProtos.Sentence>
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Sentence)
			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			IList<CoreNLPProtos.Token> GetTokenList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			CoreNLPProtos.Token GetToken(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			int GetTokenCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			IList<CoreNLPProtos.ITokenOrBuilder> GetTokenOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			CoreNLPProtos.ITokenOrBuilder GetTokenOrBuilder(int index);

			/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
			bool HasTokenOffsetBegin();

			/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
			int GetTokenOffsetBegin();

			/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
			bool HasTokenOffsetEnd();

			/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
			int GetTokenOffsetEnd();

			/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
			bool HasSentenceIndex();

			/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
			int GetSentenceIndex();

			/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
			bool HasCharacterOffsetBegin();

			/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
			int GetCharacterOffsetBegin();

			/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
			bool HasCharacterOffsetEnd();

			/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
			int GetCharacterOffsetEnd();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
			bool HasParseTree();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
			CoreNLPProtos.ParseTree GetParseTree();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
			CoreNLPProtos.IParseTreeOrBuilder GetParseTreeOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
			bool HasBinarizedParseTree();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
			CoreNLPProtos.ParseTree GetBinarizedParseTree();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
			CoreNLPProtos.IParseTreeOrBuilder GetBinarizedParseTreeOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
			bool HasAnnotatedParseTree();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
			CoreNLPProtos.ParseTree GetAnnotatedParseTree();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
			CoreNLPProtos.IParseTreeOrBuilder GetAnnotatedParseTreeOrBuilder();

			/// <summary><code>optional string sentiment = 33;</code></summary>
			bool HasSentiment();

			/// <summary><code>optional string sentiment = 33;</code></summary>
			string GetSentiment();

			/// <summary><code>optional string sentiment = 33;</code></summary>
			ByteString GetSentimentBytes();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			IList<CoreNLPProtos.ParseTree> GetKBestParseTreesList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			CoreNLPProtos.ParseTree GetKBestParseTrees(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			int GetKBestParseTreesCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			IList<CoreNLPProtos.IParseTreeOrBuilder> GetKBestParseTreesOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			CoreNLPProtos.IParseTreeOrBuilder GetKBestParseTreesOrBuilder(int index);

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
			bool HasBasicDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
			CoreNLPProtos.DependencyGraph GetBasicDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetBasicDependenciesOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
			bool HasCollapsedDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
			CoreNLPProtos.DependencyGraph GetCollapsedDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetCollapsedDependenciesOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
			bool HasCollapsedCCProcessedDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
			CoreNLPProtos.DependencyGraph GetCollapsedCCProcessedDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetCollapsedCCProcessedDependenciesOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
			bool HasAlternativeDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
			CoreNLPProtos.DependencyGraph GetAlternativeDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetAlternativeDependenciesOrBuilder();

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			IList<CoreNLPProtos.RelationTriple> GetOpenieTripleList();

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			CoreNLPProtos.RelationTriple GetOpenieTriple(int index);

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			int GetOpenieTripleCount();

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			IList<CoreNLPProtos.IRelationTripleOrBuilder> GetOpenieTripleOrBuilderList();

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			CoreNLPProtos.IRelationTripleOrBuilder GetOpenieTripleOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			IList<CoreNLPProtos.RelationTriple> GetKbpTripleList();

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			CoreNLPProtos.RelationTriple GetKbpTriple(int index);

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			int GetKbpTripleCount();

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			IList<CoreNLPProtos.IRelationTripleOrBuilder> GetKbpTripleOrBuilderList();

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			CoreNLPProtos.IRelationTripleOrBuilder GetKbpTripleOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			IList<CoreNLPProtos.SentenceFragment> GetEntailedSentenceList();

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			CoreNLPProtos.SentenceFragment GetEntailedSentence(int index);

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			int GetEntailedSentenceCount();

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			IList<CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedSentenceOrBuilderList();

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			CoreNLPProtos.ISentenceFragmentOrBuilder GetEntailedSentenceOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			IList<CoreNLPProtos.SentenceFragment> GetEntailedClauseList();

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			CoreNLPProtos.SentenceFragment GetEntailedClause(int index);

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			int GetEntailedClauseCount();

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			IList<CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedClauseOrBuilderList();

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			CoreNLPProtos.ISentenceFragmentOrBuilder GetEntailedClauseOrBuilder(int index);

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
			bool HasEnhancedDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
			CoreNLPProtos.DependencyGraph GetEnhancedDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetEnhancedDependenciesOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
			bool HasEnhancedPlusPlusDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
			CoreNLPProtos.DependencyGraph GetEnhancedPlusPlusDependencies();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetEnhancedPlusPlusDependenciesOrBuilder();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			IList<CoreNLPProtos.Token> GetCharacterList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			CoreNLPProtos.Token GetCharacter(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			int GetCharacterCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			IList<CoreNLPProtos.ITokenOrBuilder> GetCharacterOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			CoreNLPProtos.ITokenOrBuilder GetCharacterOrBuilder(int index);

			/// <summary><code>optional uint32 paragraph = 11;</code></summary>
			bool HasParagraph();

			/// <summary><code>optional uint32 paragraph = 11;</code></summary>
			int GetParagraph();

			/// <summary>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </pre>
			/// <code>optional string text = 12;</code>
			/// </remarks>
			bool HasText();

			/// <summary>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </pre>
			/// <code>optional string text = 12;</code>
			/// </remarks>
			string GetText();

			/// <summary>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </pre>
			/// <code>optional string text = 12;</code>
			/// </remarks>
			ByteString GetTextBytes();

			/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
			bool HasLineNumber();

			/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
			int GetLineNumber();

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional bool hasRelationAnnotations = 51;</code>
			/// </summary>
			bool HasHasRelationAnnotations();

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional bool hasRelationAnnotations = 51;</code>
			/// </summary>
			bool GetHasRelationAnnotations();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			IList<CoreNLPProtos.Entity> GetEntityList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			CoreNLPProtos.Entity GetEntity(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			int GetEntityCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			IList<CoreNLPProtos.IEntityOrBuilder> GetEntityOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			CoreNLPProtos.IEntityOrBuilder GetEntityOrBuilder(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			IList<CoreNLPProtos.Relation> GetRelationList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			CoreNLPProtos.Relation GetRelation(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			int GetRelationCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			IList<CoreNLPProtos.IRelationOrBuilder> GetRelationOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			CoreNLPProtos.IRelationOrBuilder GetRelationOrBuilder(int index);

			/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
			bool HasHasNumerizedTokensAnnotation();

			/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
			bool GetHasNumerizedTokensAnnotation();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			IList<CoreNLPProtos.NERMention> GetMentionsList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			CoreNLPProtos.NERMention GetMentions(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			int GetMentionsCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			IList<CoreNLPProtos.INERMentionOrBuilder> GetMentionsOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			CoreNLPProtos.INERMentionOrBuilder GetMentionsOrBuilder(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			IList<CoreNLPProtos.Mention> GetMentionsForCorefList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			CoreNLPProtos.Mention GetMentionsForCoref(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			int GetMentionsForCorefCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			IList<CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			CoreNLPProtos.IMentionOrBuilder GetMentionsForCorefOrBuilder(int index);

			/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
			bool HasHasCorefMentionsAnnotation();

			/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
			bool GetHasCorefMentionsAnnotation();

			/// <summary>
			/// <pre>
			/// Useful when storing sentences (e.g.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Useful when storing sentences (e.g. ForEach)
			/// </pre>
			/// <code>optional string sentenceID = 58;</code>
			/// </remarks>
			bool HasSentenceID();

			/// <summary>
			/// <pre>
			/// Useful when storing sentences (e.g.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Useful when storing sentences (e.g. ForEach)
			/// </pre>
			/// <code>optional string sentenceID = 58;</code>
			/// </remarks>
			string GetSentenceID();

			/// <summary>
			/// <pre>
			/// Useful when storing sentences (e.g.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Useful when storing sentences (e.g. ForEach)
			/// </pre>
			/// <code>optional string sentenceID = 58;</code>
			/// </remarks>
			ByteString GetSentenceIDBytes();

			/// <summary>
			/// <pre>
			/// date of section
			/// </pre>
			/// <code>optional string sectionDate = 59;</code>
			/// </summary>
			bool HasSectionDate();

			/// <summary>
			/// <pre>
			/// date of section
			/// </pre>
			/// <code>optional string sectionDate = 59;</code>
			/// </summary>
			string GetSectionDate();

			/// <summary>
			/// <pre>
			/// date of section
			/// </pre>
			/// <code>optional string sectionDate = 59;</code>
			/// </summary>
			ByteString GetSectionDateBytes();

			/// <summary>
			/// <pre>
			/// section index for this sentence's section
			/// </pre>
			/// <code>optional uint32 sectionIndex = 60;</code>
			/// </summary>
			bool HasSectionIndex();

			/// <summary>
			/// <pre>
			/// section index for this sentence's section
			/// </pre>
			/// <code>optional uint32 sectionIndex = 60;</code>
			/// </summary>
			int GetSectionIndex();

			/// <summary>
			/// <pre>
			/// name of section
			/// </pre>
			/// <code>optional string sectionName = 61;</code>
			/// </summary>
			bool HasSectionName();

			/// <summary>
			/// <pre>
			/// name of section
			/// </pre>
			/// <code>optional string sectionName = 61;</code>
			/// </summary>
			string GetSectionName();

			/// <summary>
			/// <pre>
			/// name of section
			/// </pre>
			/// <code>optional string sectionName = 61;</code>
			/// </summary>
			ByteString GetSectionNameBytes();

			/// <summary>
			/// <pre>
			/// author of section
			/// </pre>
			/// <code>optional string sectionAuthor = 62;</code>
			/// </summary>
			bool HasSectionAuthor();

			/// <summary>
			/// <pre>
			/// author of section
			/// </pre>
			/// <code>optional string sectionAuthor = 62;</code>
			/// </summary>
			string GetSectionAuthor();

			/// <summary>
			/// <pre>
			/// author of section
			/// </pre>
			/// <code>optional string sectionAuthor = 62;</code>
			/// </summary>
			ByteString GetSectionAuthorBytes();

			/// <summary>
			/// <pre>
			/// doc id
			/// </pre>
			/// <code>optional string docID = 63;</code>
			/// </summary>
			bool HasDocID();

			/// <summary>
			/// <pre>
			/// doc id
			/// </pre>
			/// <code>optional string docID = 63;</code>
			/// </summary>
			string GetDocID();

			/// <summary>
			/// <pre>
			/// doc id
			/// </pre>
			/// <code>optional string docID = 63;</code>
			/// </summary>
			ByteString GetDocIDBytes();

			/// <summary>
			/// <pre>
			/// is this sentence in an xml quote in a post
			/// </pre>
			/// <code>optional bool sectionQuoted = 64;</code>
			/// </summary>
			bool HasSectionQuoted();

			/// <summary>
			/// <pre>
			/// is this sentence in an xml quote in a post
			/// </pre>
			/// <code>optional bool sectionQuoted = 64;</code>
			/// </summary>
			bool GetSectionQuoted();

			/// <summary>
			/// <pre>
			/// check if there are entity mentions
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
			/// </summary>
			bool HasHasEntityMentionsAnnotation();

			/// <summary>
			/// <pre>
			/// check if there are entity mentions
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
			/// </summary>
			bool GetHasEntityMentionsAnnotation();

			/// <summary>
			/// <pre>
			/// check if there are KBP triples
			/// </pre>
			/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
			/// </summary>
			bool HasHasKBPTriplesAnnotation();

			/// <summary>
			/// <pre>
			/// check if there are KBP triples
			/// </pre>
			/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
			/// </summary>
			bool GetHasKBPTriplesAnnotation();

			/// <summary>
			/// <pre>
			/// check if there are OpenIE triples
			/// </pre>
			/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
			/// </summary>
			bool HasHasOpenieTriplesAnnotation();

			/// <summary>
			/// <pre>
			/// check if there are OpenIE triples
			/// </pre>
			/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
			/// </summary>
			bool GetHasOpenieTriplesAnnotation();

			/// <summary>
			/// <pre>
			/// quote stuff
			/// </pre>
			/// <code>optional uint32 chapterIndex = 66;</code>
			/// </summary>
			bool HasChapterIndex();

			/// <summary>
			/// <pre>
			/// quote stuff
			/// </pre>
			/// <code>optional uint32 chapterIndex = 66;</code>
			/// </summary>
			int GetChapterIndex();

			/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
			bool HasParagraphIndex();

			/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
			int GetParagraphIndex();
		}

		/// <summary>
		/// <pre>
		/// The serialized version of a CoreMap representing a sentence.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// The serialized version of a CoreMap representing a sentence.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Sentence</c>
		/// </remarks>
		[System.Serializable]
		public sealed class Sentence : GeneratedMessageV3.ExtendableMessage<CoreNLPProtos.Sentence>, CoreNLPProtos.ISentenceOrBuilder
		{
			private Sentence(GeneratedMessageV3.ExtendableBuilder<CoreNLPProtos.Sentence, object> builder)
				: base(builder)
			{
			}

			private Sentence()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Sentence)
				// Use Sentence.newBuilder() to construct.
				token_ = Java.Util.Collections.EmptyList();
				tokenOffsetBegin_ = 0;
				tokenOffsetEnd_ = 0;
				sentenceIndex_ = 0;
				characterOffsetBegin_ = 0;
				characterOffsetEnd_ = 0;
				sentiment_ = string.Empty;
				kBestParseTrees_ = Java.Util.Collections.EmptyList();
				openieTriple_ = Java.Util.Collections.EmptyList();
				kbpTriple_ = Java.Util.Collections.EmptyList();
				entailedSentence_ = Java.Util.Collections.EmptyList();
				entailedClause_ = Java.Util.Collections.EmptyList();
				character_ = Java.Util.Collections.EmptyList();
				paragraph_ = 0;
				text_ = string.Empty;
				lineNumber_ = 0;
				hasRelationAnnotations_ = false;
				entity_ = Java.Util.Collections.EmptyList();
				relation_ = Java.Util.Collections.EmptyList();
				hasNumerizedTokensAnnotation_ = false;
				mentions_ = Java.Util.Collections.EmptyList();
				mentionsForCoref_ = Java.Util.Collections.EmptyList();
				hasCorefMentionsAnnotation_ = false;
				sentenceID_ = string.Empty;
				sectionDate_ = string.Empty;
				sectionIndex_ = 0;
				sectionName_ = string.Empty;
				sectionAuthor_ = string.Empty;
				docID_ = string.Empty;
				sectionQuoted_ = false;
				hasEntityMentionsAnnotation_ = false;
				hasKBPTriplesAnnotation_ = false;
				hasOpenieTriplesAnnotation_ = false;
				chapterIndex_ = 0;
				paragraphIndex_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Sentence(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				int mutable_bitField1_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									token_ = new List<CoreNLPProtos.Token>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								token_.Add(input.ReadMessage(CoreNLPProtos.Token.Parser, extensionRegistry));
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								tokenOffsetBegin_ = input.ReadUInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								tokenOffsetEnd_ = input.ReadUInt32();
								break;
							}

							case 32:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								sentenceIndex_ = input.ReadUInt32();
								break;
							}

							case 40:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								characterOffsetBegin_ = input.ReadUInt32();
								break;
							}

							case 48:
							{
								bitField0_ |= unchecked((int)(0x00000010));
								characterOffsetEnd_ = input.ReadUInt32();
								break;
							}

							case 58:
							{
								CoreNLPProtos.ParseTree.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
								{
									subBuilder = ((CoreNLPProtos.ParseTree.Builder)parseTree_.ToBuilder());
								}
								parseTree_ = input.ReadMessage(CoreNLPProtos.ParseTree.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(parseTree_);
									parseTree_ = ((CoreNLPProtos.ParseTree)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000020));
								break;
							}

							case 66:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)basicDependencies_.ToBuilder());
								}
								basicDependencies_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(basicDependencies_);
									basicDependencies_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000200));
								break;
							}

							case 74:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)collapsedDependencies_.ToBuilder());
								}
								collapsedDependencies_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(collapsedDependencies_);
									collapsedDependencies_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000400));
								break;
							}

							case 82:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)collapsedCCProcessedDependencies_.ToBuilder());
								}
								collapsedCCProcessedDependencies_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(collapsedCCProcessedDependencies_);
									collapsedCCProcessedDependencies_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000800));
								break;
							}

							case 88:
							{
								bitField0_ |= unchecked((int)(0x00008000));
								paragraph_ = input.ReadUInt32();
								break;
							}

							case 98:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00010000));
								text_ = bs;
								break;
							}

							case 106:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)alternativeDependencies_.ToBuilder());
								}
								alternativeDependencies_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(alternativeDependencies_);
									alternativeDependencies_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00001000));
								break;
							}

							case 114:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
								{
									openieTriple_ = new List<CoreNLPProtos.RelationTriple>();
									mutable_bitField0_ |= unchecked((int)(0x00008000));
								}
								openieTriple_.Add(input.ReadMessage(CoreNLPProtos.RelationTriple.Parser, extensionRegistry));
								break;
							}

							case 122:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
								{
									entailedSentence_ = new List<CoreNLPProtos.SentenceFragment>();
									mutable_bitField0_ |= unchecked((int)(0x00020000));
								}
								entailedSentence_.Add(input.ReadMessage(CoreNLPProtos.SentenceFragment.Parser, extensionRegistry));
								break;
							}

							case 130:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
								{
									kbpTriple_ = new List<CoreNLPProtos.RelationTriple>();
									mutable_bitField0_ |= unchecked((int)(0x00010000));
								}
								kbpTriple_.Add(input.ReadMessage(CoreNLPProtos.RelationTriple.Parser, extensionRegistry));
								break;
							}

							case 138:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)enhancedDependencies_.ToBuilder());
								}
								enhancedDependencies_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(enhancedDependencies_);
									enhancedDependencies_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00002000));
								break;
							}

							case 146:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)enhancedPlusPlusDependencies_.ToBuilder());
								}
								enhancedPlusPlusDependencies_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(enhancedPlusPlusDependencies_);
									enhancedPlusPlusDependencies_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00004000));
								break;
							}

							case 154:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
								{
									character_ = new List<CoreNLPProtos.Token>();
									mutable_bitField0_ |= unchecked((int)(0x00200000));
								}
								character_.Add(input.ReadMessage(CoreNLPProtos.Token.Parser, extensionRegistry));
								break;
							}

							case 160:
							{
								bitField0_ |= unchecked((int)(0x00020000));
								lineNumber_ = input.ReadUInt32();
								break;
							}

							case 250:
							{
								CoreNLPProtos.ParseTree.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
								{
									subBuilder = ((CoreNLPProtos.ParseTree.Builder)binarizedParseTree_.ToBuilder());
								}
								binarizedParseTree_ = input.ReadMessage(CoreNLPProtos.ParseTree.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(binarizedParseTree_);
									binarizedParseTree_ = ((CoreNLPProtos.ParseTree)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000040));
								break;
							}

							case 258:
							{
								CoreNLPProtos.ParseTree.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
								{
									subBuilder = ((CoreNLPProtos.ParseTree.Builder)annotatedParseTree_.ToBuilder());
								}
								annotatedParseTree_ = input.ReadMessage(CoreNLPProtos.ParseTree.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(annotatedParseTree_);
									annotatedParseTree_ = ((CoreNLPProtos.ParseTree)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000080));
								break;
							}

							case 266:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000100));
								sentiment_ = bs;
								break;
							}

							case 274:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
								{
									kBestParseTrees_ = new List<CoreNLPProtos.ParseTree>();
									mutable_bitField0_ |= unchecked((int)(0x00000400));
								}
								kBestParseTrees_.Add(input.ReadMessage(CoreNLPProtos.ParseTree.Parser, extensionRegistry));
								break;
							}

							case 282:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
								{
									entailedClause_ = new List<CoreNLPProtos.SentenceFragment>();
									mutable_bitField0_ |= unchecked((int)(0x00040000));
								}
								entailedClause_.Add(input.ReadMessage(CoreNLPProtos.SentenceFragment.Parser, extensionRegistry));
								break;
							}

							case 408:
							{
								bitField0_ |= unchecked((int)(0x00040000));
								hasRelationAnnotations_ = input.ReadBool();
								break;
							}

							case 418:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
								{
									entity_ = new List<CoreNLPProtos.Entity>();
									mutable_bitField0_ |= unchecked((int)(0x04000000));
								}
								entity_.Add(input.ReadMessage(CoreNLPProtos.Entity.Parser, extensionRegistry));
								break;
							}

							case 426:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
								{
									relation_ = new List<CoreNLPProtos.Relation>();
									mutable_bitField0_ |= unchecked((int)(0x08000000));
								}
								relation_.Add(input.ReadMessage(CoreNLPProtos.Relation.Parser, extensionRegistry));
								break;
							}

							case 432:
							{
								bitField0_ |= unchecked((int)(0x00080000));
								hasNumerizedTokensAnnotation_ = input.ReadBool();
								break;
							}

							case 442:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
								{
									mentions_ = new List<CoreNLPProtos.NERMention>();
									mutable_bitField0_ |= unchecked((int)(0x20000000));
								}
								mentions_.Add(input.ReadMessage(CoreNLPProtos.NERMention.Parser, extensionRegistry));
								break;
							}

							case 450:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
								{
									mentionsForCoref_ = new List<CoreNLPProtos.Mention>();
									mutable_bitField0_ |= unchecked((int)(0x40000000));
								}
								mentionsForCoref_.Add(input.ReadMessage(CoreNLPProtos.Mention.Parser, extensionRegistry));
								break;
							}

							case 456:
							{
								bitField0_ |= unchecked((int)(0x00100000));
								hasCorefMentionsAnnotation_ = input.ReadBool();
								break;
							}

							case 466:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00200000));
								sentenceID_ = bs;
								break;
							}

							case 474:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00400000));
								sectionDate_ = bs;
								break;
							}

							case 480:
							{
								bitField0_ |= unchecked((int)(0x00800000));
								sectionIndex_ = input.ReadUInt32();
								break;
							}

							case 490:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x01000000));
								sectionName_ = bs;
								break;
							}

							case 498:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x02000000));
								sectionAuthor_ = bs;
								break;
							}

							case 506:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x04000000));
								docID_ = bs;
								break;
							}

							case 512:
							{
								bitField0_ |= unchecked((int)(0x08000000));
								sectionQuoted_ = input.ReadBool();
								break;
							}

							case 520:
							{
								bitField0_ |= unchecked((int)(0x10000000));
								hasEntityMentionsAnnotation_ = input.ReadBool();
								break;
							}

							case 528:
							{
								bitField0_ |= unchecked((int)(0x80000000));
								chapterIndex_ = input.ReadUInt32();
								break;
							}

							case 536:
							{
								bitField1_ |= unchecked((int)(0x00000001));
								paragraphIndex_ = input.ReadUInt32();
								break;
							}

							case 544:
							{
								bitField0_ |= unchecked((int)(0x20000000));
								hasKBPTriplesAnnotation_ = input.ReadBool();
								break;
							}

							case 552:
							{
								bitField0_ |= unchecked((int)(0x40000000));
								hasOpenieTriplesAnnotation_ = input.ReadBool();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						token_ = Java.Util.Collections.UnmodifiableList(token_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
					{
						openieTriple_ = Java.Util.Collections.UnmodifiableList(openieTriple_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						entailedSentence_ = Java.Util.Collections.UnmodifiableList(entailedSentence_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						kbpTriple_ = Java.Util.Collections.UnmodifiableList(kbpTriple_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
					{
						character_ = Java.Util.Collections.UnmodifiableList(character_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						kBestParseTrees_ = Java.Util.Collections.UnmodifiableList(kBestParseTrees_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						entailedClause_ = Java.Util.Collections.UnmodifiableList(entailedClause_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
					{
						entity_ = Java.Util.Collections.UnmodifiableList(entity_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
					{
						relation_ = Java.Util.Collections.UnmodifiableList(relation_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
					{
						mentions_ = Java.Util.Collections.UnmodifiableList(mentions_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
					{
						mentionsForCoref_ = Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Sentence_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Sentence_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Sentence), typeof(CoreNLPProtos.Sentence.Builder));
			}

			private int bitField0_;

			private int bitField1_;

			public const int TokenFieldNumber = 1;

			private IList<CoreNLPProtos.Token> token_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			public IList<CoreNLPProtos.Token> GetTokenList()
			{
				return token_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			public IList<CoreNLPProtos.ITokenOrBuilder> GetTokenOrBuilderList()
			{
				return token_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			public int GetTokenCount()
			{
				return token_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			public CoreNLPProtos.Token GetToken(int index)
			{
				return token_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
			public CoreNLPProtos.ITokenOrBuilder GetTokenOrBuilder(int index)
			{
				return token_[index];
			}

			public const int TokenoffsetbeginFieldNumber = 2;

			private int tokenOffsetBegin_;

			/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
			public bool HasTokenOffsetBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
			public int GetTokenOffsetBegin()
			{
				return tokenOffsetBegin_;
			}

			public const int TokenoffsetendFieldNumber = 3;

			private int tokenOffsetEnd_;

			/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
			public bool HasTokenOffsetEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
			public int GetTokenOffsetEnd()
			{
				return tokenOffsetEnd_;
			}

			public const int SentenceindexFieldNumber = 4;

			private int sentenceIndex_;

			/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
			public bool HasSentenceIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
			public int GetSentenceIndex()
			{
				return sentenceIndex_;
			}

			public const int CharacteroffsetbeginFieldNumber = 5;

			private int characterOffsetBegin_;

			/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
			public bool HasCharacterOffsetBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
			public int GetCharacterOffsetBegin()
			{
				return characterOffsetBegin_;
			}

			public const int CharacteroffsetendFieldNumber = 6;

			private int characterOffsetEnd_;

			/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
			public bool HasCharacterOffsetEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
			public int GetCharacterOffsetEnd()
			{
				return characterOffsetEnd_;
			}

			public const int ParsetreeFieldNumber = 7;

			private CoreNLPProtos.ParseTree parseTree_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
			public bool HasParseTree()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
			public CoreNLPProtos.ParseTree GetParseTree()
			{
				return parseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : parseTree_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
			public CoreNLPProtos.IParseTreeOrBuilder GetParseTreeOrBuilder()
			{
				return parseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : parseTree_;
			}

			public const int BinarizedparsetreeFieldNumber = 31;

			private CoreNLPProtos.ParseTree binarizedParseTree_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
			public bool HasBinarizedParseTree()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
			public CoreNLPProtos.ParseTree GetBinarizedParseTree()
			{
				return binarizedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : binarizedParseTree_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
			public CoreNLPProtos.IParseTreeOrBuilder GetBinarizedParseTreeOrBuilder()
			{
				return binarizedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : binarizedParseTree_;
			}

			public const int AnnotatedparsetreeFieldNumber = 32;

			private CoreNLPProtos.ParseTree annotatedParseTree_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
			public bool HasAnnotatedParseTree()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
			public CoreNLPProtos.ParseTree GetAnnotatedParseTree()
			{
				return annotatedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : annotatedParseTree_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
			public CoreNLPProtos.IParseTreeOrBuilder GetAnnotatedParseTreeOrBuilder()
			{
				return annotatedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : annotatedParseTree_;
			}

			public const int SentimentFieldNumber = 33;

			private volatile object sentiment_;

			/// <summary><code>optional string sentiment = 33;</code></summary>
			public bool HasSentiment()
			{
				return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary><code>optional string sentiment = 33;</code></summary>
			public string GetSentiment()
			{
				object @ref = sentiment_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sentiment_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string sentiment = 33;</code></summary>
			public ByteString GetSentimentBytes()
			{
				object @ref = sentiment_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sentiment_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int KbestparsetreesFieldNumber = 34;

			private IList<CoreNLPProtos.ParseTree> kBestParseTrees_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			public IList<CoreNLPProtos.ParseTree> GetKBestParseTreesList()
			{
				return kBestParseTrees_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			public IList<CoreNLPProtos.IParseTreeOrBuilder> GetKBestParseTreesOrBuilderList()
			{
				return kBestParseTrees_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			public int GetKBestParseTreesCount()
			{
				return kBestParseTrees_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			public CoreNLPProtos.ParseTree GetKBestParseTrees(int index)
			{
				return kBestParseTrees_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
			public CoreNLPProtos.IParseTreeOrBuilder GetKBestParseTreesOrBuilder(int index)
			{
				return kBestParseTrees_[index];
			}

			public const int BasicdependenciesFieldNumber = 8;

			private CoreNLPProtos.DependencyGraph basicDependencies_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
			public bool HasBasicDependencies()
			{
				return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
			public CoreNLPProtos.DependencyGraph GetBasicDependencies()
			{
				return basicDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : basicDependencies_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetBasicDependenciesOrBuilder()
			{
				return basicDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : basicDependencies_;
			}

			public const int CollapseddependenciesFieldNumber = 9;

			private CoreNLPProtos.DependencyGraph collapsedDependencies_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
			public bool HasCollapsedDependencies()
			{
				return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
			public CoreNLPProtos.DependencyGraph GetCollapsedDependencies()
			{
				return collapsedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedDependencies_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetCollapsedDependenciesOrBuilder()
			{
				return collapsedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedDependencies_;
			}

			public const int CollapsedccprocesseddependenciesFieldNumber = 10;

			private CoreNLPProtos.DependencyGraph collapsedCCProcessedDependencies_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
			public bool HasCollapsedCCProcessedDependencies()
			{
				return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
			public CoreNLPProtos.DependencyGraph GetCollapsedCCProcessedDependencies()
			{
				return collapsedCCProcessedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedCCProcessedDependencies_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetCollapsedCCProcessedDependenciesOrBuilder()
			{
				return collapsedCCProcessedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedCCProcessedDependencies_;
			}

			public const int AlternativedependenciesFieldNumber = 13;

			private CoreNLPProtos.DependencyGraph alternativeDependencies_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
			public bool HasAlternativeDependencies()
			{
				return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
			public CoreNLPProtos.DependencyGraph GetAlternativeDependencies()
			{
				return alternativeDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : alternativeDependencies_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetAlternativeDependenciesOrBuilder()
			{
				return alternativeDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : alternativeDependencies_;
			}

			public const int OpenietripleFieldNumber = 14;

			private IList<CoreNLPProtos.RelationTriple> openieTriple_;

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			public IList<CoreNLPProtos.RelationTriple> GetOpenieTripleList()
			{
				return openieTriple_;
			}

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			public IList<CoreNLPProtos.IRelationTripleOrBuilder> GetOpenieTripleOrBuilderList()
			{
				return openieTriple_;
			}

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			public int GetOpenieTripleCount()
			{
				return openieTriple_.Count;
			}

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			public CoreNLPProtos.RelationTriple GetOpenieTriple(int index)
			{
				return openieTriple_[index];
			}

			/// <summary>
			/// <pre>
			/// The OpenIE triples in the sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
			/// </summary>
			public CoreNLPProtos.IRelationTripleOrBuilder GetOpenieTripleOrBuilder(int index)
			{
				return openieTriple_[index];
			}

			public const int KbptripleFieldNumber = 16;

			private IList<CoreNLPProtos.RelationTriple> kbpTriple_;

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			public IList<CoreNLPProtos.RelationTriple> GetKbpTripleList()
			{
				return kbpTriple_;
			}

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			public IList<CoreNLPProtos.IRelationTripleOrBuilder> GetKbpTripleOrBuilderList()
			{
				return kbpTriple_;
			}

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			public int GetKbpTripleCount()
			{
				return kbpTriple_.Count;
			}

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			public CoreNLPProtos.RelationTriple GetKbpTriple(int index)
			{
				return kbpTriple_[index];
			}

			/// <summary>
			/// <pre>
			/// The KBP triples in this sentence
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
			/// </summary>
			public CoreNLPProtos.IRelationTripleOrBuilder GetKbpTripleOrBuilder(int index)
			{
				return kbpTriple_[index];
			}

			public const int EntailedsentenceFieldNumber = 15;

			private IList<CoreNLPProtos.SentenceFragment> entailedSentence_;

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			public IList<CoreNLPProtos.SentenceFragment> GetEntailedSentenceList()
			{
				return entailedSentence_;
			}

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			public IList<CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedSentenceOrBuilderList()
			{
				return entailedSentence_;
			}

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			public int GetEntailedSentenceCount()
			{
				return entailedSentence_.Count;
			}

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			public CoreNLPProtos.SentenceFragment GetEntailedSentence(int index)
			{
				return entailedSentence_[index];
			}

			/// <summary>
			/// <pre>
			/// The entailed sentences, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
			/// </summary>
			public CoreNLPProtos.ISentenceFragmentOrBuilder GetEntailedSentenceOrBuilder(int index)
			{
				return entailedSentence_[index];
			}

			public const int EntailedclauseFieldNumber = 35;

			private IList<CoreNLPProtos.SentenceFragment> entailedClause_;

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			public IList<CoreNLPProtos.SentenceFragment> GetEntailedClauseList()
			{
				return entailedClause_;
			}

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			public IList<CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedClauseOrBuilderList()
			{
				return entailedClause_;
			}

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			public int GetEntailedClauseCount()
			{
				return entailedClause_.Count;
			}

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			public CoreNLPProtos.SentenceFragment GetEntailedClause(int index)
			{
				return entailedClause_[index];
			}

			/// <summary>
			/// <pre>
			/// The entailed clauses, by natural logic
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
			/// </summary>
			public CoreNLPProtos.ISentenceFragmentOrBuilder GetEntailedClauseOrBuilder(int index)
			{
				return entailedClause_[index];
			}

			public const int EnhanceddependenciesFieldNumber = 17;

			private CoreNLPProtos.DependencyGraph enhancedDependencies_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
			public bool HasEnhancedDependencies()
			{
				return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
			public CoreNLPProtos.DependencyGraph GetEnhancedDependencies()
			{
				return enhancedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedDependencies_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetEnhancedDependenciesOrBuilder()
			{
				return enhancedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedDependencies_;
			}

			public const int EnhancedplusplusdependenciesFieldNumber = 18;

			private CoreNLPProtos.DependencyGraph enhancedPlusPlusDependencies_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
			public bool HasEnhancedPlusPlusDependencies()
			{
				return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
			public CoreNLPProtos.DependencyGraph GetEnhancedPlusPlusDependencies()
			{
				return enhancedPlusPlusDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedPlusPlusDependencies_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetEnhancedPlusPlusDependenciesOrBuilder()
			{
				return enhancedPlusPlusDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedPlusPlusDependencies_;
			}

			public const int CharacterFieldNumber = 19;

			private IList<CoreNLPProtos.Token> character_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			public IList<CoreNLPProtos.Token> GetCharacterList()
			{
				return character_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			public IList<CoreNLPProtos.ITokenOrBuilder> GetCharacterOrBuilderList()
			{
				return character_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			public int GetCharacterCount()
			{
				return character_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			public CoreNLPProtos.Token GetCharacter(int index)
			{
				return character_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
			public CoreNLPProtos.ITokenOrBuilder GetCharacterOrBuilder(int index)
			{
				return character_[index];
			}

			public const int ParagraphFieldNumber = 11;

			private int paragraph_;

			/// <summary><code>optional uint32 paragraph = 11;</code></summary>
			public bool HasParagraph()
			{
				return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
			}

			/// <summary><code>optional uint32 paragraph = 11;</code></summary>
			public int GetParagraph()
			{
				return paragraph_;
			}

			public const int TextFieldNumber = 12;

			private volatile object text_;

			/// <summary>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </pre>
			/// <code>optional string text = 12;</code>
			/// </remarks>
			public bool HasText()
			{
				return ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
			}

			/// <summary>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </pre>
			/// <code>optional string text = 12;</code>
			/// </remarks>
			public string GetText()
			{
				object @ref = text_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						text_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Only needed if we're only saving the sentence.
			/// </pre>
			/// <code>optional string text = 12;</code>
			/// </remarks>
			public ByteString GetTextBytes()
			{
				object @ref = text_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					text_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int LinenumberFieldNumber = 20;

			private int lineNumber_;

			/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
			public bool HasLineNumber()
			{
				return ((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
			}

			/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
			public int GetLineNumber()
			{
				return lineNumber_;
			}

			public const int HasrelationannotationsFieldNumber = 51;

			private bool hasRelationAnnotations_;

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional bool hasRelationAnnotations = 51;</code>
			/// </summary>
			public bool HasHasRelationAnnotations()
			{
				return ((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000)));
			}

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional bool hasRelationAnnotations = 51;</code>
			/// </summary>
			public bool GetHasRelationAnnotations()
			{
				return hasRelationAnnotations_;
			}

			public const int EntityFieldNumber = 52;

			private IList<CoreNLPProtos.Entity> entity_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			public IList<CoreNLPProtos.Entity> GetEntityList()
			{
				return entity_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			public IList<CoreNLPProtos.IEntityOrBuilder> GetEntityOrBuilderList()
			{
				return entity_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			public int GetEntityCount()
			{
				return entity_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			public CoreNLPProtos.Entity GetEntity(int index)
			{
				return entity_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
			public CoreNLPProtos.IEntityOrBuilder GetEntityOrBuilder(int index)
			{
				return entity_[index];
			}

			public const int RelationFieldNumber = 53;

			private IList<CoreNLPProtos.Relation> relation_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			public IList<CoreNLPProtos.Relation> GetRelationList()
			{
				return relation_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			public IList<CoreNLPProtos.IRelationOrBuilder> GetRelationOrBuilderList()
			{
				return relation_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			public int GetRelationCount()
			{
				return relation_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			public CoreNLPProtos.Relation GetRelation(int index)
			{
				return relation_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
			public CoreNLPProtos.IRelationOrBuilder GetRelationOrBuilder(int index)
			{
				return relation_[index];
			}

			public const int HasnumerizedtokensannotationFieldNumber = 54;

			private bool hasNumerizedTokensAnnotation_;

			/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
			public bool HasHasNumerizedTokensAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
			}

			/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
			public bool GetHasNumerizedTokensAnnotation()
			{
				return hasNumerizedTokensAnnotation_;
			}

			public const int MentionsFieldNumber = 55;

			private IList<CoreNLPProtos.NERMention> mentions_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			public IList<CoreNLPProtos.NERMention> GetMentionsList()
			{
				return mentions_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			public IList<CoreNLPProtos.INERMentionOrBuilder> GetMentionsOrBuilderList()
			{
				return mentions_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			public int GetMentionsCount()
			{
				return mentions_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			public CoreNLPProtos.NERMention GetMentions(int index)
			{
				return mentions_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
			public CoreNLPProtos.INERMentionOrBuilder GetMentionsOrBuilder(int index)
			{
				return mentions_[index];
			}

			public const int MentionsforcorefFieldNumber = 56;

			private IList<CoreNLPProtos.Mention> mentionsForCoref_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			public IList<CoreNLPProtos.Mention> GetMentionsForCorefList()
			{
				return mentionsForCoref_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			public IList<CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefOrBuilderList()
			{
				return mentionsForCoref_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			public int GetMentionsForCorefCount()
			{
				return mentionsForCoref_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			public CoreNLPProtos.Mention GetMentionsForCoref(int index)
			{
				return mentionsForCoref_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
			public CoreNLPProtos.IMentionOrBuilder GetMentionsForCorefOrBuilder(int index)
			{
				return mentionsForCoref_[index];
			}

			public const int HascorefmentionsannotationFieldNumber = 57;

			private bool hasCorefMentionsAnnotation_;

			/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
			public bool HasHasCorefMentionsAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
			}

			/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
			public bool GetHasCorefMentionsAnnotation()
			{
				return hasCorefMentionsAnnotation_;
			}

			public const int SentenceidFieldNumber = 58;

			private volatile object sentenceID_;

			/// <summary>
			/// <pre>
			/// Useful when storing sentences (e.g.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Useful when storing sentences (e.g. ForEach)
			/// </pre>
			/// <code>optional string sentenceID = 58;</code>
			/// </remarks>
			public bool HasSentenceID()
			{
				return ((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000)));
			}

			/// <summary>
			/// <pre>
			/// Useful when storing sentences (e.g.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Useful when storing sentences (e.g. ForEach)
			/// </pre>
			/// <code>optional string sentenceID = 58;</code>
			/// </remarks>
			public string GetSentenceID()
			{
				object @ref = sentenceID_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sentenceID_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Useful when storing sentences (e.g.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// Useful when storing sentences (e.g. ForEach)
			/// </pre>
			/// <code>optional string sentenceID = 58;</code>
			/// </remarks>
			public ByteString GetSentenceIDBytes()
			{
				object @ref = sentenceID_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sentenceID_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectiondateFieldNumber = 59;

			private volatile object sectionDate_;

			/// <summary>
			/// <pre>
			/// date of section
			/// </pre>
			/// <code>optional string sectionDate = 59;</code>
			/// </summary>
			public bool HasSectionDate()
			{
				return ((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000)));
			}

			/// <summary>
			/// <pre>
			/// date of section
			/// </pre>
			/// <code>optional string sectionDate = 59;</code>
			/// </summary>
			public string GetSectionDate()
			{
				object @ref = sectionDate_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sectionDate_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// date of section
			/// </pre>
			/// <code>optional string sectionDate = 59;</code>
			/// </summary>
			public ByteString GetSectionDateBytes()
			{
				object @ref = sectionDate_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sectionDate_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectionindexFieldNumber = 60;

			private int sectionIndex_;

			/// <summary>
			/// <pre>
			/// section index for this sentence's section
			/// </pre>
			/// <code>optional uint32 sectionIndex = 60;</code>
			/// </summary>
			public bool HasSectionIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000)));
			}

			/// <summary>
			/// <pre>
			/// section index for this sentence's section
			/// </pre>
			/// <code>optional uint32 sectionIndex = 60;</code>
			/// </summary>
			public int GetSectionIndex()
			{
				return sectionIndex_;
			}

			public const int SectionnameFieldNumber = 61;

			private volatile object sectionName_;

			/// <summary>
			/// <pre>
			/// name of section
			/// </pre>
			/// <code>optional string sectionName = 61;</code>
			/// </summary>
			public bool HasSectionName()
			{
				return ((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000)));
			}

			/// <summary>
			/// <pre>
			/// name of section
			/// </pre>
			/// <code>optional string sectionName = 61;</code>
			/// </summary>
			public string GetSectionName()
			{
				object @ref = sectionName_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sectionName_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// name of section
			/// </pre>
			/// <code>optional string sectionName = 61;</code>
			/// </summary>
			public ByteString GetSectionNameBytes()
			{
				object @ref = sectionName_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sectionName_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectionauthorFieldNumber = 62;

			private volatile object sectionAuthor_;

			/// <summary>
			/// <pre>
			/// author of section
			/// </pre>
			/// <code>optional string sectionAuthor = 62;</code>
			/// </summary>
			public bool HasSectionAuthor()
			{
				return ((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000)));
			}

			/// <summary>
			/// <pre>
			/// author of section
			/// </pre>
			/// <code>optional string sectionAuthor = 62;</code>
			/// </summary>
			public string GetSectionAuthor()
			{
				object @ref = sectionAuthor_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sectionAuthor_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// author of section
			/// </pre>
			/// <code>optional string sectionAuthor = 62;</code>
			/// </summary>
			public ByteString GetSectionAuthorBytes()
			{
				object @ref = sectionAuthor_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sectionAuthor_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int DocidFieldNumber = 63;

			private volatile object docID_;

			/// <summary>
			/// <pre>
			/// doc id
			/// </pre>
			/// <code>optional string docID = 63;</code>
			/// </summary>
			public bool HasDocID()
			{
				return ((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000)));
			}

			/// <summary>
			/// <pre>
			/// doc id
			/// </pre>
			/// <code>optional string docID = 63;</code>
			/// </summary>
			public string GetDocID()
			{
				object @ref = docID_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						docID_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// doc id
			/// </pre>
			/// <code>optional string docID = 63;</code>
			/// </summary>
			public ByteString GetDocIDBytes()
			{
				object @ref = docID_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					docID_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectionquotedFieldNumber = 64;

			private bool sectionQuoted_;

			/// <summary>
			/// <pre>
			/// is this sentence in an xml quote in a post
			/// </pre>
			/// <code>optional bool sectionQuoted = 64;</code>
			/// </summary>
			public bool HasSectionQuoted()
			{
				return ((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000)));
			}

			/// <summary>
			/// <pre>
			/// is this sentence in an xml quote in a post
			/// </pre>
			/// <code>optional bool sectionQuoted = 64;</code>
			/// </summary>
			public bool GetSectionQuoted()
			{
				return sectionQuoted_;
			}

			public const int HasentitymentionsannotationFieldNumber = 65;

			private bool hasEntityMentionsAnnotation_;

			/// <summary>
			/// <pre>
			/// check if there are entity mentions
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
			/// </summary>
			public bool HasHasEntityMentionsAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000)));
			}

			/// <summary>
			/// <pre>
			/// check if there are entity mentions
			/// </pre>
			/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
			/// </summary>
			public bool GetHasEntityMentionsAnnotation()
			{
				return hasEntityMentionsAnnotation_;
			}

			public const int HaskbptriplesannotationFieldNumber = 68;

			private bool hasKBPTriplesAnnotation_;

			/// <summary>
			/// <pre>
			/// check if there are KBP triples
			/// </pre>
			/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
			/// </summary>
			public bool HasHasKBPTriplesAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000)));
			}

			/// <summary>
			/// <pre>
			/// check if there are KBP triples
			/// </pre>
			/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
			/// </summary>
			public bool GetHasKBPTriplesAnnotation()
			{
				return hasKBPTriplesAnnotation_;
			}

			public const int HasopenietriplesannotationFieldNumber = 69;

			private bool hasOpenieTriplesAnnotation_;

			/// <summary>
			/// <pre>
			/// check if there are OpenIE triples
			/// </pre>
			/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
			/// </summary>
			public bool HasHasOpenieTriplesAnnotation()
			{
				return ((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000)));
			}

			/// <summary>
			/// <pre>
			/// check if there are OpenIE triples
			/// </pre>
			/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
			/// </summary>
			public bool GetHasOpenieTriplesAnnotation()
			{
				return hasOpenieTriplesAnnotation_;
			}

			public const int ChapterindexFieldNumber = 66;

			private int chapterIndex_;

			/// <summary>
			/// <pre>
			/// quote stuff
			/// </pre>
			/// <code>optional uint32 chapterIndex = 66;</code>
			/// </summary>
			public bool HasChapterIndex()
			{
				return ((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000)));
			}

			/// <summary>
			/// <pre>
			/// quote stuff
			/// </pre>
			/// <code>optional uint32 chapterIndex = 66;</code>
			/// </summary>
			public int GetChapterIndex()
			{
				return chapterIndex_;
			}

			public const int ParagraphindexFieldNumber = 67;

			private int paragraphIndex_;

			/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
			public bool HasParagraphIndex()
			{
				return ((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
			public int GetParagraphIndex()
			{
				return paragraphIndex_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasTokenOffsetBegin())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasTokenOffsetEnd())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				for (int i = 0; i < GetTokenCount(); i++)
				{
					if (!GetToken(i).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasBasicDependencies())
				{
					if (!GetBasicDependencies().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasCollapsedDependencies())
				{
					if (!GetCollapsedDependencies().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasCollapsedCCProcessedDependencies())
				{
					if (!GetCollapsedCCProcessedDependencies().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasAlternativeDependencies())
				{
					if (!GetAlternativeDependencies().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_1 = 0; i_1 < GetOpenieTripleCount(); i_1++)
				{
					if (!GetOpenieTriple(i_1).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_2 = 0; i_2 < GetKbpTripleCount(); i_2++)
				{
					if (!GetKbpTriple(i_2).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasEnhancedDependencies())
				{
					if (!GetEnhancedDependencies().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasEnhancedPlusPlusDependencies())
				{
					if (!GetEnhancedPlusPlusDependencies().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_3 = 0; i_3 < GetCharacterCount(); i_3++)
				{
					if (!GetCharacter(i_3).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_4 = 0; i_4 < GetMentionsCount(); i_4++)
				{
					if (!GetMentions(i_4).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (!ExtensionsAreInitialized())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				GeneratedMessageV3.ExtendableMessage.ExtensionWriter extensionWriter = NewExtensionWriter();
				for (int i = 0; i < token_.Count; i++)
				{
					output.WriteMessage(1, token_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(2, tokenOffsetBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(3, tokenOffsetEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteUInt32(4, sentenceIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteUInt32(5, characterOffsetBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteUInt32(6, characterOffsetEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteMessage(7, GetParseTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					output.WriteMessage(8, GetBasicDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					output.WriteMessage(9, GetCollapsedDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					output.WriteMessage(10, GetCollapsedCCProcessedDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					output.WriteUInt32(11, paragraph_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					GeneratedMessageV3.WriteString(output, 12, text_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					output.WriteMessage(13, GetAlternativeDependencies());
				}
				for (int i_1 = 0; i_1 < openieTriple_.Count; i_1++)
				{
					output.WriteMessage(14, openieTriple_[i_1]);
				}
				for (int i_2 = 0; i_2 < entailedSentence_.Count; i_2++)
				{
					output.WriteMessage(15, entailedSentence_[i_2]);
				}
				for (int i_3 = 0; i_3 < kbpTriple_.Count; i_3++)
				{
					output.WriteMessage(16, kbpTriple_[i_3]);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					output.WriteMessage(17, GetEnhancedDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					output.WriteMessage(18, GetEnhancedPlusPlusDependencies());
				}
				for (int i_4 = 0; i_4 < character_.Count; i_4++)
				{
					output.WriteMessage(19, character_[i_4]);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					output.WriteUInt32(20, lineNumber_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteMessage(31, GetBinarizedParseTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					output.WriteMessage(32, GetAnnotatedParseTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					GeneratedMessageV3.WriteString(output, 33, sentiment_);
				}
				for (int i_5 = 0; i_5 < kBestParseTrees_.Count; i_5++)
				{
					output.WriteMessage(34, kBestParseTrees_[i_5]);
				}
				for (int i_6 = 0; i_6 < entailedClause_.Count; i_6++)
				{
					output.WriteMessage(35, entailedClause_[i_6]);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					output.WriteBool(51, hasRelationAnnotations_);
				}
				for (int i_7 = 0; i_7 < entity_.Count; i_7++)
				{
					output.WriteMessage(52, entity_[i_7]);
				}
				for (int i_8 = 0; i_8 < relation_.Count; i_8++)
				{
					output.WriteMessage(53, relation_[i_8]);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					output.WriteBool(54, hasNumerizedTokensAnnotation_);
				}
				for (int i_9 = 0; i_9 < mentions_.Count; i_9++)
				{
					output.WriteMessage(55, mentions_[i_9]);
				}
				for (int i_10 = 0; i_10 < mentionsForCoref_.Count; i_10++)
				{
					output.WriteMessage(56, mentionsForCoref_[i_10]);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					output.WriteBool(57, hasCorefMentionsAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
				{
					GeneratedMessageV3.WriteString(output, 58, sentenceID_);
				}
				if (((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
				{
					GeneratedMessageV3.WriteString(output, 59, sectionDate_);
				}
				if (((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
				{
					output.WriteUInt32(60, sectionIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
				{
					GeneratedMessageV3.WriteString(output, 61, sectionName_);
				}
				if (((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
				{
					GeneratedMessageV3.WriteString(output, 62, sectionAuthor_);
				}
				if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
				{
					GeneratedMessageV3.WriteString(output, 63, docID_);
				}
				if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
				{
					output.WriteBool(64, sectionQuoted_);
				}
				if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
				{
					output.WriteBool(65, hasEntityMentionsAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
				{
					output.WriteUInt32(66, chapterIndex_);
				}
				if (((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(67, paragraphIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
				{
					output.WriteBool(68, hasKBPTriplesAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
				{
					output.WriteBool(69, hasOpenieTriplesAnnotation_);
				}
				extensionWriter.WriteUntil(256, output);
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				for (int i = 0; i < token_.Count; i++)
				{
					size += CodedOutputStream.ComputeMessageSize(1, token_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, tokenOffsetBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, tokenOffsetEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeUInt32Size(4, sentenceIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeUInt32Size(5, characterOffsetBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeUInt32Size(6, characterOffsetEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeMessageSize(7, GetParseTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					size += CodedOutputStream.ComputeMessageSize(8, GetBasicDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					size += CodedOutputStream.ComputeMessageSize(9, GetCollapsedDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					size += CodedOutputStream.ComputeMessageSize(10, GetCollapsedCCProcessedDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(11, paragraph_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(12, text_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					size += CodedOutputStream.ComputeMessageSize(13, GetAlternativeDependencies());
				}
				for (int i_1 = 0; i_1 < openieTriple_.Count; i_1++)
				{
					size += CodedOutputStream.ComputeMessageSize(14, openieTriple_[i_1]);
				}
				for (int i_2 = 0; i_2 < entailedSentence_.Count; i_2++)
				{
					size += CodedOutputStream.ComputeMessageSize(15, entailedSentence_[i_2]);
				}
				for (int i_3 = 0; i_3 < kbpTriple_.Count; i_3++)
				{
					size += CodedOutputStream.ComputeMessageSize(16, kbpTriple_[i_3]);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					size += CodedOutputStream.ComputeMessageSize(17, GetEnhancedDependencies());
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					size += CodedOutputStream.ComputeMessageSize(18, GetEnhancedPlusPlusDependencies());
				}
				for (int i_4 = 0; i_4 < character_.Count; i_4++)
				{
					size += CodedOutputStream.ComputeMessageSize(19, character_[i_4]);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(20, lineNumber_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeMessageSize(31, GetBinarizedParseTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += CodedOutputStream.ComputeMessageSize(32, GetAnnotatedParseTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += GeneratedMessageV3.ComputeStringSize(33, sentiment_);
				}
				for (int i_5 = 0; i_5 < kBestParseTrees_.Count; i_5++)
				{
					size += CodedOutputStream.ComputeMessageSize(34, kBestParseTrees_[i_5]);
				}
				for (int i_6 = 0; i_6 < entailedClause_.Count; i_6++)
				{
					size += CodedOutputStream.ComputeMessageSize(35, entailedClause_[i_6]);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					size += CodedOutputStream.ComputeBoolSize(51, hasRelationAnnotations_);
				}
				for (int i_7 = 0; i_7 < entity_.Count; i_7++)
				{
					size += CodedOutputStream.ComputeMessageSize(52, entity_[i_7]);
				}
				for (int i_8 = 0; i_8 < relation_.Count; i_8++)
				{
					size += CodedOutputStream.ComputeMessageSize(53, relation_[i_8]);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					size += CodedOutputStream.ComputeBoolSize(54, hasNumerizedTokensAnnotation_);
				}
				for (int i_9 = 0; i_9 < mentions_.Count; i_9++)
				{
					size += CodedOutputStream.ComputeMessageSize(55, mentions_[i_9]);
				}
				for (int i_10 = 0; i_10 < mentionsForCoref_.Count; i_10++)
				{
					size += CodedOutputStream.ComputeMessageSize(56, mentionsForCoref_[i_10]);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					size += CodedOutputStream.ComputeBoolSize(57, hasCorefMentionsAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(58, sentenceID_);
				}
				if (((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(59, sectionDate_);
				}
				if (((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(60, sectionIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(61, sectionName_);
				}
				if (((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(62, sectionAuthor_);
				}
				if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(63, docID_);
				}
				if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(64, sectionQuoted_);
				}
				if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(65, hasEntityMentionsAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(66, chapterIndex_);
				}
				if (((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(67, paragraphIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(68, hasKBPTriplesAnnotation_);
				}
				if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(69, hasOpenieTriplesAnnotation_);
				}
				size += ExtensionsSerializedSize();
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Sentence))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Sentence other = (CoreNLPProtos.Sentence)obj;
				bool result = true;
				result = result && GetTokenList().Equals(other.GetTokenList());
				result = result && (HasTokenOffsetBegin() == other.HasTokenOffsetBegin());
				if (HasTokenOffsetBegin())
				{
					result = result && (GetTokenOffsetBegin() == other.GetTokenOffsetBegin());
				}
				result = result && (HasTokenOffsetEnd() == other.HasTokenOffsetEnd());
				if (HasTokenOffsetEnd())
				{
					result = result && (GetTokenOffsetEnd() == other.GetTokenOffsetEnd());
				}
				result = result && (HasSentenceIndex() == other.HasSentenceIndex());
				if (HasSentenceIndex())
				{
					result = result && (GetSentenceIndex() == other.GetSentenceIndex());
				}
				result = result && (HasCharacterOffsetBegin() == other.HasCharacterOffsetBegin());
				if (HasCharacterOffsetBegin())
				{
					result = result && (GetCharacterOffsetBegin() == other.GetCharacterOffsetBegin());
				}
				result = result && (HasCharacterOffsetEnd() == other.HasCharacterOffsetEnd());
				if (HasCharacterOffsetEnd())
				{
					result = result && (GetCharacterOffsetEnd() == other.GetCharacterOffsetEnd());
				}
				result = result && (HasParseTree() == other.HasParseTree());
				if (HasParseTree())
				{
					result = result && GetParseTree().Equals(other.GetParseTree());
				}
				result = result && (HasBinarizedParseTree() == other.HasBinarizedParseTree());
				if (HasBinarizedParseTree())
				{
					result = result && GetBinarizedParseTree().Equals(other.GetBinarizedParseTree());
				}
				result = result && (HasAnnotatedParseTree() == other.HasAnnotatedParseTree());
				if (HasAnnotatedParseTree())
				{
					result = result && GetAnnotatedParseTree().Equals(other.GetAnnotatedParseTree());
				}
				result = result && (HasSentiment() == other.HasSentiment());
				if (HasSentiment())
				{
					result = result && GetSentiment().Equals(other.GetSentiment());
				}
				result = result && GetKBestParseTreesList().Equals(other.GetKBestParseTreesList());
				result = result && (HasBasicDependencies() == other.HasBasicDependencies());
				if (HasBasicDependencies())
				{
					result = result && GetBasicDependencies().Equals(other.GetBasicDependencies());
				}
				result = result && (HasCollapsedDependencies() == other.HasCollapsedDependencies());
				if (HasCollapsedDependencies())
				{
					result = result && GetCollapsedDependencies().Equals(other.GetCollapsedDependencies());
				}
				result = result && (HasCollapsedCCProcessedDependencies() == other.HasCollapsedCCProcessedDependencies());
				if (HasCollapsedCCProcessedDependencies())
				{
					result = result && GetCollapsedCCProcessedDependencies().Equals(other.GetCollapsedCCProcessedDependencies());
				}
				result = result && (HasAlternativeDependencies() == other.HasAlternativeDependencies());
				if (HasAlternativeDependencies())
				{
					result = result && GetAlternativeDependencies().Equals(other.GetAlternativeDependencies());
				}
				result = result && GetOpenieTripleList().Equals(other.GetOpenieTripleList());
				result = result && GetKbpTripleList().Equals(other.GetKbpTripleList());
				result = result && GetEntailedSentenceList().Equals(other.GetEntailedSentenceList());
				result = result && GetEntailedClauseList().Equals(other.GetEntailedClauseList());
				result = result && (HasEnhancedDependencies() == other.HasEnhancedDependencies());
				if (HasEnhancedDependencies())
				{
					result = result && GetEnhancedDependencies().Equals(other.GetEnhancedDependencies());
				}
				result = result && (HasEnhancedPlusPlusDependencies() == other.HasEnhancedPlusPlusDependencies());
				if (HasEnhancedPlusPlusDependencies())
				{
					result = result && GetEnhancedPlusPlusDependencies().Equals(other.GetEnhancedPlusPlusDependencies());
				}
				result = result && GetCharacterList().Equals(other.GetCharacterList());
				result = result && (HasParagraph() == other.HasParagraph());
				if (HasParagraph())
				{
					result = result && (GetParagraph() == other.GetParagraph());
				}
				result = result && (HasText() == other.HasText());
				if (HasText())
				{
					result = result && GetText().Equals(other.GetText());
				}
				result = result && (HasLineNumber() == other.HasLineNumber());
				if (HasLineNumber())
				{
					result = result && (GetLineNumber() == other.GetLineNumber());
				}
				result = result && (HasHasRelationAnnotations() == other.HasHasRelationAnnotations());
				if (HasHasRelationAnnotations())
				{
					result = result && (GetHasRelationAnnotations() == other.GetHasRelationAnnotations());
				}
				result = result && GetEntityList().Equals(other.GetEntityList());
				result = result && GetRelationList().Equals(other.GetRelationList());
				result = result && (HasHasNumerizedTokensAnnotation() == other.HasHasNumerizedTokensAnnotation());
				if (HasHasNumerizedTokensAnnotation())
				{
					result = result && (GetHasNumerizedTokensAnnotation() == other.GetHasNumerizedTokensAnnotation());
				}
				result = result && GetMentionsList().Equals(other.GetMentionsList());
				result = result && GetMentionsForCorefList().Equals(other.GetMentionsForCorefList());
				result = result && (HasHasCorefMentionsAnnotation() == other.HasHasCorefMentionsAnnotation());
				if (HasHasCorefMentionsAnnotation())
				{
					result = result && (GetHasCorefMentionsAnnotation() == other.GetHasCorefMentionsAnnotation());
				}
				result = result && (HasSentenceID() == other.HasSentenceID());
				if (HasSentenceID())
				{
					result = result && GetSentenceID().Equals(other.GetSentenceID());
				}
				result = result && (HasSectionDate() == other.HasSectionDate());
				if (HasSectionDate())
				{
					result = result && GetSectionDate().Equals(other.GetSectionDate());
				}
				result = result && (HasSectionIndex() == other.HasSectionIndex());
				if (HasSectionIndex())
				{
					result = result && (GetSectionIndex() == other.GetSectionIndex());
				}
				result = result && (HasSectionName() == other.HasSectionName());
				if (HasSectionName())
				{
					result = result && GetSectionName().Equals(other.GetSectionName());
				}
				result = result && (HasSectionAuthor() == other.HasSectionAuthor());
				if (HasSectionAuthor())
				{
					result = result && GetSectionAuthor().Equals(other.GetSectionAuthor());
				}
				result = result && (HasDocID() == other.HasDocID());
				if (HasDocID())
				{
					result = result && GetDocID().Equals(other.GetDocID());
				}
				result = result && (HasSectionQuoted() == other.HasSectionQuoted());
				if (HasSectionQuoted())
				{
					result = result && (GetSectionQuoted() == other.GetSectionQuoted());
				}
				result = result && (HasHasEntityMentionsAnnotation() == other.HasHasEntityMentionsAnnotation());
				if (HasHasEntityMentionsAnnotation())
				{
					result = result && (GetHasEntityMentionsAnnotation() == other.GetHasEntityMentionsAnnotation());
				}
				result = result && (HasHasKBPTriplesAnnotation() == other.HasHasKBPTriplesAnnotation());
				if (HasHasKBPTriplesAnnotation())
				{
					result = result && (GetHasKBPTriplesAnnotation() == other.GetHasKBPTriplesAnnotation());
				}
				result = result && (HasHasOpenieTriplesAnnotation() == other.HasHasOpenieTriplesAnnotation());
				if (HasHasOpenieTriplesAnnotation())
				{
					result = result && (GetHasOpenieTriplesAnnotation() == other.GetHasOpenieTriplesAnnotation());
				}
				result = result && (HasChapterIndex() == other.HasChapterIndex());
				if (HasChapterIndex())
				{
					result = result && (GetChapterIndex() == other.GetChapterIndex());
				}
				result = result && (HasParagraphIndex() == other.HasParagraphIndex());
				if (HasParagraphIndex())
				{
					result = result && (GetParagraphIndex() == other.GetParagraphIndex());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				result = result && GetExtensionFields().Equals(other.GetExtensionFields());
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (GetTokenCount() > 0)
				{
					hash = (37 * hash) + TokenFieldNumber;
					hash = (53 * hash) + GetTokenList().GetHashCode();
				}
				if (HasTokenOffsetBegin())
				{
					hash = (37 * hash) + TokenoffsetbeginFieldNumber;
					hash = (53 * hash) + GetTokenOffsetBegin();
				}
				if (HasTokenOffsetEnd())
				{
					hash = (37 * hash) + TokenoffsetendFieldNumber;
					hash = (53 * hash) + GetTokenOffsetEnd();
				}
				if (HasSentenceIndex())
				{
					hash = (37 * hash) + SentenceindexFieldNumber;
					hash = (53 * hash) + GetSentenceIndex();
				}
				if (HasCharacterOffsetBegin())
				{
					hash = (37 * hash) + CharacteroffsetbeginFieldNumber;
					hash = (53 * hash) + GetCharacterOffsetBegin();
				}
				if (HasCharacterOffsetEnd())
				{
					hash = (37 * hash) + CharacteroffsetendFieldNumber;
					hash = (53 * hash) + GetCharacterOffsetEnd();
				}
				if (HasParseTree())
				{
					hash = (37 * hash) + ParsetreeFieldNumber;
					hash = (53 * hash) + GetParseTree().GetHashCode();
				}
				if (HasBinarizedParseTree())
				{
					hash = (37 * hash) + BinarizedparsetreeFieldNumber;
					hash = (53 * hash) + GetBinarizedParseTree().GetHashCode();
				}
				if (HasAnnotatedParseTree())
				{
					hash = (37 * hash) + AnnotatedparsetreeFieldNumber;
					hash = (53 * hash) + GetAnnotatedParseTree().GetHashCode();
				}
				if (HasSentiment())
				{
					hash = (37 * hash) + SentimentFieldNumber;
					hash = (53 * hash) + GetSentiment().GetHashCode();
				}
				if (GetKBestParseTreesCount() > 0)
				{
					hash = (37 * hash) + KbestparsetreesFieldNumber;
					hash = (53 * hash) + GetKBestParseTreesList().GetHashCode();
				}
				if (HasBasicDependencies())
				{
					hash = (37 * hash) + BasicdependenciesFieldNumber;
					hash = (53 * hash) + GetBasicDependencies().GetHashCode();
				}
				if (HasCollapsedDependencies())
				{
					hash = (37 * hash) + CollapseddependenciesFieldNumber;
					hash = (53 * hash) + GetCollapsedDependencies().GetHashCode();
				}
				if (HasCollapsedCCProcessedDependencies())
				{
					hash = (37 * hash) + CollapsedccprocesseddependenciesFieldNumber;
					hash = (53 * hash) + GetCollapsedCCProcessedDependencies().GetHashCode();
				}
				if (HasAlternativeDependencies())
				{
					hash = (37 * hash) + AlternativedependenciesFieldNumber;
					hash = (53 * hash) + GetAlternativeDependencies().GetHashCode();
				}
				if (GetOpenieTripleCount() > 0)
				{
					hash = (37 * hash) + OpenietripleFieldNumber;
					hash = (53 * hash) + GetOpenieTripleList().GetHashCode();
				}
				if (GetKbpTripleCount() > 0)
				{
					hash = (37 * hash) + KbptripleFieldNumber;
					hash = (53 * hash) + GetKbpTripleList().GetHashCode();
				}
				if (GetEntailedSentenceCount() > 0)
				{
					hash = (37 * hash) + EntailedsentenceFieldNumber;
					hash = (53 * hash) + GetEntailedSentenceList().GetHashCode();
				}
				if (GetEntailedClauseCount() > 0)
				{
					hash = (37 * hash) + EntailedclauseFieldNumber;
					hash = (53 * hash) + GetEntailedClauseList().GetHashCode();
				}
				if (HasEnhancedDependencies())
				{
					hash = (37 * hash) + EnhanceddependenciesFieldNumber;
					hash = (53 * hash) + GetEnhancedDependencies().GetHashCode();
				}
				if (HasEnhancedPlusPlusDependencies())
				{
					hash = (37 * hash) + EnhancedplusplusdependenciesFieldNumber;
					hash = (53 * hash) + GetEnhancedPlusPlusDependencies().GetHashCode();
				}
				if (GetCharacterCount() > 0)
				{
					hash = (37 * hash) + CharacterFieldNumber;
					hash = (53 * hash) + GetCharacterList().GetHashCode();
				}
				if (HasParagraph())
				{
					hash = (37 * hash) + ParagraphFieldNumber;
					hash = (53 * hash) + GetParagraph();
				}
				if (HasText())
				{
					hash = (37 * hash) + TextFieldNumber;
					hash = (53 * hash) + GetText().GetHashCode();
				}
				if (HasLineNumber())
				{
					hash = (37 * hash) + LinenumberFieldNumber;
					hash = (53 * hash) + GetLineNumber();
				}
				if (HasHasRelationAnnotations())
				{
					hash = (37 * hash) + HasrelationannotationsFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasRelationAnnotations());
				}
				if (GetEntityCount() > 0)
				{
					hash = (37 * hash) + EntityFieldNumber;
					hash = (53 * hash) + GetEntityList().GetHashCode();
				}
				if (GetRelationCount() > 0)
				{
					hash = (37 * hash) + RelationFieldNumber;
					hash = (53 * hash) + GetRelationList().GetHashCode();
				}
				if (HasHasNumerizedTokensAnnotation())
				{
					hash = (37 * hash) + HasnumerizedtokensannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasNumerizedTokensAnnotation());
				}
				if (GetMentionsCount() > 0)
				{
					hash = (37 * hash) + MentionsFieldNumber;
					hash = (53 * hash) + GetMentionsList().GetHashCode();
				}
				if (GetMentionsForCorefCount() > 0)
				{
					hash = (37 * hash) + MentionsforcorefFieldNumber;
					hash = (53 * hash) + GetMentionsForCorefList().GetHashCode();
				}
				if (HasHasCorefMentionsAnnotation())
				{
					hash = (37 * hash) + HascorefmentionsannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasCorefMentionsAnnotation());
				}
				if (HasSentenceID())
				{
					hash = (37 * hash) + SentenceidFieldNumber;
					hash = (53 * hash) + GetSentenceID().GetHashCode();
				}
				if (HasSectionDate())
				{
					hash = (37 * hash) + SectiondateFieldNumber;
					hash = (53 * hash) + GetSectionDate().GetHashCode();
				}
				if (HasSectionIndex())
				{
					hash = (37 * hash) + SectionindexFieldNumber;
					hash = (53 * hash) + GetSectionIndex();
				}
				if (HasSectionName())
				{
					hash = (37 * hash) + SectionnameFieldNumber;
					hash = (53 * hash) + GetSectionName().GetHashCode();
				}
				if (HasSectionAuthor())
				{
					hash = (37 * hash) + SectionauthorFieldNumber;
					hash = (53 * hash) + GetSectionAuthor().GetHashCode();
				}
				if (HasDocID())
				{
					hash = (37 * hash) + DocidFieldNumber;
					hash = (53 * hash) + GetDocID().GetHashCode();
				}
				if (HasSectionQuoted())
				{
					hash = (37 * hash) + SectionquotedFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetSectionQuoted());
				}
				if (HasHasEntityMentionsAnnotation())
				{
					hash = (37 * hash) + HasentitymentionsannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasEntityMentionsAnnotation());
				}
				if (HasHasKBPTriplesAnnotation())
				{
					hash = (37 * hash) + HaskbptriplesannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasKBPTriplesAnnotation());
				}
				if (HasHasOpenieTriplesAnnotation())
				{
					hash = (37 * hash) + HasopenietriplesannotationFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasOpenieTriplesAnnotation());
				}
				if (HasChapterIndex())
				{
					hash = (37 * hash) + ChapterindexFieldNumber;
					hash = (53 * hash) + GetChapterIndex();
				}
				if (HasParagraphIndex())
				{
					hash = (37 * hash) + ParagraphindexFieldNumber;
					hash = (53 * hash) + GetParagraphIndex();
				}
				hash = HashFields(hash, GetExtensionFields());
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Sentence ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Sentence ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Sentence ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Sentence ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Sentence ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Sentence ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Sentence ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Sentence ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Sentence ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Sentence ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Sentence.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Sentence.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Sentence.Builder NewBuilder(CoreNLPProtos.Sentence prototype)
			{
				return ((CoreNLPProtos.Sentence.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Sentence.Builder() : new CoreNLPProtos.Sentence.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Sentence.Builder builder = new CoreNLPProtos.Sentence.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// The serialized version of a CoreMap representing a sentence.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// The serialized version of a CoreMap representing a sentence.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Sentence</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.ExtendableBuilder<CoreNLPProtos.Sentence, CoreNLPProtos.Sentence.Builder>, CoreNLPProtos.ISentenceOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Sentence)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Sentence_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Sentence_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Sentence), typeof(CoreNLPProtos.Sentence.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Sentence.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetTokenFieldBuilder();
						GetParseTreeFieldBuilder();
						GetBinarizedParseTreeFieldBuilder();
						GetAnnotatedParseTreeFieldBuilder();
						GetKBestParseTreesFieldBuilder();
						GetBasicDependenciesFieldBuilder();
						GetCollapsedDependenciesFieldBuilder();
						GetCollapsedCCProcessedDependenciesFieldBuilder();
						GetAlternativeDependenciesFieldBuilder();
						GetOpenieTripleFieldBuilder();
						GetKbpTripleFieldBuilder();
						GetEntailedSentenceFieldBuilder();
						GetEntailedClauseFieldBuilder();
						GetEnhancedDependenciesFieldBuilder();
						GetEnhancedPlusPlusDependenciesFieldBuilder();
						GetCharacterFieldBuilder();
						GetEntityFieldBuilder();
						GetRelationFieldBuilder();
						GetMentionsFieldBuilder();
						GetMentionsForCorefFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					if (tokenBuilder_ == null)
					{
						token_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					else
					{
						tokenBuilder_.Clear();
					}
					tokenOffsetBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					tokenOffsetEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					sentenceIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					characterOffsetBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					characterOffsetEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					if (parseTreeBuilder_ == null)
					{
						parseTree_ = null;
					}
					else
					{
						parseTreeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					if (binarizedParseTreeBuilder_ == null)
					{
						binarizedParseTree_ = null;
					}
					else
					{
						binarizedParseTreeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					if (annotatedParseTreeBuilder_ == null)
					{
						annotatedParseTree_ = null;
					}
					else
					{
						annotatedParseTreeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					sentiment_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					if (kBestParseTreesBuilder_ == null)
					{
						kBestParseTrees_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					}
					else
					{
						kBestParseTreesBuilder_.Clear();
					}
					if (basicDependenciesBuilder_ == null)
					{
						basicDependencies_ = null;
					}
					else
					{
						basicDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					if (collapsedDependenciesBuilder_ == null)
					{
						collapsedDependencies_ = null;
					}
					else
					{
						collapsedDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						collapsedCCProcessedDependencies_ = null;
					}
					else
					{
						collapsedCCProcessedDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					if (alternativeDependenciesBuilder_ == null)
					{
						alternativeDependencies_ = null;
					}
					else
					{
						alternativeDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					if (openieTripleBuilder_ == null)
					{
						openieTriple_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					}
					else
					{
						openieTripleBuilder_.Clear();
					}
					if (kbpTripleBuilder_ == null)
					{
						kbpTriple_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					}
					else
					{
						kbpTripleBuilder_.Clear();
					}
					if (entailedSentenceBuilder_ == null)
					{
						entailedSentence_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					}
					else
					{
						entailedSentenceBuilder_.Clear();
					}
					if (entailedClauseBuilder_ == null)
					{
						entailedClause_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
					}
					else
					{
						entailedClauseBuilder_.Clear();
					}
					if (enhancedDependenciesBuilder_ == null)
					{
						enhancedDependencies_ = null;
					}
					else
					{
						enhancedDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						enhancedPlusPlusDependencies_ = null;
					}
					else
					{
						enhancedPlusPlusDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					if (characterBuilder_ == null)
					{
						character_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
					}
					else
					{
						characterBuilder_.Clear();
					}
					paragraph_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
					text_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00800000)));
					lineNumber_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x01000000)));
					hasRelationAnnotations_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x02000000)));
					if (entityBuilder_ == null)
					{
						entity_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
					}
					else
					{
						entityBuilder_.Clear();
					}
					if (relationBuilder_ == null)
					{
						relation_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
					}
					else
					{
						relationBuilder_.Clear();
					}
					hasNumerizedTokensAnnotation_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x10000000)));
					if (mentionsBuilder_ == null)
					{
						mentions_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
					}
					else
					{
						mentionsBuilder_.Clear();
					}
					if (mentionsForCorefBuilder_ == null)
					{
						mentionsForCoref_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
					}
					else
					{
						mentionsForCorefBuilder_.Clear();
					}
					hasCorefMentionsAnnotation_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x80000000)));
					sentenceID_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
					sectionDate_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
					sectionIndex_ = 0;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
					sectionName_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
					sectionAuthor_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
					docID_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
					sectionQuoted_ = false;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
					hasEntityMentionsAnnotation_ = false;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
					hasKBPTriplesAnnotation_ = false;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
					hasOpenieTriplesAnnotation_ = false;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000200)));
					chapterIndex_ = 0;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000400)));
					paragraphIndex_ = 0;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000800)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Sentence_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Sentence.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Sentence result = ((CoreNLPProtos.Sentence)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Sentence result = new CoreNLPProtos.Sentence(this);
					int from_bitField0_ = bitField0_;
					int from_bitField1_ = bitField1_;
					int to_bitField0_ = 0;
					int to_bitField1_ = 0;
					if (tokenBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
						{
							token_ = Java.Util.Collections.UnmodifiableList(token_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						result.token_ = token_;
					}
					else
					{
						result.token_ = tokenBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.tokenOffsetBegin_ = tokenOffsetBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.tokenOffsetEnd_ = tokenOffsetEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.sentenceIndex_ = sentenceIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.characterOffsetBegin_ = characterOffsetBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.characterOffsetEnd_ = characterOffsetEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					if (parseTreeBuilder_ == null)
					{
						result.parseTree_ = parseTree_;
					}
					else
					{
						result.parseTree_ = parseTreeBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					if (binarizedParseTreeBuilder_ == null)
					{
						result.binarizedParseTree_ = binarizedParseTree_;
					}
					else
					{
						result.binarizedParseTree_ = binarizedParseTreeBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					if (annotatedParseTreeBuilder_ == null)
					{
						result.annotatedParseTree_ = annotatedParseTree_;
					}
					else
					{
						result.annotatedParseTree_ = annotatedParseTreeBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x00000100));
					}
					result.sentiment_ = sentiment_;
					if (kBestParseTreesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
						{
							kBestParseTrees_ = Java.Util.Collections.UnmodifiableList(kBestParseTrees_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
						}
						result.kBestParseTrees_ = kBestParseTrees_;
					}
					else
					{
						result.kBestParseTrees_ = kBestParseTreesBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField0_ |= unchecked((int)(0x00000200));
					}
					if (basicDependenciesBuilder_ == null)
					{
						result.basicDependencies_ = basicDependencies_;
					}
					else
					{
						result.basicDependencies_ = basicDependenciesBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
					{
						to_bitField0_ |= unchecked((int)(0x00000400));
					}
					if (collapsedDependenciesBuilder_ == null)
					{
						result.collapsedDependencies_ = collapsedDependencies_;
					}
					else
					{
						result.collapsedDependencies_ = collapsedDependenciesBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
					{
						to_bitField0_ |= unchecked((int)(0x00000800));
					}
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						result.collapsedCCProcessedDependencies_ = collapsedCCProcessedDependencies_;
					}
					else
					{
						result.collapsedCCProcessedDependencies_ = collapsedCCProcessedDependenciesBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
					{
						to_bitField0_ |= unchecked((int)(0x00001000));
					}
					if (alternativeDependenciesBuilder_ == null)
					{
						result.alternativeDependencies_ = alternativeDependencies_;
					}
					else
					{
						result.alternativeDependencies_ = alternativeDependenciesBuilder_.Build();
					}
					if (openieTripleBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
						{
							openieTriple_ = Java.Util.Collections.UnmodifiableList(openieTriple_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
						}
						result.openieTriple_ = openieTriple_;
					}
					else
					{
						result.openieTriple_ = openieTripleBuilder_.Build();
					}
					if (kbpTripleBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
						{
							kbpTriple_ = Java.Util.Collections.UnmodifiableList(kbpTriple_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
						}
						result.kbpTriple_ = kbpTriple_;
					}
					else
					{
						result.kbpTriple_ = kbpTripleBuilder_.Build();
					}
					if (entailedSentenceBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
						{
							entailedSentence_ = Java.Util.Collections.UnmodifiableList(entailedSentence_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
						}
						result.entailedSentence_ = entailedSentence_;
					}
					else
					{
						result.entailedSentence_ = entailedSentenceBuilder_.Build();
					}
					if (entailedClauseBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
						{
							entailedClause_ = Java.Util.Collections.UnmodifiableList(entailedClause_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
						}
						result.entailedClause_ = entailedClause_;
					}
					else
					{
						result.entailedClause_ = entailedClauseBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
					{
						to_bitField0_ |= unchecked((int)(0x00002000));
					}
					if (enhancedDependenciesBuilder_ == null)
					{
						result.enhancedDependencies_ = enhancedDependencies_;
					}
					else
					{
						result.enhancedDependencies_ = enhancedDependenciesBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
					{
						to_bitField0_ |= unchecked((int)(0x00004000));
					}
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						result.enhancedPlusPlusDependencies_ = enhancedPlusPlusDependencies_;
					}
					else
					{
						result.enhancedPlusPlusDependencies_ = enhancedPlusPlusDependenciesBuilder_.Build();
					}
					if (characterBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
						{
							character_ = Java.Util.Collections.UnmodifiableList(character_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
						}
						result.character_ = character_;
					}
					else
					{
						result.character_ = characterBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
					{
						to_bitField0_ |= unchecked((int)(0x00008000));
					}
					result.paragraph_ = paragraph_;
					if (((from_bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
					{
						to_bitField0_ |= unchecked((int)(0x00010000));
					}
					result.text_ = text_;
					if (((from_bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
					{
						to_bitField0_ |= unchecked((int)(0x00020000));
					}
					result.lineNumber_ = lineNumber_;
					if (((from_bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
					{
						to_bitField0_ |= unchecked((int)(0x00040000));
					}
					result.hasRelationAnnotations_ = hasRelationAnnotations_;
					if (entityBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
						{
							entity_ = Java.Util.Collections.UnmodifiableList(entity_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
						}
						result.entity_ = entity_;
					}
					else
					{
						result.entity_ = entityBuilder_.Build();
					}
					if (relationBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
						{
							relation_ = Java.Util.Collections.UnmodifiableList(relation_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
						}
						result.relation_ = relation_;
					}
					else
					{
						result.relation_ = relationBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
					{
						to_bitField0_ |= unchecked((int)(0x00080000));
					}
					result.hasNumerizedTokensAnnotation_ = hasNumerizedTokensAnnotation_;
					if (mentionsBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
						{
							mentions_ = Java.Util.Collections.UnmodifiableList(mentions_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
						}
						result.mentions_ = mentions_;
					}
					else
					{
						result.mentions_ = mentionsBuilder_.Build();
					}
					if (mentionsForCorefBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
						{
							mentionsForCoref_ = Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
						}
						result.mentionsForCoref_ = mentionsForCoref_;
					}
					else
					{
						result.mentionsForCoref_ = mentionsForCorefBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
					{
						to_bitField0_ |= unchecked((int)(0x00100000));
					}
					result.hasCorefMentionsAnnotation_ = hasCorefMentionsAnnotation_;
					if (((from_bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00200000));
					}
					result.sentenceID_ = sentenceID_;
					if (((from_bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00400000));
					}
					result.sectionDate_ = sectionDate_;
					if (((from_bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00800000));
					}
					result.sectionIndex_ = sectionIndex_;
					if (((from_bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x01000000));
					}
					result.sectionName_ = sectionName_;
					if (((from_bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x02000000));
					}
					result.sectionAuthor_ = sectionAuthor_;
					if (((from_bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x04000000));
					}
					result.docID_ = docID_;
					if (((from_bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x08000000));
					}
					result.sectionQuoted_ = sectionQuoted_;
					if (((from_bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x10000000));
					}
					result.hasEntityMentionsAnnotation_ = hasEntityMentionsAnnotation_;
					if (((from_bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x20000000));
					}
					result.hasKBPTriplesAnnotation_ = hasKBPTriplesAnnotation_;
					if (((from_bitField1_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x40000000));
					}
					result.hasOpenieTriplesAnnotation_ = hasOpenieTriplesAnnotation_;
					if (((from_bitField1_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x80000000));
					}
					result.chapterIndex_ = chapterIndex_;
					if (((from_bitField1_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField1_ |= unchecked((int)(0x00000001));
					}
					result.paragraphIndex_ = paragraphIndex_;
					result.bitField0_ = to_bitField0_;
					result.bitField1_ = to_bitField1_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Sentence.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Sentence.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Sentence.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Sentence.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Sentence.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Sentence.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Sentence.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Sentence.Builder SetExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Sentence, Type> extension, Type value)
				{
					return (CoreNLPProtos.Sentence.Builder)base.SetExtension(extension, value);
				}

				public override CoreNLPProtos.Sentence.Builder SetExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Sentence, IList<Type>> extension, int index, Type value)
				{
					return (CoreNLPProtos.Sentence.Builder)base.SetExtension(extension, index, value);
				}

				public override CoreNLPProtos.Sentence.Builder AddExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Sentence, IList<Type>> extension, Type value)
				{
					return (CoreNLPProtos.Sentence.Builder)base.AddExtension(extension, value);
				}

				public override CoreNLPProtos.Sentence.Builder ClearExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Sentence, object> extension)
				{
					return (CoreNLPProtos.Sentence.Builder)base.ClearExtension(extension);
				}

				public override CoreNLPProtos.Sentence.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Sentence)
					{
						return MergeFrom((CoreNLPProtos.Sentence)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Sentence.Builder MergeFrom(CoreNLPProtos.Sentence other)
				{
					if (other == CoreNLPProtos.Sentence.GetDefaultInstance())
					{
						return this;
					}
					if (tokenBuilder_ == null)
					{
						if (!other.token_.IsEmpty())
						{
							if (token_.IsEmpty())
							{
								token_ = other.token_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
							}
							else
							{
								EnsureTokenIsMutable();
								Sharpen.Collections.AddAll(token_, other.token_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.token_.IsEmpty())
						{
							if (tokenBuilder_.IsEmpty())
							{
								tokenBuilder_.Dispose();
								tokenBuilder_ = null;
								token_ = other.token_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
								tokenBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetTokenFieldBuilder() : null;
							}
							else
							{
								tokenBuilder_.AddAllMessages(other.token_);
							}
						}
					}
					if (other.HasTokenOffsetBegin())
					{
						SetTokenOffsetBegin(other.GetTokenOffsetBegin());
					}
					if (other.HasTokenOffsetEnd())
					{
						SetTokenOffsetEnd(other.GetTokenOffsetEnd());
					}
					if (other.HasSentenceIndex())
					{
						SetSentenceIndex(other.GetSentenceIndex());
					}
					if (other.HasCharacterOffsetBegin())
					{
						SetCharacterOffsetBegin(other.GetCharacterOffsetBegin());
					}
					if (other.HasCharacterOffsetEnd())
					{
						SetCharacterOffsetEnd(other.GetCharacterOffsetEnd());
					}
					if (other.HasParseTree())
					{
						MergeParseTree(other.GetParseTree());
					}
					if (other.HasBinarizedParseTree())
					{
						MergeBinarizedParseTree(other.GetBinarizedParseTree());
					}
					if (other.HasAnnotatedParseTree())
					{
						MergeAnnotatedParseTree(other.GetAnnotatedParseTree());
					}
					if (other.HasSentiment())
					{
						bitField0_ |= unchecked((int)(0x00000200));
						sentiment_ = other.sentiment_;
						OnChanged();
					}
					if (kBestParseTreesBuilder_ == null)
					{
						if (!other.kBestParseTrees_.IsEmpty())
						{
							if (kBestParseTrees_.IsEmpty())
							{
								kBestParseTrees_ = other.kBestParseTrees_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
							}
							else
							{
								EnsureKBestParseTreesIsMutable();
								Sharpen.Collections.AddAll(kBestParseTrees_, other.kBestParseTrees_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.kBestParseTrees_.IsEmpty())
						{
							if (kBestParseTreesBuilder_.IsEmpty())
							{
								kBestParseTreesBuilder_.Dispose();
								kBestParseTreesBuilder_ = null;
								kBestParseTrees_ = other.kBestParseTrees_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
								kBestParseTreesBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetKBestParseTreesFieldBuilder() : null;
							}
							else
							{
								kBestParseTreesBuilder_.AddAllMessages(other.kBestParseTrees_);
							}
						}
					}
					if (other.HasBasicDependencies())
					{
						MergeBasicDependencies(other.GetBasicDependencies());
					}
					if (other.HasCollapsedDependencies())
					{
						MergeCollapsedDependencies(other.GetCollapsedDependencies());
					}
					if (other.HasCollapsedCCProcessedDependencies())
					{
						MergeCollapsedCCProcessedDependencies(other.GetCollapsedCCProcessedDependencies());
					}
					if (other.HasAlternativeDependencies())
					{
						MergeAlternativeDependencies(other.GetAlternativeDependencies());
					}
					if (openieTripleBuilder_ == null)
					{
						if (!other.openieTriple_.IsEmpty())
						{
							if (openieTriple_.IsEmpty())
							{
								openieTriple_ = other.openieTriple_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
							}
							else
							{
								EnsureOpenieTripleIsMutable();
								Sharpen.Collections.AddAll(openieTriple_, other.openieTriple_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.openieTriple_.IsEmpty())
						{
							if (openieTripleBuilder_.IsEmpty())
							{
								openieTripleBuilder_.Dispose();
								openieTripleBuilder_ = null;
								openieTriple_ = other.openieTriple_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
								openieTripleBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetOpenieTripleFieldBuilder() : null;
							}
							else
							{
								openieTripleBuilder_.AddAllMessages(other.openieTriple_);
							}
						}
					}
					if (kbpTripleBuilder_ == null)
					{
						if (!other.kbpTriple_.IsEmpty())
						{
							if (kbpTriple_.IsEmpty())
							{
								kbpTriple_ = other.kbpTriple_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
							}
							else
							{
								EnsureKbpTripleIsMutable();
								Sharpen.Collections.AddAll(kbpTriple_, other.kbpTriple_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.kbpTriple_.IsEmpty())
						{
							if (kbpTripleBuilder_.IsEmpty())
							{
								kbpTripleBuilder_.Dispose();
								kbpTripleBuilder_ = null;
								kbpTriple_ = other.kbpTriple_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
								kbpTripleBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetKbpTripleFieldBuilder() : null;
							}
							else
							{
								kbpTripleBuilder_.AddAllMessages(other.kbpTriple_);
							}
						}
					}
					if (entailedSentenceBuilder_ == null)
					{
						if (!other.entailedSentence_.IsEmpty())
						{
							if (entailedSentence_.IsEmpty())
							{
								entailedSentence_ = other.entailedSentence_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
							}
							else
							{
								EnsureEntailedSentenceIsMutable();
								Sharpen.Collections.AddAll(entailedSentence_, other.entailedSentence_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.entailedSentence_.IsEmpty())
						{
							if (entailedSentenceBuilder_.IsEmpty())
							{
								entailedSentenceBuilder_.Dispose();
								entailedSentenceBuilder_ = null;
								entailedSentence_ = other.entailedSentence_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
								entailedSentenceBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetEntailedSentenceFieldBuilder() : null;
							}
							else
							{
								entailedSentenceBuilder_.AddAllMessages(other.entailedSentence_);
							}
						}
					}
					if (entailedClauseBuilder_ == null)
					{
						if (!other.entailedClause_.IsEmpty())
						{
							if (entailedClause_.IsEmpty())
							{
								entailedClause_ = other.entailedClause_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
							}
							else
							{
								EnsureEntailedClauseIsMutable();
								Sharpen.Collections.AddAll(entailedClause_, other.entailedClause_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.entailedClause_.IsEmpty())
						{
							if (entailedClauseBuilder_.IsEmpty())
							{
								entailedClauseBuilder_.Dispose();
								entailedClauseBuilder_ = null;
								entailedClause_ = other.entailedClause_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
								entailedClauseBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetEntailedClauseFieldBuilder() : null;
							}
							else
							{
								entailedClauseBuilder_.AddAllMessages(other.entailedClause_);
							}
						}
					}
					if (other.HasEnhancedDependencies())
					{
						MergeEnhancedDependencies(other.GetEnhancedDependencies());
					}
					if (other.HasEnhancedPlusPlusDependencies())
					{
						MergeEnhancedPlusPlusDependencies(other.GetEnhancedPlusPlusDependencies());
					}
					if (characterBuilder_ == null)
					{
						if (!other.character_.IsEmpty())
						{
							if (character_.IsEmpty())
							{
								character_ = other.character_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
							}
							else
							{
								EnsureCharacterIsMutable();
								Sharpen.Collections.AddAll(character_, other.character_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.character_.IsEmpty())
						{
							if (characterBuilder_.IsEmpty())
							{
								characterBuilder_.Dispose();
								characterBuilder_ = null;
								character_ = other.character_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
								characterBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetCharacterFieldBuilder() : null;
							}
							else
							{
								characterBuilder_.AddAllMessages(other.character_);
							}
						}
					}
					if (other.HasParagraph())
					{
						SetParagraph(other.GetParagraph());
					}
					if (other.HasText())
					{
						bitField0_ |= unchecked((int)(0x00800000));
						text_ = other.text_;
						OnChanged();
					}
					if (other.HasLineNumber())
					{
						SetLineNumber(other.GetLineNumber());
					}
					if (other.HasHasRelationAnnotations())
					{
						SetHasRelationAnnotations(other.GetHasRelationAnnotations());
					}
					if (entityBuilder_ == null)
					{
						if (!other.entity_.IsEmpty())
						{
							if (entity_.IsEmpty())
							{
								entity_ = other.entity_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
							}
							else
							{
								EnsureEntityIsMutable();
								Sharpen.Collections.AddAll(entity_, other.entity_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.entity_.IsEmpty())
						{
							if (entityBuilder_.IsEmpty())
							{
								entityBuilder_.Dispose();
								entityBuilder_ = null;
								entity_ = other.entity_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
								entityBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetEntityFieldBuilder() : null;
							}
							else
							{
								entityBuilder_.AddAllMessages(other.entity_);
							}
						}
					}
					if (relationBuilder_ == null)
					{
						if (!other.relation_.IsEmpty())
						{
							if (relation_.IsEmpty())
							{
								relation_ = other.relation_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
							}
							else
							{
								EnsureRelationIsMutable();
								Sharpen.Collections.AddAll(relation_, other.relation_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.relation_.IsEmpty())
						{
							if (relationBuilder_.IsEmpty())
							{
								relationBuilder_.Dispose();
								relationBuilder_ = null;
								relation_ = other.relation_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
								relationBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetRelationFieldBuilder() : null;
							}
							else
							{
								relationBuilder_.AddAllMessages(other.relation_);
							}
						}
					}
					if (other.HasHasNumerizedTokensAnnotation())
					{
						SetHasNumerizedTokensAnnotation(other.GetHasNumerizedTokensAnnotation());
					}
					if (mentionsBuilder_ == null)
					{
						if (!other.mentions_.IsEmpty())
						{
							if (mentions_.IsEmpty())
							{
								mentions_ = other.mentions_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
							}
							else
							{
								EnsureMentionsIsMutable();
								Sharpen.Collections.AddAll(mentions_, other.mentions_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.mentions_.IsEmpty())
						{
							if (mentionsBuilder_.IsEmpty())
							{
								mentionsBuilder_.Dispose();
								mentionsBuilder_ = null;
								mentions_ = other.mentions_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
								mentionsBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetMentionsFieldBuilder() : null;
							}
							else
							{
								mentionsBuilder_.AddAllMessages(other.mentions_);
							}
						}
					}
					if (mentionsForCorefBuilder_ == null)
					{
						if (!other.mentionsForCoref_.IsEmpty())
						{
							if (mentionsForCoref_.IsEmpty())
							{
								mentionsForCoref_ = other.mentionsForCoref_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
							}
							else
							{
								EnsureMentionsForCorefIsMutable();
								Sharpen.Collections.AddAll(mentionsForCoref_, other.mentionsForCoref_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.mentionsForCoref_.IsEmpty())
						{
							if (mentionsForCorefBuilder_.IsEmpty())
							{
								mentionsForCorefBuilder_.Dispose();
								mentionsForCorefBuilder_ = null;
								mentionsForCoref_ = other.mentionsForCoref_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
								mentionsForCorefBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetMentionsForCorefFieldBuilder() : null;
							}
							else
							{
								mentionsForCorefBuilder_.AddAllMessages(other.mentionsForCoref_);
							}
						}
					}
					if (other.HasHasCorefMentionsAnnotation())
					{
						SetHasCorefMentionsAnnotation(other.GetHasCorefMentionsAnnotation());
					}
					if (other.HasSentenceID())
					{
						bitField1_ |= unchecked((int)(0x00000001));
						sentenceID_ = other.sentenceID_;
						OnChanged();
					}
					if (other.HasSectionDate())
					{
						bitField1_ |= unchecked((int)(0x00000002));
						sectionDate_ = other.sectionDate_;
						OnChanged();
					}
					if (other.HasSectionIndex())
					{
						SetSectionIndex(other.GetSectionIndex());
					}
					if (other.HasSectionName())
					{
						bitField1_ |= unchecked((int)(0x00000008));
						sectionName_ = other.sectionName_;
						OnChanged();
					}
					if (other.HasSectionAuthor())
					{
						bitField1_ |= unchecked((int)(0x00000010));
						sectionAuthor_ = other.sectionAuthor_;
						OnChanged();
					}
					if (other.HasDocID())
					{
						bitField1_ |= unchecked((int)(0x00000020));
						docID_ = other.docID_;
						OnChanged();
					}
					if (other.HasSectionQuoted())
					{
						SetSectionQuoted(other.GetSectionQuoted());
					}
					if (other.HasHasEntityMentionsAnnotation())
					{
						SetHasEntityMentionsAnnotation(other.GetHasEntityMentionsAnnotation());
					}
					if (other.HasHasKBPTriplesAnnotation())
					{
						SetHasKBPTriplesAnnotation(other.GetHasKBPTriplesAnnotation());
					}
					if (other.HasHasOpenieTriplesAnnotation())
					{
						SetHasOpenieTriplesAnnotation(other.GetHasOpenieTriplesAnnotation());
					}
					if (other.HasChapterIndex())
					{
						SetChapterIndex(other.GetChapterIndex());
					}
					if (other.HasParagraphIndex())
					{
						SetParagraphIndex(other.GetParagraphIndex());
					}
					this.MergeExtensionFields(other);
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasTokenOffsetBegin())
					{
						return false;
					}
					if (!HasTokenOffsetEnd())
					{
						return false;
					}
					for (int i = 0; i < GetTokenCount(); i++)
					{
						if (!GetToken(i).IsInitialized())
						{
							return false;
						}
					}
					if (HasBasicDependencies())
					{
						if (!GetBasicDependencies().IsInitialized())
						{
							return false;
						}
					}
					if (HasCollapsedDependencies())
					{
						if (!GetCollapsedDependencies().IsInitialized())
						{
							return false;
						}
					}
					if (HasCollapsedCCProcessedDependencies())
					{
						if (!GetCollapsedCCProcessedDependencies().IsInitialized())
						{
							return false;
						}
					}
					if (HasAlternativeDependencies())
					{
						if (!GetAlternativeDependencies().IsInitialized())
						{
							return false;
						}
					}
					for (int i_1 = 0; i_1 < GetOpenieTripleCount(); i_1++)
					{
						if (!GetOpenieTriple(i_1).IsInitialized())
						{
							return false;
						}
					}
					for (int i_2 = 0; i_2 < GetKbpTripleCount(); i_2++)
					{
						if (!GetKbpTriple(i_2).IsInitialized())
						{
							return false;
						}
					}
					if (HasEnhancedDependencies())
					{
						if (!GetEnhancedDependencies().IsInitialized())
						{
							return false;
						}
					}
					if (HasEnhancedPlusPlusDependencies())
					{
						if (!GetEnhancedPlusPlusDependencies().IsInitialized())
						{
							return false;
						}
					}
					for (int i_3 = 0; i_3 < GetCharacterCount(); i_3++)
					{
						if (!GetCharacter(i_3).IsInitialized())
						{
							return false;
						}
					}
					for (int i_4 = 0; i_4 < GetMentionsCount(); i_4++)
					{
						if (!GetMentions(i_4).IsInitialized())
						{
							return false;
						}
					}
					if (!ExtensionsAreInitialized())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Sentence parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Sentence)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int bitField1_;

				private IList<CoreNLPProtos.Token> token_ = Java.Util.Collections.EmptyList();

				private void EnsureTokenIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						token_ = new List<CoreNLPProtos.Token>(token_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> tokenBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public IList<CoreNLPProtos.Token> GetTokenList()
				{
					if (tokenBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(token_);
					}
					else
					{
						return tokenBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public int GetTokenCount()
				{
					if (tokenBuilder_ == null)
					{
						return token_.Count;
					}
					else
					{
						return tokenBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Token GetToken(int index)
				{
					if (tokenBuilder_ == null)
					{
						return token_[index];
					}
					else
					{
						return tokenBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetToken(int index, CoreNLPProtos.Token value)
				{
					if (tokenBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureTokenIsMutable();
						token_.Set(index, value);
						OnChanged();
					}
					else
					{
						tokenBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetToken(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (tokenBuilder_ == null)
					{
						EnsureTokenIsMutable();
						token_.Set(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						tokenBuilder_.SetMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddToken(CoreNLPProtos.Token value)
				{
					if (tokenBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureTokenIsMutable();
						token_.Add(value);
						OnChanged();
					}
					else
					{
						tokenBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddToken(int index, CoreNLPProtos.Token value)
				{
					if (tokenBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureTokenIsMutable();
						token_.Add(index, value);
						OnChanged();
					}
					else
					{
						tokenBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddToken(CoreNLPProtos.Token.Builder builderForValue)
				{
					if (tokenBuilder_ == null)
					{
						EnsureTokenIsMutable();
						token_.Add(((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						tokenBuilder_.AddMessage(((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddToken(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (tokenBuilder_ == null)
					{
						EnsureTokenIsMutable();
						token_.Add(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						tokenBuilder_.AddMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddAllToken<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Token
				{
					if (tokenBuilder_ == null)
					{
						EnsureTokenIsMutable();
						AbstractMessageLite.Builder.AddAll(values, token_);
						OnChanged();
					}
					else
					{
						tokenBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearToken()
				{
					if (tokenBuilder_ == null)
					{
						token_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						OnChanged();
					}
					else
					{
						tokenBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Sentence.Builder RemoveToken(int index)
				{
					if (tokenBuilder_ == null)
					{
						EnsureTokenIsMutable();
						token_.Remove(index);
						OnChanged();
					}
					else
					{
						tokenBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Token.Builder GetTokenBuilder(int index)
				{
					return GetTokenFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.ITokenOrBuilder GetTokenOrBuilder(int index)
				{
					if (tokenBuilder_ == null)
					{
						return token_[index];
					}
					else
					{
						return tokenBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public IList<CoreNLPProtos.ITokenOrBuilder> GetTokenOrBuilderList()
				{
					if (tokenBuilder_ != null)
					{
						return tokenBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(token_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Token.Builder AddTokenBuilder()
				{
					return GetTokenFieldBuilder().AddBuilder(CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public CoreNLPProtos.Token.Builder AddTokenBuilder(int index)
				{
					return GetTokenFieldBuilder().AddBuilder(index, CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token token = 1;</code></summary>
				public IList<CoreNLPProtos.Token.Builder> GetTokenBuilderList()
				{
					return GetTokenFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> GetTokenFieldBuilder()
				{
					if (tokenBuilder_ == null)
					{
						tokenBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder>(token_, ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))), GetParentForChildren(), IsClean
							());
						token_ = null;
					}
					return tokenBuilder_;
				}

				private int tokenOffsetBegin_;

				/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
				public bool HasTokenOffsetBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
				public int GetTokenOffsetBegin()
				{
					return tokenOffsetBegin_;
				}

				/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetTokenOffsetBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					tokenOffsetBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 tokenOffsetBegin = 2;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearTokenOffsetBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					tokenOffsetBegin_ = 0;
					OnChanged();
					return this;
				}

				private int tokenOffsetEnd_;

				/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
				public bool HasTokenOffsetEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
				public int GetTokenOffsetEnd()
				{
					return tokenOffsetEnd_;
				}

				/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetTokenOffsetEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					tokenOffsetEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 tokenOffsetEnd = 3;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearTokenOffsetEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					tokenOffsetEnd_ = 0;
					OnChanged();
					return this;
				}

				private int sentenceIndex_;

				/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
				public bool HasSentenceIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
				public int GetSentenceIndex()
				{
					return sentenceIndex_;
				}

				/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetSentenceIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000008));
					sentenceIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 sentenceIndex = 4;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearSentenceIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					sentenceIndex_ = 0;
					OnChanged();
					return this;
				}

				private int characterOffsetBegin_;

				/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
				public bool HasCharacterOffsetBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
				public int GetCharacterOffsetBegin()
				{
					return characterOffsetBegin_;
				}

				/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCharacterOffsetBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000010));
					characterOffsetBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 characterOffsetBegin = 5;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearCharacterOffsetBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					characterOffsetBegin_ = 0;
					OnChanged();
					return this;
				}

				private int characterOffsetEnd_;

				/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
				public bool HasCharacterOffsetEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
				public int GetCharacterOffsetEnd()
				{
					return characterOffsetEnd_;
				}

				/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCharacterOffsetEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000020));
					characterOffsetEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 characterOffsetEnd = 6;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearCharacterOffsetEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					characterOffsetEnd_ = 0;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.ParseTree parseTree_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> parseTreeBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public bool HasParseTree()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public CoreNLPProtos.ParseTree GetParseTree()
				{
					if (parseTreeBuilder_ == null)
					{
						return parseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : parseTree_;
					}
					else
					{
						return parseTreeBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetParseTree(CoreNLPProtos.ParseTree value)
				{
					if (parseTreeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						parseTree_ = value;
						OnChanged();
					}
					else
					{
						parseTreeBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00000040));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetParseTree(CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (parseTreeBuilder_ == null)
					{
						parseTree_ = ((CoreNLPProtos.ParseTree)builderForValue.Build());
						OnChanged();
					}
					else
					{
						parseTreeBuilder_.SetMessage(((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00000040));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeParseTree(CoreNLPProtos.ParseTree value)
				{
					if (parseTreeBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))) && parseTree_ != null && parseTree_ != CoreNLPProtos.ParseTree.GetDefaultInstance())
						{
							parseTree_ = ((CoreNLPProtos.ParseTree)CoreNLPProtos.ParseTree.NewBuilder(parseTree_).MergeFrom(value).BuildPartial());
						}
						else
						{
							parseTree_ = value;
						}
						OnChanged();
					}
					else
					{
						parseTreeBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00000040));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearParseTree()
				{
					if (parseTreeBuilder_ == null)
					{
						parseTree_ = null;
						OnChanged();
					}
					else
					{
						parseTreeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public CoreNLPProtos.ParseTree.Builder GetParseTreeBuilder()
				{
					bitField0_ |= unchecked((int)(0x00000040));
					OnChanged();
					return GetParseTreeFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				public CoreNLPProtos.IParseTreeOrBuilder GetParseTreeOrBuilder()
				{
					if (parseTreeBuilder_ != null)
					{
						return parseTreeBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return parseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : parseTree_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> GetParseTreeFieldBuilder()
				{
					if (parseTreeBuilder_ == null)
					{
						parseTreeBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder>(GetParseTree(), GetParentForChildren(), IsClean());
						parseTree_ = null;
					}
					return parseTreeBuilder_;
				}

				private CoreNLPProtos.ParseTree binarizedParseTree_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> binarizedParseTreeBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public bool HasBinarizedParseTree()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public CoreNLPProtos.ParseTree GetBinarizedParseTree()
				{
					if (binarizedParseTreeBuilder_ == null)
					{
						return binarizedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : binarizedParseTree_;
					}
					else
					{
						return binarizedParseTreeBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetBinarizedParseTree(CoreNLPProtos.ParseTree value)
				{
					if (binarizedParseTreeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						binarizedParseTree_ = value;
						OnChanged();
					}
					else
					{
						binarizedParseTreeBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00000080));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetBinarizedParseTree(CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (binarizedParseTreeBuilder_ == null)
					{
						binarizedParseTree_ = ((CoreNLPProtos.ParseTree)builderForValue.Build());
						OnChanged();
					}
					else
					{
						binarizedParseTreeBuilder_.SetMessage(((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00000080));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeBinarizedParseTree(CoreNLPProtos.ParseTree value)
				{
					if (binarizedParseTreeBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))) && binarizedParseTree_ != null && binarizedParseTree_ != CoreNLPProtos.ParseTree.GetDefaultInstance())
						{
							binarizedParseTree_ = ((CoreNLPProtos.ParseTree)CoreNLPProtos.ParseTree.NewBuilder(binarizedParseTree_).MergeFrom(value).BuildPartial());
						}
						else
						{
							binarizedParseTree_ = value;
						}
						OnChanged();
					}
					else
					{
						binarizedParseTreeBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00000080));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearBinarizedParseTree()
				{
					if (binarizedParseTreeBuilder_ == null)
					{
						binarizedParseTree_ = null;
						OnChanged();
					}
					else
					{
						binarizedParseTreeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public CoreNLPProtos.ParseTree.Builder GetBinarizedParseTreeBuilder()
				{
					bitField0_ |= unchecked((int)(0x00000080));
					OnChanged();
					return GetBinarizedParseTreeFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				public CoreNLPProtos.IParseTreeOrBuilder GetBinarizedParseTreeOrBuilder()
				{
					if (binarizedParseTreeBuilder_ != null)
					{
						return binarizedParseTreeBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return binarizedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : binarizedParseTree_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> GetBinarizedParseTreeFieldBuilder()
				{
					if (binarizedParseTreeBuilder_ == null)
					{
						binarizedParseTreeBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder>(GetBinarizedParseTree(), GetParentForChildren(), IsClean());
						binarizedParseTree_ = null;
					}
					return binarizedParseTreeBuilder_;
				}

				private CoreNLPProtos.ParseTree annotatedParseTree_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> annotatedParseTreeBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public bool HasAnnotatedParseTree()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public CoreNLPProtos.ParseTree GetAnnotatedParseTree()
				{
					if (annotatedParseTreeBuilder_ == null)
					{
						return annotatedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : annotatedParseTree_;
					}
					else
					{
						return annotatedParseTreeBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetAnnotatedParseTree(CoreNLPProtos.ParseTree value)
				{
					if (annotatedParseTreeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						annotatedParseTree_ = value;
						OnChanged();
					}
					else
					{
						annotatedParseTreeBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00000100));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetAnnotatedParseTree(CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (annotatedParseTreeBuilder_ == null)
					{
						annotatedParseTree_ = ((CoreNLPProtos.ParseTree)builderForValue.Build());
						OnChanged();
					}
					else
					{
						annotatedParseTreeBuilder_.SetMessage(((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00000100));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeAnnotatedParseTree(CoreNLPProtos.ParseTree value)
				{
					if (annotatedParseTreeBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))) && annotatedParseTree_ != null && annotatedParseTree_ != CoreNLPProtos.ParseTree.GetDefaultInstance())
						{
							annotatedParseTree_ = ((CoreNLPProtos.ParseTree)CoreNLPProtos.ParseTree.NewBuilder(annotatedParseTree_).MergeFrom(value).BuildPartial());
						}
						else
						{
							annotatedParseTree_ = value;
						}
						OnChanged();
					}
					else
					{
						annotatedParseTreeBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00000100));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearAnnotatedParseTree()
				{
					if (annotatedParseTreeBuilder_ == null)
					{
						annotatedParseTree_ = null;
						OnChanged();
					}
					else
					{
						annotatedParseTreeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public CoreNLPProtos.ParseTree.Builder GetAnnotatedParseTreeBuilder()
				{
					bitField0_ |= unchecked((int)(0x00000100));
					OnChanged();
					return GetAnnotatedParseTreeFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				public CoreNLPProtos.IParseTreeOrBuilder GetAnnotatedParseTreeOrBuilder()
				{
					if (annotatedParseTreeBuilder_ != null)
					{
						return annotatedParseTreeBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return annotatedParseTree_ == null ? CoreNLPProtos.ParseTree.GetDefaultInstance() : annotatedParseTree_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> GetAnnotatedParseTreeFieldBuilder()
				{
					if (annotatedParseTreeBuilder_ == null)
					{
						annotatedParseTreeBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder>(GetAnnotatedParseTree(), GetParentForChildren(), IsClean());
						annotatedParseTree_ = null;
					}
					return annotatedParseTreeBuilder_;
				}

				private object sentiment_ = string.Empty;

				/// <summary><code>optional string sentiment = 33;</code></summary>
				public bool HasSentiment()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary><code>optional string sentiment = 33;</code></summary>
				public string GetSentiment()
				{
					object @ref = sentiment_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sentiment_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string sentiment = 33;</code></summary>
				public ByteString GetSentimentBytes()
				{
					object @ref = sentiment_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sentiment_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string sentiment = 33;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetSentiment(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					sentiment_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sentiment = 33;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearSentiment()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					sentiment_ = GetDefaultInstance().GetSentiment();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sentiment = 33;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetSentimentBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					sentiment_ = value;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.ParseTree> kBestParseTrees_ = Java.Util.Collections.EmptyList();

				private void EnsureKBestParseTreesIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						kBestParseTrees_ = new List<CoreNLPProtos.ParseTree>(kBestParseTrees_);
						bitField0_ |= unchecked((int)(0x00000400));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> kBestParseTreesBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public IList<CoreNLPProtos.ParseTree> GetKBestParseTreesList()
				{
					if (kBestParseTreesBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(kBestParseTrees_);
					}
					else
					{
						return kBestParseTreesBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public int GetKBestParseTreesCount()
				{
					if (kBestParseTreesBuilder_ == null)
					{
						return kBestParseTrees_.Count;
					}
					else
					{
						return kBestParseTreesBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.ParseTree GetKBestParseTrees(int index)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						return kBestParseTrees_[index];
					}
					else
					{
						return kBestParseTreesBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetKBestParseTrees(int index, CoreNLPProtos.ParseTree value)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureKBestParseTreesIsMutable();
						kBestParseTrees_.Set(index, value);
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetKBestParseTrees(int index, CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						EnsureKBestParseTreesIsMutable();
						kBestParseTrees_.Set(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.SetMessage(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddKBestParseTrees(CoreNLPProtos.ParseTree value)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureKBestParseTreesIsMutable();
						kBestParseTrees_.Add(value);
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddKBestParseTrees(int index, CoreNLPProtos.ParseTree value)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureKBestParseTreesIsMutable();
						kBestParseTrees_.Add(index, value);
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddKBestParseTrees(CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						EnsureKBestParseTreesIsMutable();
						kBestParseTrees_.Add(((CoreNLPProtos.ParseTree)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.AddMessage(((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddKBestParseTrees(int index, CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						EnsureKBestParseTreesIsMutable();
						kBestParseTrees_.Add(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.AddMessage(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddAllKBestParseTrees<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.ParseTree
				{
					if (kBestParseTreesBuilder_ == null)
					{
						EnsureKBestParseTreesIsMutable();
						AbstractMessageLite.Builder.AddAll(values, kBestParseTrees_);
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearKBestParseTrees()
				{
					if (kBestParseTreesBuilder_ == null)
					{
						kBestParseTrees_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.Sentence.Builder RemoveKBestParseTrees(int index)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						EnsureKBestParseTreesIsMutable();
						kBestParseTrees_.Remove(index);
						OnChanged();
					}
					else
					{
						kBestParseTreesBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.ParseTree.Builder GetKBestParseTreesBuilder(int index)
				{
					return GetKBestParseTreesFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.IParseTreeOrBuilder GetKBestParseTreesOrBuilder(int index)
				{
					if (kBestParseTreesBuilder_ == null)
					{
						return kBestParseTrees_[index];
					}
					else
					{
						return kBestParseTreesBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public IList<CoreNLPProtos.IParseTreeOrBuilder> GetKBestParseTreesOrBuilderList()
				{
					if (kBestParseTreesBuilder_ != null)
					{
						return kBestParseTreesBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(kBestParseTrees_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddKBestParseTreesBuilder()
				{
					return GetKBestParseTreesFieldBuilder().AddBuilder(CoreNLPProtos.ParseTree.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddKBestParseTreesBuilder(int index)
				{
					return GetKBestParseTreesFieldBuilder().AddBuilder(index, CoreNLPProtos.ParseTree.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;</code></summary>
				public IList<CoreNLPProtos.ParseTree.Builder> GetKBestParseTreesBuilderList()
				{
					return GetKBestParseTreesFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> GetKBestParseTreesFieldBuilder()
				{
					if (kBestParseTreesBuilder_ == null)
					{
						kBestParseTreesBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder>(kBestParseTrees_, ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)))
							, GetParentForChildren(), IsClean());
						kBestParseTrees_ = null;
					}
					return kBestParseTreesBuilder_;
				}

				private CoreNLPProtos.DependencyGraph basicDependencies_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> basicDependenciesBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public bool HasBasicDependencies()
				{
					return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public CoreNLPProtos.DependencyGraph GetBasicDependencies()
				{
					if (basicDependenciesBuilder_ == null)
					{
						return basicDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : basicDependencies_;
					}
					else
					{
						return basicDependenciesBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetBasicDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (basicDependenciesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						basicDependencies_ = value;
						OnChanged();
					}
					else
					{
						basicDependenciesBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00000800));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetBasicDependencies(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (basicDependenciesBuilder_ == null)
					{
						basicDependencies_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						basicDependenciesBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00000800));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeBasicDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (basicDependenciesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))) && basicDependencies_ != null && basicDependencies_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							basicDependencies_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(basicDependencies_).MergeFrom(value).BuildPartial());
						}
						else
						{
							basicDependencies_ = value;
						}
						OnChanged();
					}
					else
					{
						basicDependenciesBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00000800));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearBasicDependencies()
				{
					if (basicDependenciesBuilder_ == null)
					{
						basicDependencies_ = null;
						OnChanged();
					}
					else
					{
						basicDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder GetBasicDependenciesBuilder()
				{
					bitField0_ |= unchecked((int)(0x00000800));
					OnChanged();
					return GetBasicDependenciesFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetBasicDependenciesOrBuilder()
				{
					if (basicDependenciesBuilder_ != null)
					{
						return basicDependenciesBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return basicDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : basicDependencies_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetBasicDependenciesFieldBuilder()
				{
					if (basicDependenciesBuilder_ == null)
					{
						basicDependenciesBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetBasicDependencies(), GetParentForChildren(), IsClean());
						basicDependencies_ = null;
					}
					return basicDependenciesBuilder_;
				}

				private CoreNLPProtos.DependencyGraph collapsedDependencies_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> collapsedDependenciesBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public bool HasCollapsedDependencies()
				{
					return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public CoreNLPProtos.DependencyGraph GetCollapsedDependencies()
				{
					if (collapsedDependenciesBuilder_ == null)
					{
						return collapsedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedDependencies_;
					}
					else
					{
						return collapsedDependenciesBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCollapsedDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (collapsedDependenciesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						collapsedDependencies_ = value;
						OnChanged();
					}
					else
					{
						collapsedDependenciesBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00001000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCollapsedDependencies(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (collapsedDependenciesBuilder_ == null)
					{
						collapsedDependencies_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						collapsedDependenciesBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00001000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeCollapsedDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (collapsedDependenciesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))) && collapsedDependencies_ != null && collapsedDependencies_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							collapsedDependencies_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(collapsedDependencies_).MergeFrom(value).BuildPartial());
						}
						else
						{
							collapsedDependencies_ = value;
						}
						OnChanged();
					}
					else
					{
						collapsedDependenciesBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00001000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearCollapsedDependencies()
				{
					if (collapsedDependenciesBuilder_ == null)
					{
						collapsedDependencies_ = null;
						OnChanged();
					}
					else
					{
						collapsedDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder GetCollapsedDependenciesBuilder()
				{
					bitField0_ |= unchecked((int)(0x00001000));
					OnChanged();
					return GetCollapsedDependenciesFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetCollapsedDependenciesOrBuilder()
				{
					if (collapsedDependenciesBuilder_ != null)
					{
						return collapsedDependenciesBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return collapsedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedDependencies_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetCollapsedDependenciesFieldBuilder()
				{
					if (collapsedDependenciesBuilder_ == null)
					{
						collapsedDependenciesBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetCollapsedDependencies(), GetParentForChildren(), IsClean());
						collapsedDependencies_ = null;
					}
					return collapsedDependenciesBuilder_;
				}

				private CoreNLPProtos.DependencyGraph collapsedCCProcessedDependencies_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> collapsedCCProcessedDependenciesBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public bool HasCollapsedCCProcessedDependencies()
				{
					return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public CoreNLPProtos.DependencyGraph GetCollapsedCCProcessedDependencies()
				{
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						return collapsedCCProcessedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedCCProcessedDependencies_;
					}
					else
					{
						return collapsedCCProcessedDependenciesBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCollapsedCCProcessedDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						collapsedCCProcessedDependencies_ = value;
						OnChanged();
					}
					else
					{
						collapsedCCProcessedDependenciesBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00002000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCollapsedCCProcessedDependencies(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						collapsedCCProcessedDependencies_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						collapsedCCProcessedDependenciesBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00002000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeCollapsedCCProcessedDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))) && collapsedCCProcessedDependencies_ != null && collapsedCCProcessedDependencies_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							collapsedCCProcessedDependencies_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(collapsedCCProcessedDependencies_).MergeFrom(value).BuildPartial());
						}
						else
						{
							collapsedCCProcessedDependencies_ = value;
						}
						OnChanged();
					}
					else
					{
						collapsedCCProcessedDependenciesBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00002000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearCollapsedCCProcessedDependencies()
				{
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						collapsedCCProcessedDependencies_ = null;
						OnChanged();
					}
					else
					{
						collapsedCCProcessedDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder GetCollapsedCCProcessedDependenciesBuilder()
				{
					bitField0_ |= unchecked((int)(0x00002000));
					OnChanged();
					return GetCollapsedCCProcessedDependenciesFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetCollapsedCCProcessedDependenciesOrBuilder()
				{
					if (collapsedCCProcessedDependenciesBuilder_ != null)
					{
						return collapsedCCProcessedDependenciesBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return collapsedCCProcessedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : collapsedCCProcessedDependencies_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetCollapsedCCProcessedDependenciesFieldBuilder()
				{
					if (collapsedCCProcessedDependenciesBuilder_ == null)
					{
						collapsedCCProcessedDependenciesBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetCollapsedCCProcessedDependencies(), GetParentForChildren(), 
							IsClean());
						collapsedCCProcessedDependencies_ = null;
					}
					return collapsedCCProcessedDependenciesBuilder_;
				}

				private CoreNLPProtos.DependencyGraph alternativeDependencies_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> alternativeDependenciesBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public bool HasAlternativeDependencies()
				{
					return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public CoreNLPProtos.DependencyGraph GetAlternativeDependencies()
				{
					if (alternativeDependenciesBuilder_ == null)
					{
						return alternativeDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : alternativeDependencies_;
					}
					else
					{
						return alternativeDependenciesBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetAlternativeDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (alternativeDependenciesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						alternativeDependencies_ = value;
						OnChanged();
					}
					else
					{
						alternativeDependenciesBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00004000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetAlternativeDependencies(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (alternativeDependenciesBuilder_ == null)
					{
						alternativeDependencies_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						alternativeDependenciesBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00004000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeAlternativeDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (alternativeDependenciesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))) && alternativeDependencies_ != null && alternativeDependencies_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							alternativeDependencies_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(alternativeDependencies_).MergeFrom(value).BuildPartial());
						}
						else
						{
							alternativeDependencies_ = value;
						}
						OnChanged();
					}
					else
					{
						alternativeDependenciesBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00004000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearAlternativeDependencies()
				{
					if (alternativeDependenciesBuilder_ == null)
					{
						alternativeDependencies_ = null;
						OnChanged();
					}
					else
					{
						alternativeDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder GetAlternativeDependenciesBuilder()
				{
					bitField0_ |= unchecked((int)(0x00004000));
					OnChanged();
					return GetAlternativeDependenciesFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetAlternativeDependenciesOrBuilder()
				{
					if (alternativeDependenciesBuilder_ != null)
					{
						return alternativeDependenciesBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return alternativeDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : alternativeDependencies_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetAlternativeDependenciesFieldBuilder()
				{
					if (alternativeDependenciesBuilder_ == null)
					{
						alternativeDependenciesBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetAlternativeDependencies(), GetParentForChildren(), IsClean());
						alternativeDependencies_ = null;
					}
					return alternativeDependenciesBuilder_;
				}

				private IList<CoreNLPProtos.RelationTriple> openieTriple_ = Java.Util.Collections.EmptyList();

				private void EnsureOpenieTripleIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
					{
						openieTriple_ = new List<CoreNLPProtos.RelationTriple>(openieTriple_);
						bitField0_ |= unchecked((int)(0x00008000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.RelationTriple, CoreNLPProtos.RelationTriple.Builder, CoreNLPProtos.IRelationTripleOrBuilder> openieTripleBuilder_;

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.RelationTriple> GetOpenieTripleList()
				{
					if (openieTripleBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(openieTriple_);
					}
					else
					{
						return openieTripleBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public int GetOpenieTripleCount()
				{
					if (openieTripleBuilder_ == null)
					{
						return openieTriple_.Count;
					}
					else
					{
						return openieTripleBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple GetOpenieTriple(int index)
				{
					if (openieTripleBuilder_ == null)
					{
						return openieTriple_[index];
					}
					else
					{
						return openieTripleBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetOpenieTriple(int index, CoreNLPProtos.RelationTriple value)
				{
					if (openieTripleBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureOpenieTripleIsMutable();
						openieTriple_.Set(index, value);
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetOpenieTriple(int index, CoreNLPProtos.RelationTriple.Builder builderForValue)
				{
					if (openieTripleBuilder_ == null)
					{
						EnsureOpenieTripleIsMutable();
						openieTriple_.Set(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.SetMessage(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddOpenieTriple(CoreNLPProtos.RelationTriple value)
				{
					if (openieTripleBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureOpenieTripleIsMutable();
						openieTriple_.Add(value);
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddOpenieTriple(int index, CoreNLPProtos.RelationTriple value)
				{
					if (openieTripleBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureOpenieTripleIsMutable();
						openieTriple_.Add(index, value);
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddOpenieTriple(CoreNLPProtos.RelationTriple.Builder builderForValue)
				{
					if (openieTripleBuilder_ == null)
					{
						EnsureOpenieTripleIsMutable();
						openieTriple_.Add(((CoreNLPProtos.RelationTriple)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.AddMessage(((CoreNLPProtos.RelationTriple)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddOpenieTriple(int index, CoreNLPProtos.RelationTriple.Builder builderForValue)
				{
					if (openieTripleBuilder_ == null)
					{
						EnsureOpenieTripleIsMutable();
						openieTriple_.Add(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.AddMessage(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddAllOpenieTriple<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.RelationTriple
				{
					if (openieTripleBuilder_ == null)
					{
						EnsureOpenieTripleIsMutable();
						AbstractMessageLite.Builder.AddAll(values, openieTriple_);
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearOpenieTriple()
				{
					if (openieTripleBuilder_ == null)
					{
						openieTriple_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder RemoveOpenieTriple(int index)
				{
					if (openieTripleBuilder_ == null)
					{
						EnsureOpenieTripleIsMutable();
						openieTriple_.Remove(index);
						OnChanged();
					}
					else
					{
						openieTripleBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder GetOpenieTripleBuilder(int index)
				{
					return GetOpenieTripleFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.IRelationTripleOrBuilder GetOpenieTripleOrBuilder(int index)
				{
					if (openieTripleBuilder_ == null)
					{
						return openieTriple_[index];
					}
					else
					{
						return openieTripleBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.IRelationTripleOrBuilder> GetOpenieTripleOrBuilderList()
				{
					if (openieTripleBuilder_ != null)
					{
						return openieTripleBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(openieTriple_);
					}
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddOpenieTripleBuilder()
				{
					return GetOpenieTripleFieldBuilder().AddBuilder(CoreNLPProtos.RelationTriple.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddOpenieTripleBuilder(int index)
				{
					return GetOpenieTripleFieldBuilder().AddBuilder(index, CoreNLPProtos.RelationTriple.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The OpenIE triples in the sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.RelationTriple.Builder> GetOpenieTripleBuilderList()
				{
					return GetOpenieTripleFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.RelationTriple, CoreNLPProtos.RelationTriple.Builder, CoreNLPProtos.IRelationTripleOrBuilder> GetOpenieTripleFieldBuilder()
				{
					if (openieTripleBuilder_ == null)
					{
						openieTripleBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.RelationTriple, CoreNLPProtos.RelationTriple.Builder, CoreNLPProtos.IRelationTripleOrBuilder>(openieTriple_, ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000
							))), GetParentForChildren(), IsClean());
						openieTriple_ = null;
					}
					return openieTripleBuilder_;
				}

				private IList<CoreNLPProtos.RelationTriple> kbpTriple_ = Java.Util.Collections.EmptyList();

				private void EnsureKbpTripleIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						kbpTriple_ = new List<CoreNLPProtos.RelationTriple>(kbpTriple_);
						bitField0_ |= unchecked((int)(0x00010000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.RelationTriple, CoreNLPProtos.RelationTriple.Builder, CoreNLPProtos.IRelationTripleOrBuilder> kbpTripleBuilder_;

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public IList<CoreNLPProtos.RelationTriple> GetKbpTripleList()
				{
					if (kbpTripleBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(kbpTriple_);
					}
					else
					{
						return kbpTripleBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public int GetKbpTripleCount()
				{
					if (kbpTripleBuilder_ == null)
					{
						return kbpTriple_.Count;
					}
					else
					{
						return kbpTripleBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple GetKbpTriple(int index)
				{
					if (kbpTripleBuilder_ == null)
					{
						return kbpTriple_[index];
					}
					else
					{
						return kbpTripleBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetKbpTriple(int index, CoreNLPProtos.RelationTriple value)
				{
					if (kbpTripleBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureKbpTripleIsMutable();
						kbpTriple_.Set(index, value);
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetKbpTriple(int index, CoreNLPProtos.RelationTriple.Builder builderForValue)
				{
					if (kbpTripleBuilder_ == null)
					{
						EnsureKbpTripleIsMutable();
						kbpTriple_.Set(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.SetMessage(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddKbpTriple(CoreNLPProtos.RelationTriple value)
				{
					if (kbpTripleBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureKbpTripleIsMutable();
						kbpTriple_.Add(value);
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddKbpTriple(int index, CoreNLPProtos.RelationTriple value)
				{
					if (kbpTripleBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureKbpTripleIsMutable();
						kbpTriple_.Add(index, value);
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddKbpTriple(CoreNLPProtos.RelationTriple.Builder builderForValue)
				{
					if (kbpTripleBuilder_ == null)
					{
						EnsureKbpTripleIsMutable();
						kbpTriple_.Add(((CoreNLPProtos.RelationTriple)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.AddMessage(((CoreNLPProtos.RelationTriple)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddKbpTriple(int index, CoreNLPProtos.RelationTriple.Builder builderForValue)
				{
					if (kbpTripleBuilder_ == null)
					{
						EnsureKbpTripleIsMutable();
						kbpTriple_.Add(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.AddMessage(index, ((CoreNLPProtos.RelationTriple)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddAllKbpTriple<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.RelationTriple
				{
					if (kbpTripleBuilder_ == null)
					{
						EnsureKbpTripleIsMutable();
						AbstractMessageLite.Builder.AddAll(values, kbpTriple_);
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearKbpTriple()
				{
					if (kbpTripleBuilder_ == null)
					{
						kbpTriple_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder RemoveKbpTriple(int index)
				{
					if (kbpTripleBuilder_ == null)
					{
						EnsureKbpTripleIsMutable();
						kbpTriple_.Remove(index);
						OnChanged();
					}
					else
					{
						kbpTripleBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder GetKbpTripleBuilder(int index)
				{
					return GetKbpTripleFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.IRelationTripleOrBuilder GetKbpTripleOrBuilder(int index)
				{
					if (kbpTripleBuilder_ == null)
					{
						return kbpTriple_[index];
					}
					else
					{
						return kbpTripleBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public IList<CoreNLPProtos.IRelationTripleOrBuilder> GetKbpTripleOrBuilderList()
				{
					if (kbpTripleBuilder_ != null)
					{
						return kbpTripleBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(kbpTriple_);
					}
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddKbpTripleBuilder()
				{
					return GetKbpTripleFieldBuilder().AddBuilder(CoreNLPProtos.RelationTriple.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddKbpTripleBuilder(int index)
				{
					return GetKbpTripleFieldBuilder().AddBuilder(index, CoreNLPProtos.RelationTriple.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The KBP triples in this sentence
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;</code>
				/// </summary>
				public IList<CoreNLPProtos.RelationTriple.Builder> GetKbpTripleBuilderList()
				{
					return GetKbpTripleFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.RelationTriple, CoreNLPProtos.RelationTriple.Builder, CoreNLPProtos.IRelationTripleOrBuilder> GetKbpTripleFieldBuilder()
				{
					if (kbpTripleBuilder_ == null)
					{
						kbpTripleBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.RelationTriple, CoreNLPProtos.RelationTriple.Builder, CoreNLPProtos.IRelationTripleOrBuilder>(kbpTriple_, ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000
							))), GetParentForChildren(), IsClean());
						kbpTriple_ = null;
					}
					return kbpTripleBuilder_;
				}

				private IList<CoreNLPProtos.SentenceFragment> entailedSentence_ = Java.Util.Collections.EmptyList();

				private void EnsureEntailedSentenceIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						entailedSentence_ = new List<CoreNLPProtos.SentenceFragment>(entailedSentence_);
						bitField0_ |= unchecked((int)(0x00020000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.SentenceFragment, CoreNLPProtos.SentenceFragment.Builder, CoreNLPProtos.ISentenceFragmentOrBuilder> entailedSentenceBuilder_;

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public IList<CoreNLPProtos.SentenceFragment> GetEntailedSentenceList()
				{
					if (entailedSentenceBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(entailedSentence_);
					}
					else
					{
						return entailedSentenceBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public int GetEntailedSentenceCount()
				{
					if (entailedSentenceBuilder_ == null)
					{
						return entailedSentence_.Count;
					}
					else
					{
						return entailedSentenceBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment GetEntailedSentence(int index)
				{
					if (entailedSentenceBuilder_ == null)
					{
						return entailedSentence_[index];
					}
					else
					{
						return entailedSentenceBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetEntailedSentence(int index, CoreNLPProtos.SentenceFragment value)
				{
					if (entailedSentenceBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntailedSentenceIsMutable();
						entailedSentence_.Set(index, value);
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetEntailedSentence(int index, CoreNLPProtos.SentenceFragment.Builder builderForValue)
				{
					if (entailedSentenceBuilder_ == null)
					{
						EnsureEntailedSentenceIsMutable();
						entailedSentence_.Set(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.SetMessage(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedSentence(CoreNLPProtos.SentenceFragment value)
				{
					if (entailedSentenceBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntailedSentenceIsMutable();
						entailedSentence_.Add(value);
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedSentence(int index, CoreNLPProtos.SentenceFragment value)
				{
					if (entailedSentenceBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntailedSentenceIsMutable();
						entailedSentence_.Add(index, value);
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedSentence(CoreNLPProtos.SentenceFragment.Builder builderForValue)
				{
					if (entailedSentenceBuilder_ == null)
					{
						EnsureEntailedSentenceIsMutable();
						entailedSentence_.Add(((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.AddMessage(((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedSentence(int index, CoreNLPProtos.SentenceFragment.Builder builderForValue)
				{
					if (entailedSentenceBuilder_ == null)
					{
						EnsureEntailedSentenceIsMutable();
						entailedSentence_.Add(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.AddMessage(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddAllEntailedSentence<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.SentenceFragment
				{
					if (entailedSentenceBuilder_ == null)
					{
						EnsureEntailedSentenceIsMutable();
						AbstractMessageLite.Builder.AddAll(values, entailedSentence_);
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearEntailedSentence()
				{
					if (entailedSentenceBuilder_ == null)
					{
						entailedSentence_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder RemoveEntailedSentence(int index)
				{
					if (entailedSentenceBuilder_ == null)
					{
						EnsureEntailedSentenceIsMutable();
						entailedSentence_.Remove(index);
						OnChanged();
					}
					else
					{
						entailedSentenceBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment.Builder GetEntailedSentenceBuilder(int index)
				{
					return GetEntailedSentenceFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.ISentenceFragmentOrBuilder GetEntailedSentenceOrBuilder(int index)
				{
					if (entailedSentenceBuilder_ == null)
					{
						return entailedSentence_[index];
					}
					else
					{
						return entailedSentenceBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public IList<CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedSentenceOrBuilderList()
				{
					if (entailedSentenceBuilder_ != null)
					{
						return entailedSentenceBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(entailedSentence_);
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment.Builder AddEntailedSentenceBuilder()
				{
					return GetEntailedSentenceFieldBuilder().AddBuilder(CoreNLPProtos.SentenceFragment.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment.Builder AddEntailedSentenceBuilder(int index)
				{
					return GetEntailedSentenceFieldBuilder().AddBuilder(index, CoreNLPProtos.SentenceFragment.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The entailed sentences, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;</code>
				/// </summary>
				public IList<CoreNLPProtos.SentenceFragment.Builder> GetEntailedSentenceBuilderList()
				{
					return GetEntailedSentenceFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.SentenceFragment, CoreNLPProtos.SentenceFragment.Builder, CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedSentenceFieldBuilder()
				{
					if (entailedSentenceBuilder_ == null)
					{
						entailedSentenceBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.SentenceFragment, CoreNLPProtos.SentenceFragment.Builder, CoreNLPProtos.ISentenceFragmentOrBuilder>(entailedSentence_, ((bitField0_ & unchecked((int)(0x00020000))) == unchecked(
							(int)(0x00020000))), GetParentForChildren(), IsClean());
						entailedSentence_ = null;
					}
					return entailedSentenceBuilder_;
				}

				private IList<CoreNLPProtos.SentenceFragment> entailedClause_ = Java.Util.Collections.EmptyList();

				private void EnsureEntailedClauseIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						entailedClause_ = new List<CoreNLPProtos.SentenceFragment>(entailedClause_);
						bitField0_ |= unchecked((int)(0x00040000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.SentenceFragment, CoreNLPProtos.SentenceFragment.Builder, CoreNLPProtos.ISentenceFragmentOrBuilder> entailedClauseBuilder_;

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public IList<CoreNLPProtos.SentenceFragment> GetEntailedClauseList()
				{
					if (entailedClauseBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(entailedClause_);
					}
					else
					{
						return entailedClauseBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public int GetEntailedClauseCount()
				{
					if (entailedClauseBuilder_ == null)
					{
						return entailedClause_.Count;
					}
					else
					{
						return entailedClauseBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment GetEntailedClause(int index)
				{
					if (entailedClauseBuilder_ == null)
					{
						return entailedClause_[index];
					}
					else
					{
						return entailedClauseBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetEntailedClause(int index, CoreNLPProtos.SentenceFragment value)
				{
					if (entailedClauseBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntailedClauseIsMutable();
						entailedClause_.Set(index, value);
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetEntailedClause(int index, CoreNLPProtos.SentenceFragment.Builder builderForValue)
				{
					if (entailedClauseBuilder_ == null)
					{
						EnsureEntailedClauseIsMutable();
						entailedClause_.Set(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.SetMessage(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedClause(CoreNLPProtos.SentenceFragment value)
				{
					if (entailedClauseBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntailedClauseIsMutable();
						entailedClause_.Add(value);
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedClause(int index, CoreNLPProtos.SentenceFragment value)
				{
					if (entailedClauseBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntailedClauseIsMutable();
						entailedClause_.Add(index, value);
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedClause(CoreNLPProtos.SentenceFragment.Builder builderForValue)
				{
					if (entailedClauseBuilder_ == null)
					{
						EnsureEntailedClauseIsMutable();
						entailedClause_.Add(((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.AddMessage(((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddEntailedClause(int index, CoreNLPProtos.SentenceFragment.Builder builderForValue)
				{
					if (entailedClauseBuilder_ == null)
					{
						EnsureEntailedClauseIsMutable();
						entailedClause_.Add(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.AddMessage(index, ((CoreNLPProtos.SentenceFragment)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder AddAllEntailedClause<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.SentenceFragment
				{
					if (entailedClauseBuilder_ == null)
					{
						EnsureEntailedClauseIsMutable();
						AbstractMessageLite.Builder.AddAll(values, entailedClause_);
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearEntailedClause()
				{
					if (entailedClauseBuilder_ == null)
					{
						entailedClause_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder RemoveEntailedClause(int index)
				{
					if (entailedClauseBuilder_ == null)
					{
						EnsureEntailedClauseIsMutable();
						entailedClause_.Remove(index);
						OnChanged();
					}
					else
					{
						entailedClauseBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment.Builder GetEntailedClauseBuilder(int index)
				{
					return GetEntailedClauseFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.ISentenceFragmentOrBuilder GetEntailedClauseOrBuilder(int index)
				{
					if (entailedClauseBuilder_ == null)
					{
						return entailedClause_[index];
					}
					else
					{
						return entailedClauseBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public IList<CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedClauseOrBuilderList()
				{
					if (entailedClauseBuilder_ != null)
					{
						return entailedClauseBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(entailedClause_);
					}
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment.Builder AddEntailedClauseBuilder()
				{
					return GetEntailedClauseFieldBuilder().AddBuilder(CoreNLPProtos.SentenceFragment.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public CoreNLPProtos.SentenceFragment.Builder AddEntailedClauseBuilder(int index)
				{
					return GetEntailedClauseFieldBuilder().AddBuilder(index, CoreNLPProtos.SentenceFragment.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The entailed clauses, by natural logic
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedClause = 35;</code>
				/// </summary>
				public IList<CoreNLPProtos.SentenceFragment.Builder> GetEntailedClauseBuilderList()
				{
					return GetEntailedClauseFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.SentenceFragment, CoreNLPProtos.SentenceFragment.Builder, CoreNLPProtos.ISentenceFragmentOrBuilder> GetEntailedClauseFieldBuilder()
				{
					if (entailedClauseBuilder_ == null)
					{
						entailedClauseBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.SentenceFragment, CoreNLPProtos.SentenceFragment.Builder, CoreNLPProtos.ISentenceFragmentOrBuilder>(entailedClause_, ((bitField0_ & unchecked((int)(0x00040000))) == unchecked(
							(int)(0x00040000))), GetParentForChildren(), IsClean());
						entailedClause_ = null;
					}
					return entailedClauseBuilder_;
				}

				private CoreNLPProtos.DependencyGraph enhancedDependencies_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> enhancedDependenciesBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public bool HasEnhancedDependencies()
				{
					return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public CoreNLPProtos.DependencyGraph GetEnhancedDependencies()
				{
					if (enhancedDependenciesBuilder_ == null)
					{
						return enhancedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedDependencies_;
					}
					else
					{
						return enhancedDependenciesBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetEnhancedDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (enhancedDependenciesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						enhancedDependencies_ = value;
						OnChanged();
					}
					else
					{
						enhancedDependenciesBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00080000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetEnhancedDependencies(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (enhancedDependenciesBuilder_ == null)
					{
						enhancedDependencies_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						enhancedDependenciesBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00080000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeEnhancedDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (enhancedDependenciesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))) && enhancedDependencies_ != null && enhancedDependencies_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							enhancedDependencies_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(enhancedDependencies_).MergeFrom(value).BuildPartial());
						}
						else
						{
							enhancedDependencies_ = value;
						}
						OnChanged();
					}
					else
					{
						enhancedDependenciesBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00080000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearEnhancedDependencies()
				{
					if (enhancedDependenciesBuilder_ == null)
					{
						enhancedDependencies_ = null;
						OnChanged();
					}
					else
					{
						enhancedDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder GetEnhancedDependenciesBuilder()
				{
					bitField0_ |= unchecked((int)(0x00080000));
					OnChanged();
					return GetEnhancedDependenciesFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetEnhancedDependenciesOrBuilder()
				{
					if (enhancedDependenciesBuilder_ != null)
					{
						return enhancedDependenciesBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return enhancedDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedDependencies_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedDependencies = 17;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetEnhancedDependenciesFieldBuilder()
				{
					if (enhancedDependenciesBuilder_ == null)
					{
						enhancedDependenciesBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetEnhancedDependencies(), GetParentForChildren(), IsClean());
						enhancedDependencies_ = null;
					}
					return enhancedDependenciesBuilder_;
				}

				private CoreNLPProtos.DependencyGraph enhancedPlusPlusDependencies_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> enhancedPlusPlusDependenciesBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public bool HasEnhancedPlusPlusDependencies()
				{
					return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public CoreNLPProtos.DependencyGraph GetEnhancedPlusPlusDependencies()
				{
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						return enhancedPlusPlusDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedPlusPlusDependencies_;
					}
					else
					{
						return enhancedPlusPlusDependenciesBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetEnhancedPlusPlusDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						enhancedPlusPlusDependencies_ = value;
						OnChanged();
					}
					else
					{
						enhancedPlusPlusDependenciesBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetEnhancedPlusPlusDependencies(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						enhancedPlusPlusDependencies_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						enhancedPlusPlusDependenciesBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public CoreNLPProtos.Sentence.Builder MergeEnhancedPlusPlusDependencies(CoreNLPProtos.DependencyGraph value)
				{
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))) && enhancedPlusPlusDependencies_ != null && enhancedPlusPlusDependencies_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							enhancedPlusPlusDependencies_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(enhancedPlusPlusDependencies_).MergeFrom(value).BuildPartial());
						}
						else
						{
							enhancedPlusPlusDependencies_ = value;
						}
						OnChanged();
					}
					else
					{
						enhancedPlusPlusDependenciesBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearEnhancedPlusPlusDependencies()
				{
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						enhancedPlusPlusDependencies_ = null;
						OnChanged();
					}
					else
					{
						enhancedPlusPlusDependenciesBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder GetEnhancedPlusPlusDependenciesBuilder()
				{
					bitField0_ |= unchecked((int)(0x00100000));
					OnChanged();
					return GetEnhancedPlusPlusDependenciesFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetEnhancedPlusPlusDependenciesOrBuilder()
				{
					if (enhancedPlusPlusDependenciesBuilder_ != null)
					{
						return enhancedPlusPlusDependenciesBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return enhancedPlusPlusDependencies_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : enhancedPlusPlusDependencies_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph enhancedPlusPlusDependencies = 18;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetEnhancedPlusPlusDependenciesFieldBuilder()
				{
					if (enhancedPlusPlusDependenciesBuilder_ == null)
					{
						enhancedPlusPlusDependenciesBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetEnhancedPlusPlusDependencies(), GetParentForChildren(), IsClean
							());
						enhancedPlusPlusDependencies_ = null;
					}
					return enhancedPlusPlusDependenciesBuilder_;
				}

				private IList<CoreNLPProtos.Token> character_ = Java.Util.Collections.EmptyList();

				private void EnsureCharacterIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
					{
						character_ = new List<CoreNLPProtos.Token>(character_);
						bitField0_ |= unchecked((int)(0x00200000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> characterBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public IList<CoreNLPProtos.Token> GetCharacterList()
				{
					if (characterBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(character_);
					}
					else
					{
						return characterBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public int GetCharacterCount()
				{
					if (characterBuilder_ == null)
					{
						return character_.Count;
					}
					else
					{
						return characterBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Token GetCharacter(int index)
				{
					if (characterBuilder_ == null)
					{
						return character_[index];
					}
					else
					{
						return characterBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCharacter(int index, CoreNLPProtos.Token value)
				{
					if (characterBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCharacterIsMutable();
						character_.Set(index, value);
						OnChanged();
					}
					else
					{
						characterBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetCharacter(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Set(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						characterBuilder_.SetMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddCharacter(CoreNLPProtos.Token value)
				{
					if (characterBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCharacterIsMutable();
						character_.Add(value);
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddCharacter(int index, CoreNLPProtos.Token value)
				{
					if (characterBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureCharacterIsMutable();
						character_.Add(index, value);
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddCharacter(CoreNLPProtos.Token.Builder builderForValue)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Add(((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddCharacter(int index, CoreNLPProtos.Token.Builder builderForValue)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Add(index, ((CoreNLPProtos.Token)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						characterBuilder_.AddMessage(index, ((CoreNLPProtos.Token)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddAllCharacter<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Token
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						AbstractMessageLite.Builder.AddAll(values, character_);
						OnChanged();
					}
					else
					{
						characterBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearCharacter()
				{
					if (characterBuilder_ == null)
					{
						character_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
						OnChanged();
					}
					else
					{
						characterBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Sentence.Builder RemoveCharacter(int index)
				{
					if (characterBuilder_ == null)
					{
						EnsureCharacterIsMutable();
						character_.Remove(index);
						OnChanged();
					}
					else
					{
						characterBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Token.Builder GetCharacterBuilder(int index)
				{
					return GetCharacterFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.ITokenOrBuilder GetCharacterOrBuilder(int index)
				{
					if (characterBuilder_ == null)
					{
						return character_[index];
					}
					else
					{
						return characterBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public IList<CoreNLPProtos.ITokenOrBuilder> GetCharacterOrBuilderList()
				{
					if (characterBuilder_ != null)
					{
						return characterBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(character_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Token.Builder AddCharacterBuilder()
				{
					return GetCharacterFieldBuilder().AddBuilder(CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public CoreNLPProtos.Token.Builder AddCharacterBuilder(int index)
				{
					return GetCharacterFieldBuilder().AddBuilder(index, CoreNLPProtos.Token.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Token character = 19;</code></summary>
				public IList<CoreNLPProtos.Token.Builder> GetCharacterBuilderList()
				{
					return GetCharacterFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> GetCharacterFieldBuilder()
				{
					if (characterBuilder_ == null)
					{
						characterBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder>(character_, ((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))), GetParentForChildren()
							, IsClean());
						character_ = null;
					}
					return characterBuilder_;
				}

				private int paragraph_;

				/// <summary><code>optional uint32 paragraph = 11;</code></summary>
				public bool HasParagraph()
				{
					return ((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000)));
				}

				/// <summary><code>optional uint32 paragraph = 11;</code></summary>
				public int GetParagraph()
				{
					return paragraph_;
				}

				/// <summary><code>optional uint32 paragraph = 11;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetParagraph(int value)
				{
					bitField0_ |= unchecked((int)(0x00400000));
					paragraph_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 paragraph = 11;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearParagraph()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
					paragraph_ = 0;
					OnChanged();
					return this;
				}

				private object text_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </pre>
				/// <code>optional string text = 12;</code>
				/// </remarks>
				public bool HasText()
				{
					return ((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000)));
				}

				/// <summary>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </pre>
				/// <code>optional string text = 12;</code>
				/// </remarks>
				public string GetText()
				{
					object @ref = text_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							text_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </pre>
				/// <code>optional string text = 12;</code>
				/// </remarks>
				public ByteString GetTextBytes()
				{
					object @ref = text_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						text_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </pre>
				/// <code>optional string text = 12;</code>
				/// </remarks>
				public CoreNLPProtos.Sentence.Builder SetText(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00800000));
					text_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </pre>
				/// <code>optional string text = 12;</code>
				/// </remarks>
				public CoreNLPProtos.Sentence.Builder ClearText()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00800000)));
					text_ = GetDefaultInstance().GetText();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Only needed if we're only saving the sentence.
				/// </pre>
				/// <code>optional string text = 12;</code>
				/// </remarks>
				public CoreNLPProtos.Sentence.Builder SetTextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00800000));
					text_ = value;
					OnChanged();
					return this;
				}

				private int lineNumber_;

				/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
				public bool HasLineNumber()
				{
					return ((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000)));
				}

				/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
				public int GetLineNumber()
				{
					return lineNumber_;
				}

				/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetLineNumber(int value)
				{
					bitField0_ |= unchecked((int)(0x01000000));
					lineNumber_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 lineNumber = 20;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearLineNumber()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x01000000)));
					lineNumber_ = 0;
					OnChanged();
					return this;
				}

				private bool hasRelationAnnotations_;

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional bool hasRelationAnnotations = 51;</code>
				/// </summary>
				public bool HasHasRelationAnnotations()
				{
					return ((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000)));
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional bool hasRelationAnnotations = 51;</code>
				/// </summary>
				public bool GetHasRelationAnnotations()
				{
					return hasRelationAnnotations_;
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional bool hasRelationAnnotations = 51;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetHasRelationAnnotations(bool value)
				{
					bitField0_ |= unchecked((int)(0x02000000));
					hasRelationAnnotations_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional bool hasRelationAnnotations = 51;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearHasRelationAnnotations()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x02000000)));
					hasRelationAnnotations_ = false;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.Entity> entity_ = Java.Util.Collections.EmptyList();

				private void EnsureEntityIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
					{
						entity_ = new List<CoreNLPProtos.Entity>(entity_);
						bitField0_ |= unchecked((int)(0x04000000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Entity, CoreNLPProtos.Entity.Builder, CoreNLPProtos.IEntityOrBuilder> entityBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public IList<CoreNLPProtos.Entity> GetEntityList()
				{
					if (entityBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(entity_);
					}
					else
					{
						return entityBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public int GetEntityCount()
				{
					if (entityBuilder_ == null)
					{
						return entity_.Count;
					}
					else
					{
						return entityBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Entity GetEntity(int index)
				{
					if (entityBuilder_ == null)
					{
						return entity_[index];
					}
					else
					{
						return entityBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetEntity(int index, CoreNLPProtos.Entity value)
				{
					if (entityBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntityIsMutable();
						entity_.Set(index, value);
						OnChanged();
					}
					else
					{
						entityBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetEntity(int index, CoreNLPProtos.Entity.Builder builderForValue)
				{
					if (entityBuilder_ == null)
					{
						EnsureEntityIsMutable();
						entity_.Set(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entityBuilder_.SetMessage(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddEntity(CoreNLPProtos.Entity value)
				{
					if (entityBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntityIsMutable();
						entity_.Add(value);
						OnChanged();
					}
					else
					{
						entityBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddEntity(int index, CoreNLPProtos.Entity value)
				{
					if (entityBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEntityIsMutable();
						entity_.Add(index, value);
						OnChanged();
					}
					else
					{
						entityBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddEntity(CoreNLPProtos.Entity.Builder builderForValue)
				{
					if (entityBuilder_ == null)
					{
						EnsureEntityIsMutable();
						entity_.Add(((CoreNLPProtos.Entity)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entityBuilder_.AddMessage(((CoreNLPProtos.Entity)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddEntity(int index, CoreNLPProtos.Entity.Builder builderForValue)
				{
					if (entityBuilder_ == null)
					{
						EnsureEntityIsMutable();
						entity_.Add(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						entityBuilder_.AddMessage(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddAllEntity<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Entity
				{
					if (entityBuilder_ == null)
					{
						EnsureEntityIsMutable();
						AbstractMessageLite.Builder.AddAll(values, entity_);
						OnChanged();
					}
					else
					{
						entityBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearEntity()
				{
					if (entityBuilder_ == null)
					{
						entity_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
						OnChanged();
					}
					else
					{
						entityBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Sentence.Builder RemoveEntity(int index)
				{
					if (entityBuilder_ == null)
					{
						EnsureEntityIsMutable();
						entity_.Remove(index);
						OnChanged();
					}
					else
					{
						entityBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Entity.Builder GetEntityBuilder(int index)
				{
					return GetEntityFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.IEntityOrBuilder GetEntityOrBuilder(int index)
				{
					if (entityBuilder_ == null)
					{
						return entity_[index];
					}
					else
					{
						return entityBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public IList<CoreNLPProtos.IEntityOrBuilder> GetEntityOrBuilderList()
				{
					if (entityBuilder_ != null)
					{
						return entityBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(entity_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Entity.Builder AddEntityBuilder()
				{
					return GetEntityFieldBuilder().AddBuilder(CoreNLPProtos.Entity.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public CoreNLPProtos.Entity.Builder AddEntityBuilder(int index)
				{
					return GetEntityFieldBuilder().AddBuilder(index, CoreNLPProtos.Entity.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity entity = 52;</code></summary>
				public IList<CoreNLPProtos.Entity.Builder> GetEntityBuilderList()
				{
					return GetEntityFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Entity, CoreNLPProtos.Entity.Builder, CoreNLPProtos.IEntityOrBuilder> GetEntityFieldBuilder()
				{
					if (entityBuilder_ == null)
					{
						entityBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Entity, CoreNLPProtos.Entity.Builder, CoreNLPProtos.IEntityOrBuilder>(entity_, ((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))), GetParentForChildren(), IsClean
							());
						entity_ = null;
					}
					return entityBuilder_;
				}

				private IList<CoreNLPProtos.Relation> relation_ = Java.Util.Collections.EmptyList();

				private void EnsureRelationIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
					{
						relation_ = new List<CoreNLPProtos.Relation>(relation_);
						bitField0_ |= unchecked((int)(0x08000000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Relation, CoreNLPProtos.Relation.Builder, CoreNLPProtos.IRelationOrBuilder> relationBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public IList<CoreNLPProtos.Relation> GetRelationList()
				{
					if (relationBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(relation_);
					}
					else
					{
						return relationBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public int GetRelationCount()
				{
					if (relationBuilder_ == null)
					{
						return relation_.Count;
					}
					else
					{
						return relationBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Relation GetRelation(int index)
				{
					if (relationBuilder_ == null)
					{
						return relation_[index];
					}
					else
					{
						return relationBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetRelation(int index, CoreNLPProtos.Relation value)
				{
					if (relationBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureRelationIsMutable();
						relation_.Set(index, value);
						OnChanged();
					}
					else
					{
						relationBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetRelation(int index, CoreNLPProtos.Relation.Builder builderForValue)
				{
					if (relationBuilder_ == null)
					{
						EnsureRelationIsMutable();
						relation_.Set(index, ((CoreNLPProtos.Relation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						relationBuilder_.SetMessage(index, ((CoreNLPProtos.Relation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddRelation(CoreNLPProtos.Relation value)
				{
					if (relationBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureRelationIsMutable();
						relation_.Add(value);
						OnChanged();
					}
					else
					{
						relationBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddRelation(int index, CoreNLPProtos.Relation value)
				{
					if (relationBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureRelationIsMutable();
						relation_.Add(index, value);
						OnChanged();
					}
					else
					{
						relationBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddRelation(CoreNLPProtos.Relation.Builder builderForValue)
				{
					if (relationBuilder_ == null)
					{
						EnsureRelationIsMutable();
						relation_.Add(((CoreNLPProtos.Relation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						relationBuilder_.AddMessage(((CoreNLPProtos.Relation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddRelation(int index, CoreNLPProtos.Relation.Builder builderForValue)
				{
					if (relationBuilder_ == null)
					{
						EnsureRelationIsMutable();
						relation_.Add(index, ((CoreNLPProtos.Relation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						relationBuilder_.AddMessage(index, ((CoreNLPProtos.Relation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddAllRelation<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Relation
				{
					if (relationBuilder_ == null)
					{
						EnsureRelationIsMutable();
						AbstractMessageLite.Builder.AddAll(values, relation_);
						OnChanged();
					}
					else
					{
						relationBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearRelation()
				{
					if (relationBuilder_ == null)
					{
						relation_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
						OnChanged();
					}
					else
					{
						relationBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Sentence.Builder RemoveRelation(int index)
				{
					if (relationBuilder_ == null)
					{
						EnsureRelationIsMutable();
						relation_.Remove(index);
						OnChanged();
					}
					else
					{
						relationBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Relation.Builder GetRelationBuilder(int index)
				{
					return GetRelationFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.IRelationOrBuilder GetRelationOrBuilder(int index)
				{
					if (relationBuilder_ == null)
					{
						return relation_[index];
					}
					else
					{
						return relationBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public IList<CoreNLPProtos.IRelationOrBuilder> GetRelationOrBuilderList()
				{
					if (relationBuilder_ != null)
					{
						return relationBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(relation_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Relation.Builder AddRelationBuilder()
				{
					return GetRelationFieldBuilder().AddBuilder(CoreNLPProtos.Relation.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public CoreNLPProtos.Relation.Builder AddRelationBuilder(int index)
				{
					return GetRelationFieldBuilder().AddBuilder(index, CoreNLPProtos.Relation.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Relation relation = 53;</code></summary>
				public IList<CoreNLPProtos.Relation.Builder> GetRelationBuilderList()
				{
					return GetRelationFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Relation, CoreNLPProtos.Relation.Builder, CoreNLPProtos.IRelationOrBuilder> GetRelationFieldBuilder()
				{
					if (relationBuilder_ == null)
					{
						relationBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Relation, CoreNLPProtos.Relation.Builder, CoreNLPProtos.IRelationOrBuilder>(relation_, ((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))), GetParentForChildren
							(), IsClean());
						relation_ = null;
					}
					return relationBuilder_;
				}

				private bool hasNumerizedTokensAnnotation_;

				/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
				public bool HasHasNumerizedTokensAnnotation()
				{
					return ((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000)));
				}

				/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
				public bool GetHasNumerizedTokensAnnotation()
				{
					return hasNumerizedTokensAnnotation_;
				}

				/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetHasNumerizedTokensAnnotation(bool value)
				{
					bitField0_ |= unchecked((int)(0x10000000));
					hasNumerizedTokensAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasNumerizedTokensAnnotation = 54;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearHasNumerizedTokensAnnotation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x10000000)));
					hasNumerizedTokensAnnotation_ = false;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.NERMention> mentions_ = Java.Util.Collections.EmptyList();

				private void EnsureMentionsIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
					{
						mentions_ = new List<CoreNLPProtos.NERMention>(mentions_);
						bitField0_ |= unchecked((int)(0x20000000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.NERMention, CoreNLPProtos.NERMention.Builder, CoreNLPProtos.INERMentionOrBuilder> mentionsBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public IList<CoreNLPProtos.NERMention> GetMentionsList()
				{
					if (mentionsBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(mentions_);
					}
					else
					{
						return mentionsBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public int GetMentionsCount()
				{
					if (mentionsBuilder_ == null)
					{
						return mentions_.Count;
					}
					else
					{
						return mentionsBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.NERMention GetMentions(int index)
				{
					if (mentionsBuilder_ == null)
					{
						return mentions_[index];
					}
					else
					{
						return mentionsBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetMentions(int index, CoreNLPProtos.NERMention value)
				{
					if (mentionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsIsMutable();
						mentions_.Set(index, value);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetMentions(int index, CoreNLPProtos.NERMention.Builder builderForValue)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Set(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.SetMessage(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentions(CoreNLPProtos.NERMention value)
				{
					if (mentionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsIsMutable();
						mentions_.Add(value);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentions(int index, CoreNLPProtos.NERMention value)
				{
					if (mentionsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsIsMutable();
						mentions_.Add(index, value);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentions(CoreNLPProtos.NERMention.Builder builderForValue)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Add(((CoreNLPProtos.NERMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(((CoreNLPProtos.NERMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentions(int index, CoreNLPProtos.NERMention.Builder builderForValue)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Add(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddMessage(index, ((CoreNLPProtos.NERMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddAllMentions<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.NERMention
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						AbstractMessageLite.Builder.AddAll(values, mentions_);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearMentions()
				{
					if (mentionsBuilder_ == null)
					{
						mentions_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
						OnChanged();
					}
					else
					{
						mentionsBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.Sentence.Builder RemoveMentions(int index)
				{
					if (mentionsBuilder_ == null)
					{
						EnsureMentionsIsMutable();
						mentions_.Remove(index);
						OnChanged();
					}
					else
					{
						mentionsBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.NERMention.Builder GetMentionsBuilder(int index)
				{
					return GetMentionsFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.INERMentionOrBuilder GetMentionsOrBuilder(int index)
				{
					if (mentionsBuilder_ == null)
					{
						return mentions_[index];
					}
					else
					{
						return mentionsBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public IList<CoreNLPProtos.INERMentionOrBuilder> GetMentionsOrBuilderList()
				{
					if (mentionsBuilder_ != null)
					{
						return mentionsBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(mentions_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.NERMention.Builder AddMentionsBuilder()
				{
					return GetMentionsFieldBuilder().AddBuilder(CoreNLPProtos.NERMention.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public CoreNLPProtos.NERMention.Builder AddMentionsBuilder(int index)
				{
					return GetMentionsFieldBuilder().AddBuilder(index, CoreNLPProtos.NERMention.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;</code></summary>
				public IList<CoreNLPProtos.NERMention.Builder> GetMentionsBuilderList()
				{
					return GetMentionsFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.NERMention, CoreNLPProtos.NERMention.Builder, CoreNLPProtos.INERMentionOrBuilder> GetMentionsFieldBuilder()
				{
					if (mentionsBuilder_ == null)
					{
						mentionsBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.NERMention, CoreNLPProtos.NERMention.Builder, CoreNLPProtos.INERMentionOrBuilder>(mentions_, ((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))), GetParentForChildren
							(), IsClean());
						mentions_ = null;
					}
					return mentionsBuilder_;
				}

				private IList<CoreNLPProtos.Mention> mentionsForCoref_ = Java.Util.Collections.EmptyList();

				private void EnsureMentionsForCorefIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
					{
						mentionsForCoref_ = new List<CoreNLPProtos.Mention>(mentionsForCoref_);
						bitField0_ |= unchecked((int)(0x40000000));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Mention, CoreNLPProtos.Mention.Builder, CoreNLPProtos.IMentionOrBuilder> mentionsForCorefBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public IList<CoreNLPProtos.Mention> GetMentionsForCorefList()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
					}
					else
					{
						return mentionsForCorefBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public int GetMentionsForCorefCount()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return mentionsForCoref_.Count;
					}
					else
					{
						return mentionsForCorefBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Mention GetMentionsForCoref(int index)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return mentionsForCoref_[index];
					}
					else
					{
						return mentionsForCorefBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetMentionsForCoref(int index, CoreNLPProtos.Mention value)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Set(index, value);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetMentionsForCoref(int index, CoreNLPProtos.Mention.Builder builderForValue)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Set(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.SetMessage(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentionsForCoref(CoreNLPProtos.Mention value)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(value);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentionsForCoref(int index, CoreNLPProtos.Mention value)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(index, value);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentionsForCoref(CoreNLPProtos.Mention.Builder builderForValue)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(((CoreNLPProtos.Mention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(((CoreNLPProtos.Mention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddMentionsForCoref(int index, CoreNLPProtos.Mention.Builder builderForValue)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Add(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddMessage(index, ((CoreNLPProtos.Mention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder AddAllMentionsForCoref<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Mention
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						AbstractMessageLite.Builder.AddAll(values, mentionsForCoref_);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearMentionsForCoref()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						mentionsForCoref_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Sentence.Builder RemoveMentionsForCoref(int index)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						EnsureMentionsForCorefIsMutable();
						mentionsForCoref_.Remove(index);
						OnChanged();
					}
					else
					{
						mentionsForCorefBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Mention.Builder GetMentionsForCorefBuilder(int index)
				{
					return GetMentionsForCorefFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.IMentionOrBuilder GetMentionsForCorefOrBuilder(int index)
				{
					if (mentionsForCorefBuilder_ == null)
					{
						return mentionsForCoref_[index];
					}
					else
					{
						return mentionsForCorefBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public IList<CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefOrBuilderList()
				{
					if (mentionsForCorefBuilder_ != null)
					{
						return mentionsForCorefBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(mentionsForCoref_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Mention.Builder AddMentionsForCorefBuilder()
				{
					return GetMentionsForCorefFieldBuilder().AddBuilder(CoreNLPProtos.Mention.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public CoreNLPProtos.Mention.Builder AddMentionsForCorefBuilder(int index)
				{
					return GetMentionsForCorefFieldBuilder().AddBuilder(index, CoreNLPProtos.Mention.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;</code></summary>
				public IList<CoreNLPProtos.Mention.Builder> GetMentionsForCorefBuilderList()
				{
					return GetMentionsForCorefFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Mention, CoreNLPProtos.Mention.Builder, CoreNLPProtos.IMentionOrBuilder> GetMentionsForCorefFieldBuilder()
				{
					if (mentionsForCorefBuilder_ == null)
					{
						mentionsForCorefBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Mention, CoreNLPProtos.Mention.Builder, CoreNLPProtos.IMentionOrBuilder>(mentionsForCoref_, ((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))), GetParentForChildren
							(), IsClean());
						mentionsForCoref_ = null;
					}
					return mentionsForCorefBuilder_;
				}

				private bool hasCorefMentionsAnnotation_;

				/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
				public bool HasHasCorefMentionsAnnotation()
				{
					return ((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000)));
				}

				/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
				public bool GetHasCorefMentionsAnnotation()
				{
					return hasCorefMentionsAnnotation_;
				}

				/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetHasCorefMentionsAnnotation(bool value)
				{
					bitField0_ |= unchecked((int)(0x80000000));
					hasCorefMentionsAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasCorefMentionsAnnotation = 57;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearHasCorefMentionsAnnotation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x80000000)));
					hasCorefMentionsAnnotation_ = false;
					OnChanged();
					return this;
				}

				private object sentenceID_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Useful when storing sentences (e.g.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Useful when storing sentences (e.g. ForEach)
				/// </pre>
				/// <code>optional string sentenceID = 58;</code>
				/// </remarks>
				public bool HasSentenceID()
				{
					return ((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary>
				/// <pre>
				/// Useful when storing sentences (e.g.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Useful when storing sentences (e.g. ForEach)
				/// </pre>
				/// <code>optional string sentenceID = 58;</code>
				/// </remarks>
				public string GetSentenceID()
				{
					object @ref = sentenceID_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sentenceID_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Useful when storing sentences (e.g.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Useful when storing sentences (e.g. ForEach)
				/// </pre>
				/// <code>optional string sentenceID = 58;</code>
				/// </remarks>
				public ByteString GetSentenceIDBytes()
				{
					object @ref = sentenceID_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sentenceID_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Useful when storing sentences (e.g.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Useful when storing sentences (e.g. ForEach)
				/// </pre>
				/// <code>optional string sentenceID = 58;</code>
				/// </remarks>
				public CoreNLPProtos.Sentence.Builder SetSentenceID(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000001));
					sentenceID_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Useful when storing sentences (e.g.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Useful when storing sentences (e.g. ForEach)
				/// </pre>
				/// <code>optional string sentenceID = 58;</code>
				/// </remarks>
				public CoreNLPProtos.Sentence.Builder ClearSentenceID()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
					sentenceID_ = GetDefaultInstance().GetSentenceID();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Useful when storing sentences (e.g.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// Useful when storing sentences (e.g. ForEach)
				/// </pre>
				/// <code>optional string sentenceID = 58;</code>
				/// </remarks>
				public CoreNLPProtos.Sentence.Builder SetSentenceIDBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000001));
					sentenceID_ = value;
					OnChanged();
					return this;
				}

				private object sectionDate_ = string.Empty;

				/// <summary>
				/// <pre>
				/// date of section
				/// </pre>
				/// <code>optional string sectionDate = 59;</code>
				/// </summary>
				public bool HasSectionDate()
				{
					return ((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary>
				/// <pre>
				/// date of section
				/// </pre>
				/// <code>optional string sectionDate = 59;</code>
				/// </summary>
				public string GetSectionDate()
				{
					object @ref = sectionDate_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sectionDate_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// date of section
				/// </pre>
				/// <code>optional string sectionDate = 59;</code>
				/// </summary>
				public ByteString GetSectionDateBytes()
				{
					object @ref = sectionDate_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sectionDate_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// date of section
				/// </pre>
				/// <code>optional string sectionDate = 59;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionDate(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000002));
					sectionDate_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// date of section
				/// </pre>
				/// <code>optional string sectionDate = 59;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearSectionDate()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
					sectionDate_ = GetDefaultInstance().GetSectionDate();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// date of section
				/// </pre>
				/// <code>optional string sectionDate = 59;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionDateBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000002));
					sectionDate_ = value;
					OnChanged();
					return this;
				}

				private int sectionIndex_;

				/// <summary>
				/// <pre>
				/// section index for this sentence's section
				/// </pre>
				/// <code>optional uint32 sectionIndex = 60;</code>
				/// </summary>
				public bool HasSectionIndex()
				{
					return ((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary>
				/// <pre>
				/// section index for this sentence's section
				/// </pre>
				/// <code>optional uint32 sectionIndex = 60;</code>
				/// </summary>
				public int GetSectionIndex()
				{
					return sectionIndex_;
				}

				/// <summary>
				/// <pre>
				/// section index for this sentence's section
				/// </pre>
				/// <code>optional uint32 sectionIndex = 60;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionIndex(int value)
				{
					bitField1_ |= unchecked((int)(0x00000004));
					sectionIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// section index for this sentence's section
				/// </pre>
				/// <code>optional uint32 sectionIndex = 60;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearSectionIndex()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
					sectionIndex_ = 0;
					OnChanged();
					return this;
				}

				private object sectionName_ = string.Empty;

				/// <summary>
				/// <pre>
				/// name of section
				/// </pre>
				/// <code>optional string sectionName = 61;</code>
				/// </summary>
				public bool HasSectionName()
				{
					return ((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary>
				/// <pre>
				/// name of section
				/// </pre>
				/// <code>optional string sectionName = 61;</code>
				/// </summary>
				public string GetSectionName()
				{
					object @ref = sectionName_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sectionName_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// name of section
				/// </pre>
				/// <code>optional string sectionName = 61;</code>
				/// </summary>
				public ByteString GetSectionNameBytes()
				{
					object @ref = sectionName_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sectionName_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// name of section
				/// </pre>
				/// <code>optional string sectionName = 61;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionName(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000008));
					sectionName_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// name of section
				/// </pre>
				/// <code>optional string sectionName = 61;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearSectionName()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
					sectionName_ = GetDefaultInstance().GetSectionName();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// name of section
				/// </pre>
				/// <code>optional string sectionName = 61;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionNameBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000008));
					sectionName_ = value;
					OnChanged();
					return this;
				}

				private object sectionAuthor_ = string.Empty;

				/// <summary>
				/// <pre>
				/// author of section
				/// </pre>
				/// <code>optional string sectionAuthor = 62;</code>
				/// </summary>
				public bool HasSectionAuthor()
				{
					return ((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary>
				/// <pre>
				/// author of section
				/// </pre>
				/// <code>optional string sectionAuthor = 62;</code>
				/// </summary>
				public string GetSectionAuthor()
				{
					object @ref = sectionAuthor_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sectionAuthor_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// author of section
				/// </pre>
				/// <code>optional string sectionAuthor = 62;</code>
				/// </summary>
				public ByteString GetSectionAuthorBytes()
				{
					object @ref = sectionAuthor_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sectionAuthor_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// author of section
				/// </pre>
				/// <code>optional string sectionAuthor = 62;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionAuthor(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000010));
					sectionAuthor_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// author of section
				/// </pre>
				/// <code>optional string sectionAuthor = 62;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearSectionAuthor()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
					sectionAuthor_ = GetDefaultInstance().GetSectionAuthor();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// author of section
				/// </pre>
				/// <code>optional string sectionAuthor = 62;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionAuthorBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000010));
					sectionAuthor_ = value;
					OnChanged();
					return this;
				}

				private object docID_ = string.Empty;

				/// <summary>
				/// <pre>
				/// doc id
				/// </pre>
				/// <code>optional string docID = 63;</code>
				/// </summary>
				public bool HasDocID()
				{
					return ((bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary>
				/// <pre>
				/// doc id
				/// </pre>
				/// <code>optional string docID = 63;</code>
				/// </summary>
				public string GetDocID()
				{
					object @ref = docID_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							docID_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// doc id
				/// </pre>
				/// <code>optional string docID = 63;</code>
				/// </summary>
				public ByteString GetDocIDBytes()
				{
					object @ref = docID_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						docID_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// doc id
				/// </pre>
				/// <code>optional string docID = 63;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetDocID(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000020));
					docID_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// doc id
				/// </pre>
				/// <code>optional string docID = 63;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearDocID()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
					docID_ = GetDefaultInstance().GetDocID();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// doc id
				/// </pre>
				/// <code>optional string docID = 63;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetDocIDBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000020));
					docID_ = value;
					OnChanged();
					return this;
				}

				private bool sectionQuoted_;

				/// <summary>
				/// <pre>
				/// is this sentence in an xml quote in a post
				/// </pre>
				/// <code>optional bool sectionQuoted = 64;</code>
				/// </summary>
				public bool HasSectionQuoted()
				{
					return ((bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary>
				/// <pre>
				/// is this sentence in an xml quote in a post
				/// </pre>
				/// <code>optional bool sectionQuoted = 64;</code>
				/// </summary>
				public bool GetSectionQuoted()
				{
					return sectionQuoted_;
				}

				/// <summary>
				/// <pre>
				/// is this sentence in an xml quote in a post
				/// </pre>
				/// <code>optional bool sectionQuoted = 64;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetSectionQuoted(bool value)
				{
					bitField1_ |= unchecked((int)(0x00000040));
					sectionQuoted_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// is this sentence in an xml quote in a post
				/// </pre>
				/// <code>optional bool sectionQuoted = 64;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearSectionQuoted()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
					sectionQuoted_ = false;
					OnChanged();
					return this;
				}

				private bool hasEntityMentionsAnnotation_;

				/// <summary>
				/// <pre>
				/// check if there are entity mentions
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
				/// </summary>
				public bool HasHasEntityMentionsAnnotation()
				{
					return ((bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary>
				/// <pre>
				/// check if there are entity mentions
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
				/// </summary>
				public bool GetHasEntityMentionsAnnotation()
				{
					return hasEntityMentionsAnnotation_;
				}

				/// <summary>
				/// <pre>
				/// check if there are entity mentions
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetHasEntityMentionsAnnotation(bool value)
				{
					bitField1_ |= unchecked((int)(0x00000080));
					hasEntityMentionsAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// check if there are entity mentions
				/// </pre>
				/// <code>optional bool hasEntityMentionsAnnotation = 65;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearHasEntityMentionsAnnotation()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
					hasEntityMentionsAnnotation_ = false;
					OnChanged();
					return this;
				}

				private bool hasKBPTriplesAnnotation_;

				/// <summary>
				/// <pre>
				/// check if there are KBP triples
				/// </pre>
				/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
				/// </summary>
				public bool HasHasKBPTriplesAnnotation()
				{
					return ((bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary>
				/// <pre>
				/// check if there are KBP triples
				/// </pre>
				/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
				/// </summary>
				public bool GetHasKBPTriplesAnnotation()
				{
					return hasKBPTriplesAnnotation_;
				}

				/// <summary>
				/// <pre>
				/// check if there are KBP triples
				/// </pre>
				/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetHasKBPTriplesAnnotation(bool value)
				{
					bitField1_ |= unchecked((int)(0x00000100));
					hasKBPTriplesAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// check if there are KBP triples
				/// </pre>
				/// <code>optional bool hasKBPTriplesAnnotation = 68;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearHasKBPTriplesAnnotation()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
					hasKBPTriplesAnnotation_ = false;
					OnChanged();
					return this;
				}

				private bool hasOpenieTriplesAnnotation_;

				/// <summary>
				/// <pre>
				/// check if there are OpenIE triples
				/// </pre>
				/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
				/// </summary>
				public bool HasHasOpenieTriplesAnnotation()
				{
					return ((bitField1_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary>
				/// <pre>
				/// check if there are OpenIE triples
				/// </pre>
				/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
				/// </summary>
				public bool GetHasOpenieTriplesAnnotation()
				{
					return hasOpenieTriplesAnnotation_;
				}

				/// <summary>
				/// <pre>
				/// check if there are OpenIE triples
				/// </pre>
				/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetHasOpenieTriplesAnnotation(bool value)
				{
					bitField1_ |= unchecked((int)(0x00000200));
					hasOpenieTriplesAnnotation_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// check if there are OpenIE triples
				/// </pre>
				/// <code>optional bool hasOpenieTriplesAnnotation = 69;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearHasOpenieTriplesAnnotation()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000200)));
					hasOpenieTriplesAnnotation_ = false;
					OnChanged();
					return this;
				}

				private int chapterIndex_;

				/// <summary>
				/// <pre>
				/// quote stuff
				/// </pre>
				/// <code>optional uint32 chapterIndex = 66;</code>
				/// </summary>
				public bool HasChapterIndex()
				{
					return ((bitField1_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary>
				/// <pre>
				/// quote stuff
				/// </pre>
				/// <code>optional uint32 chapterIndex = 66;</code>
				/// </summary>
				public int GetChapterIndex()
				{
					return chapterIndex_;
				}

				/// <summary>
				/// <pre>
				/// quote stuff
				/// </pre>
				/// <code>optional uint32 chapterIndex = 66;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder SetChapterIndex(int value)
				{
					bitField1_ |= unchecked((int)(0x00000400));
					chapterIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// quote stuff
				/// </pre>
				/// <code>optional uint32 chapterIndex = 66;</code>
				/// </summary>
				public CoreNLPProtos.Sentence.Builder ClearChapterIndex()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000400)));
					chapterIndex_ = 0;
					OnChanged();
					return this;
				}

				private int paragraphIndex_;

				/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
				public bool HasParagraphIndex()
				{
					return ((bitField1_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
				public int GetParagraphIndex()
				{
					return paragraphIndex_;
				}

				/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
				public CoreNLPProtos.Sentence.Builder SetParagraphIndex(int value)
				{
					bitField1_ |= unchecked((int)(0x00000800));
					paragraphIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 paragraphIndex = 67;</code></summary>
				public CoreNLPProtos.Sentence.Builder ClearParagraphIndex()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000800)));
					paragraphIndex_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Sentence.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Sentence)
			}

			private static readonly CoreNLPProtos.Sentence DefaultInstance;

			static Sentence()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Sentence)
				DefaultInstance = new CoreNLPProtos.Sentence();
			}

			public static CoreNLPProtos.Sentence GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_15625 : AbstractParser<CoreNLPProtos.Sentence>
			{
				public _AbstractParser_15625()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Sentence ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Sentence(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Sentence> Parser = new _AbstractParser_15625();

			public static IParser<CoreNLPProtos.Sentence> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ITokenOrBuilder : GeneratedMessageV3.IExtendableMessageOrBuilder<CoreNLPProtos.Token>
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Token)
			/// <summary>
			/// <pre>
			/// Fields set by the default annotators [new CoreNLP(new Properties())]
			/// </pre>
			/// <code>optional string word = 1;</code>
			/// </summary>
			bool HasWord();

			/// <summary>
			/// <pre>
			/// Fields set by the default annotators [new CoreNLP(new Properties())]
			/// </pre>
			/// <code>optional string word = 1;</code>
			/// </summary>
			string GetWord();

			/// <summary>
			/// <pre>
			/// Fields set by the default annotators [new CoreNLP(new Properties())]
			/// </pre>
			/// <code>optional string word = 1;</code>
			/// </summary>
			ByteString GetWordBytes();

			/// <summary>
			/// <pre>
			/// The word's part of speech tag
			/// </pre>
			/// <code>optional string pos = 2;</code>
			/// </summary>
			bool HasPos();

			/// <summary>
			/// <pre>
			/// The word's part of speech tag
			/// </pre>
			/// <code>optional string pos = 2;</code>
			/// </summary>
			string GetPos();

			/// <summary>
			/// <pre>
			/// The word's part of speech tag
			/// </pre>
			/// <code>optional string pos = 2;</code>
			/// </summary>
			ByteString GetPosBytes();

			/// <summary>
			/// <pre>
			/// The word's 'value', (e.g., parse tree node)
			/// </pre>
			/// <code>optional string value = 3;</code>
			/// </summary>
			bool HasValue();

			/// <summary>
			/// <pre>
			/// The word's 'value', (e.g., parse tree node)
			/// </pre>
			/// <code>optional string value = 3;</code>
			/// </summary>
			string GetValue();

			/// <summary>
			/// <pre>
			/// The word's 'value', (e.g., parse tree node)
			/// </pre>
			/// <code>optional string value = 3;</code>
			/// </summary>
			ByteString GetValueBytes();

			/// <summary>
			/// <pre>
			/// The word's 'category' (e.g., parse tree node)
			/// </pre>
			/// <code>optional string category = 4;</code>
			/// </summary>
			bool HasCategory();

			/// <summary>
			/// <pre>
			/// The word's 'category' (e.g., parse tree node)
			/// </pre>
			/// <code>optional string category = 4;</code>
			/// </summary>
			string GetCategory();

			/// <summary>
			/// <pre>
			/// The word's 'category' (e.g., parse tree node)
			/// </pre>
			/// <code>optional string category = 4;</code>
			/// </summary>
			ByteString GetCategoryBytes();

			/// <summary>
			/// <pre>
			/// The whitespace/xml before the token
			/// </pre>
			/// <code>optional string before = 5;</code>
			/// </summary>
			bool HasBefore();

			/// <summary>
			/// <pre>
			/// The whitespace/xml before the token
			/// </pre>
			/// <code>optional string before = 5;</code>
			/// </summary>
			string GetBefore();

			/// <summary>
			/// <pre>
			/// The whitespace/xml before the token
			/// </pre>
			/// <code>optional string before = 5;</code>
			/// </summary>
			ByteString GetBeforeBytes();

			/// <summary>
			/// <pre>
			/// The whitespace/xml after the token
			/// </pre>
			/// <code>optional string after = 6;</code>
			/// </summary>
			bool HasAfter();

			/// <summary>
			/// <pre>
			/// The whitespace/xml after the token
			/// </pre>
			/// <code>optional string after = 6;</code>
			/// </summary>
			string GetAfter();

			/// <summary>
			/// <pre>
			/// The whitespace/xml after the token
			/// </pre>
			/// <code>optional string after = 6;</code>
			/// </summary>
			ByteString GetAfterBytes();

			/// <summary>
			/// <pre>
			/// The original text for this token
			/// </pre>
			/// <code>optional string originalText = 7;</code>
			/// </summary>
			bool HasOriginalText();

			/// <summary>
			/// <pre>
			/// The original text for this token
			/// </pre>
			/// <code>optional string originalText = 7;</code>
			/// </summary>
			string GetOriginalText();

			/// <summary>
			/// <pre>
			/// The original text for this token
			/// </pre>
			/// <code>optional string originalText = 7;</code>
			/// </summary>
			ByteString GetOriginalTextBytes();

			/// <summary>
			/// <pre>
			/// The word's NER tag
			/// </pre>
			/// <code>optional string ner = 8;</code>
			/// </summary>
			bool HasNer();

			/// <summary>
			/// <pre>
			/// The word's NER tag
			/// </pre>
			/// <code>optional string ner = 8;</code>
			/// </summary>
			string GetNer();

			/// <summary>
			/// <pre>
			/// The word's NER tag
			/// </pre>
			/// <code>optional string ner = 8;</code>
			/// </summary>
			ByteString GetNerBytes();

			/// <summary>
			/// <pre>
			/// The word's coarse NER tag
			/// </pre>
			/// <code>optional string coarseNER = 62;</code>
			/// </summary>
			bool HasCoarseNER();

			/// <summary>
			/// <pre>
			/// The word's coarse NER tag
			/// </pre>
			/// <code>optional string coarseNER = 62;</code>
			/// </summary>
			string GetCoarseNER();

			/// <summary>
			/// <pre>
			/// The word's coarse NER tag
			/// </pre>
			/// <code>optional string coarseNER = 62;</code>
			/// </summary>
			ByteString GetCoarseNERBytes();

			/// <summary>
			/// <pre>
			/// The word's fine-grained NER tag
			/// </pre>
			/// <code>optional string fineGrainedNER = 63;</code>
			/// </summary>
			bool HasFineGrainedNER();

			/// <summary>
			/// <pre>
			/// The word's fine-grained NER tag
			/// </pre>
			/// <code>optional string fineGrainedNER = 63;</code>
			/// </summary>
			string GetFineGrainedNER();

			/// <summary>
			/// <pre>
			/// The word's fine-grained NER tag
			/// </pre>
			/// <code>optional string fineGrainedNER = 63;</code>
			/// </summary>
			ByteString GetFineGrainedNERBytes();

			/// <summary>
			/// <pre>
			/// The word's normalized NER tag
			/// </pre>
			/// <code>optional string normalizedNER = 9;</code>
			/// </summary>
			bool HasNormalizedNER();

			/// <summary>
			/// <pre>
			/// The word's normalized NER tag
			/// </pre>
			/// <code>optional string normalizedNER = 9;</code>
			/// </summary>
			string GetNormalizedNER();

			/// <summary>
			/// <pre>
			/// The word's normalized NER tag
			/// </pre>
			/// <code>optional string normalizedNER = 9;</code>
			/// </summary>
			ByteString GetNormalizedNERBytes();

			/// <summary>
			/// <pre>
			/// The word's lemma
			/// </pre>
			/// <code>optional string lemma = 10;</code>
			/// </summary>
			bool HasLemma();

			/// <summary>
			/// <pre>
			/// The word's lemma
			/// </pre>
			/// <code>optional string lemma = 10;</code>
			/// </summary>
			string GetLemma();

			/// <summary>
			/// <pre>
			/// The word's lemma
			/// </pre>
			/// <code>optional string lemma = 10;</code>
			/// </summary>
			ByteString GetLemmaBytes();

			/// <summary>
			/// <pre>
			/// The character offset begin, in the document
			/// </pre>
			/// <code>optional uint32 beginChar = 11;</code>
			/// </summary>
			bool HasBeginChar();

			/// <summary>
			/// <pre>
			/// The character offset begin, in the document
			/// </pre>
			/// <code>optional uint32 beginChar = 11;</code>
			/// </summary>
			int GetBeginChar();

			/// <summary>
			/// <pre>
			/// The character offset end, in the document
			/// </pre>
			/// <code>optional uint32 endChar = 12;</code>
			/// </summary>
			bool HasEndChar();

			/// <summary>
			/// <pre>
			/// The character offset end, in the document
			/// </pre>
			/// <code>optional uint32 endChar = 12;</code>
			/// </summary>
			int GetEndChar();

			/// <summary>
			/// <pre>
			/// The utterance tag used in dcoref
			/// </pre>
			/// <code>optional uint32 utterance = 13;</code>
			/// </summary>
			bool HasUtterance();

			/// <summary>
			/// <pre>
			/// The utterance tag used in dcoref
			/// </pre>
			/// <code>optional uint32 utterance = 13;</code>
			/// </summary>
			int GetUtterance();

			/// <summary>
			/// <pre>
			/// The speaker speaking this word
			/// </pre>
			/// <code>optional string speaker = 14;</code>
			/// </summary>
			bool HasSpeaker();

			/// <summary>
			/// <pre>
			/// The speaker speaking this word
			/// </pre>
			/// <code>optional string speaker = 14;</code>
			/// </summary>
			string GetSpeaker();

			/// <summary>
			/// <pre>
			/// The speaker speaking this word
			/// </pre>
			/// <code>optional string speaker = 14;</code>
			/// </summary>
			ByteString GetSpeakerBytes();

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 beginIndex = 15;</code>
			/// </summary>
			bool HasBeginIndex();

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 beginIndex = 15;</code>
			/// </summary>
			int GetBeginIndex();

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 endIndex = 16;</code>
			/// </summary>
			bool HasEndIndex();

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 endIndex = 16;</code>
			/// </summary>
			int GetEndIndex();

			/// <summary>
			/// <pre>
			/// The begin index of the token
			/// </pre>
			/// <code>optional uint32 tokenBeginIndex = 17;</code>
			/// </summary>
			bool HasTokenBeginIndex();

			/// <summary>
			/// <pre>
			/// The begin index of the token
			/// </pre>
			/// <code>optional uint32 tokenBeginIndex = 17;</code>
			/// </summary>
			int GetTokenBeginIndex();

			/// <summary>
			/// <pre>
			/// The end index of the token
			/// </pre>
			/// <code>optional uint32 tokenEndIndex = 18;</code>
			/// </summary>
			bool HasTokenEndIndex();

			/// <summary>
			/// <pre>
			/// The end index of the token
			/// </pre>
			/// <code>optional uint32 tokenEndIndex = 18;</code>
			/// </summary>
			int GetTokenEndIndex();

			/// <summary>
			/// <pre>
			/// The time this word refers to
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
			/// </summary>
			bool HasTimexValue();

			/// <summary>
			/// <pre>
			/// The time this word refers to
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
			/// </summary>
			CoreNLPProtos.Timex GetTimexValue();

			/// <summary>
			/// <pre>
			/// The time this word refers to
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
			/// </summary>
			CoreNLPProtos.ITimexOrBuilder GetTimexValueOrBuilder();

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>optional bool hasXmlContext = 21;</code>
			/// </summary>
			bool HasHasXmlContext();

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>optional bool hasXmlContext = 21;</code>
			/// </summary>
			bool GetHasXmlContext();

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			IList<string> GetXmlContextList();

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			int GetXmlContextCount();

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			string GetXmlContext(int index);

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			ByteString GetXmlContextBytes(int index);

			/// <summary>
			/// <pre>
			/// The [primary] cluster id for this token
			/// </pre>
			/// <code>optional uint32 corefClusterID = 23;</code>
			/// </summary>
			bool HasCorefClusterID();

			/// <summary>
			/// <pre>
			/// The [primary] cluster id for this token
			/// </pre>
			/// <code>optional uint32 corefClusterID = 23;</code>
			/// </summary>
			int GetCorefClusterID();

			/// <summary>
			/// <pre>
			/// A temporary annotation which is occasionally left in
			/// </pre>
			/// <code>optional string answer = 24;</code>
			/// </summary>
			bool HasAnswer();

			/// <summary>
			/// <pre>
			/// A temporary annotation which is occasionally left in
			/// </pre>
			/// <code>optional string answer = 24;</code>
			/// </summary>
			string GetAnswer();

			/// <summary>
			/// <pre>
			/// A temporary annotation which is occasionally left in
			/// </pre>
			/// <code>optional string answer = 24;</code>
			/// </summary>
			ByteString GetAnswerBytes();

			/// <summary>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
			/// </pre>
			/// <code>optional uint32 headWordIndex = 26;</code>
			/// </remarks>
			bool HasHeadWordIndex();

			/// <summary>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
			/// </pre>
			/// <code>optional uint32 headWordIndex = 26;</code>
			/// </remarks>
			int GetHeadWordIndex();

			/// <summary>
			/// <pre>
			/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
			/// </summary>
			bool HasOperator();

			/// <summary>
			/// <pre>
			/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
			/// </summary>
			CoreNLPProtos.Operator GetOperator();

			/// <summary>
			/// <pre>
			/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
			/// </summary>
			CoreNLPProtos.IOperatorOrBuilder GetOperatorOrBuilder();

			/// <summary>
			/// <pre>
			/// The polarity of this word, according to Natural Logic
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
			/// </summary>
			bool HasPolarity();

			/// <summary>
			/// <pre>
			/// The polarity of this word, according to Natural Logic
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
			/// </summary>
			CoreNLPProtos.Polarity GetPolarity();

			/// <summary>
			/// <pre>
			/// The polarity of this word, according to Natural Logic
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
			/// </summary>
			CoreNLPProtos.IPolarityOrBuilder GetPolarityOrBuilder();

			/// <summary>
			/// <pre>
			/// The polarity of this word, either "up", "down", or "flat"
			/// </pre>
			/// <code>optional string polarity_dir = 39;</code>
			/// </summary>
			bool HasPolarityDir();

			/// <summary>
			/// <pre>
			/// The polarity of this word, either "up", "down", or "flat"
			/// </pre>
			/// <code>optional string polarity_dir = 39;</code>
			/// </summary>
			string GetPolarityDir();

			/// <summary>
			/// <pre>
			/// The polarity of this word, either "up", "down", or "flat"
			/// </pre>
			/// <code>optional string polarity_dir = 39;</code>
			/// </summary>
			ByteString GetPolarityDirBytes();

			/// <summary>
			/// <pre>
			/// The span of a leaf node of a tree
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
			/// </summary>
			bool HasSpan();

			/// <summary>
			/// <pre>
			/// The span of a leaf node of a tree
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
			/// </summary>
			CoreNLPProtos.Span GetSpan();

			/// <summary>
			/// <pre>
			/// The span of a leaf node of a tree
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
			/// </summary>
			CoreNLPProtos.ISpanOrBuilder GetSpanOrBuilder();

			/// <summary>
			/// <pre>
			/// The final sentiment of the sentence
			/// </pre>
			/// <code>optional string sentiment = 30;</code>
			/// </summary>
			bool HasSentiment();

			/// <summary>
			/// <pre>
			/// The final sentiment of the sentence
			/// </pre>
			/// <code>optional string sentiment = 30;</code>
			/// </summary>
			string GetSentiment();

			/// <summary>
			/// <pre>
			/// The final sentiment of the sentence
			/// </pre>
			/// <code>optional string sentiment = 30;</code>
			/// </summary>
			ByteString GetSentimentBytes();

			/// <summary>
			/// <pre>
			/// The index of the quotation this token refers to
			/// </pre>
			/// <code>optional int32 quotationIndex = 31;</code>
			/// </summary>
			bool HasQuotationIndex();

			/// <summary>
			/// <pre>
			/// The index of the quotation this token refers to
			/// </pre>
			/// <code>optional int32 quotationIndex = 31;</code>
			/// </summary>
			int GetQuotationIndex();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
			bool HasConllUFeatures();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
			CoreNLPProtos.MapStringString GetConllUFeatures();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
			CoreNLPProtos.IMapStringStringOrBuilder GetConllUFeaturesOrBuilder();

			/// <summary>
			/// <pre>
			/// The coarse POS tag (used to store the UPOS tag)
			/// </pre>
			/// <code>optional string coarseTag = 33;</code>
			/// </summary>
			bool HasCoarseTag();

			/// <summary>
			/// <pre>
			/// The coarse POS tag (used to store the UPOS tag)
			/// </pre>
			/// <code>optional string coarseTag = 33;</code>
			/// </summary>
			string GetCoarseTag();

			/// <summary>
			/// <pre>
			/// The coarse POS tag (used to store the UPOS tag)
			/// </pre>
			/// <code>optional string coarseTag = 33;</code>
			/// </summary>
			ByteString GetCoarseTagBytes();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
			bool HasConllUTokenSpan();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
			CoreNLPProtos.Span GetConllUTokenSpan();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
			CoreNLPProtos.ISpanOrBuilder GetConllUTokenSpanOrBuilder();

			/// <summary><code>optional string conllUMisc = 35;</code></summary>
			bool HasConllUMisc();

			/// <summary><code>optional string conllUMisc = 35;</code></summary>
			string GetConllUMisc();

			/// <summary><code>optional string conllUMisc = 35;</code></summary>
			ByteString GetConllUMiscBytes();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
			bool HasConllUSecondaryDeps();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
			CoreNLPProtos.MapStringString GetConllUSecondaryDeps();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
			CoreNLPProtos.IMapStringStringOrBuilder GetConllUSecondaryDepsOrBuilder();

			/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
			bool HasWikipediaEntity();

			/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
			string GetWikipediaEntity();

			/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
			ByteString GetWikipediaEntityBytes();

			/// <summary><code>optional bool isNewline = 38;</code></summary>
			bool HasIsNewline();

			/// <summary><code>optional bool isNewline = 38;</code></summary>
			bool GetIsNewline();

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional string gender = 51;</code>
			/// </summary>
			bool HasGender();

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional string gender = 51;</code>
			/// </summary>
			string GetGender();

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional string gender = 51;</code>
			/// </summary>
			ByteString GetGenderBytes();

			/// <summary>
			/// <pre>
			/// true case type of token
			/// </pre>
			/// <code>optional string trueCase = 52;</code>
			/// </summary>
			bool HasTrueCase();

			/// <summary>
			/// <pre>
			/// true case type of token
			/// </pre>
			/// <code>optional string trueCase = 52;</code>
			/// </summary>
			string GetTrueCase();

			/// <summary>
			/// <pre>
			/// true case type of token
			/// </pre>
			/// <code>optional string trueCase = 52;</code>
			/// </summary>
			ByteString GetTrueCaseBytes();

			/// <summary>
			/// <pre>
			/// true case gloss of token
			/// </pre>
			/// <code>optional string trueCaseText = 53;</code>
			/// </summary>
			bool HasTrueCaseText();

			/// <summary>
			/// <pre>
			/// true case gloss of token
			/// </pre>
			/// <code>optional string trueCaseText = 53;</code>
			/// </summary>
			string GetTrueCaseText();

			/// <summary>
			/// <pre>
			/// true case gloss of token
			/// </pre>
			/// <code>optional string trueCaseText = 53;</code>
			/// </summary>
			ByteString GetTrueCaseTextBytes();

			/// <summary>
			/// <pre>
			/// Chinese character info
			/// </pre>
			/// <code>optional string chineseChar = 54;</code>
			/// </summary>
			bool HasChineseChar();

			/// <summary>
			/// <pre>
			/// Chinese character info
			/// </pre>
			/// <code>optional string chineseChar = 54;</code>
			/// </summary>
			string GetChineseChar();

			/// <summary>
			/// <pre>
			/// Chinese character info
			/// </pre>
			/// <code>optional string chineseChar = 54;</code>
			/// </summary>
			ByteString GetChineseCharBytes();

			/// <summary><code>optional string chineseSeg = 55;</code></summary>
			bool HasChineseSeg();

			/// <summary><code>optional string chineseSeg = 55;</code></summary>
			string GetChineseSeg();

			/// <summary><code>optional string chineseSeg = 55;</code></summary>
			ByteString GetChineseSegBytes();

			/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
			bool HasChineseXMLChar();

			/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
			string GetChineseXMLChar();

			/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
			ByteString GetChineseXMLCharBytes();

			/// <summary>
			/// <pre>
			/// Section info
			/// </pre>
			/// <code>optional string sectionName = 56;</code>
			/// </summary>
			bool HasSectionName();

			/// <summary>
			/// <pre>
			/// Section info
			/// </pre>
			/// <code>optional string sectionName = 56;</code>
			/// </summary>
			string GetSectionName();

			/// <summary>
			/// <pre>
			/// Section info
			/// </pre>
			/// <code>optional string sectionName = 56;</code>
			/// </summary>
			ByteString GetSectionNameBytes();

			/// <summary><code>optional string sectionAuthor = 57;</code></summary>
			bool HasSectionAuthor();

			/// <summary><code>optional string sectionAuthor = 57;</code></summary>
			string GetSectionAuthor();

			/// <summary><code>optional string sectionAuthor = 57;</code></summary>
			ByteString GetSectionAuthorBytes();

			/// <summary><code>optional string sectionDate = 58;</code></summary>
			bool HasSectionDate();

			/// <summary><code>optional string sectionDate = 58;</code></summary>
			string GetSectionDate();

			/// <summary><code>optional string sectionDate = 58;</code></summary>
			ByteString GetSectionDateBytes();

			/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
			bool HasSectionEndLabel();

			/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
			string GetSectionEndLabel();

			/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
			ByteString GetSectionEndLabelBytes();

			/// <summary>
			/// <pre>
			/// French tokens have parents
			/// </pre>
			/// <code>optional string parent = 61;</code>
			/// </summary>
			bool HasParent();

			/// <summary>
			/// <pre>
			/// French tokens have parents
			/// </pre>
			/// <code>optional string parent = 61;</code>
			/// </summary>
			string GetParent();

			/// <summary>
			/// <pre>
			/// French tokens have parents
			/// </pre>
			/// <code>optional string parent = 61;</code>
			/// </summary>
			ByteString GetParentBytes();

			/// <summary>
			/// <pre>
			/// mention index info
			/// </pre>
			/// <code>repeated uint32 corefMentionIndex = 64;</code>
			/// </summary>
			IList<int> GetCorefMentionIndexList();

			/// <summary>
			/// <pre>
			/// mention index info
			/// </pre>
			/// <code>repeated uint32 corefMentionIndex = 64;</code>
			/// </summary>
			int GetCorefMentionIndexCount();

			/// <summary>
			/// <pre>
			/// mention index info
			/// </pre>
			/// <code>repeated uint32 corefMentionIndex = 64;</code>
			/// </summary>
			int GetCorefMentionIndex(int index);

			/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
			bool HasEntityMentionIndex();

			/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
			int GetEntityMentionIndex();
		}

		/// <summary>
		/// <pre>
		/// The serialized version of a Token (a CoreLabel).
		/// </summary>
		/// <remarks>
		/// <pre>
		/// The serialized version of a Token (a CoreLabel).
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Token</c>
		/// </remarks>
		[System.Serializable]
		public sealed class Token : GeneratedMessageV3.ExtendableMessage<CoreNLPProtos.Token>, CoreNLPProtos.ITokenOrBuilder
		{
			private Token(GeneratedMessageV3.ExtendableBuilder<CoreNLPProtos.Token, object> builder)
				: base(builder)
			{
			}

			private Token()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Token)
				// Use Token.newBuilder() to construct.
				word_ = string.Empty;
				pos_ = string.Empty;
				value_ = string.Empty;
				category_ = string.Empty;
				before_ = string.Empty;
				after_ = string.Empty;
				originalText_ = string.Empty;
				ner_ = string.Empty;
				coarseNER_ = string.Empty;
				fineGrainedNER_ = string.Empty;
				normalizedNER_ = string.Empty;
				lemma_ = string.Empty;
				beginChar_ = 0;
				endChar_ = 0;
				utterance_ = 0;
				speaker_ = string.Empty;
				beginIndex_ = 0;
				endIndex_ = 0;
				tokenBeginIndex_ = 0;
				tokenEndIndex_ = 0;
				hasXmlContext_ = false;
				xmlContext_ = LazyStringArrayList.Empty;
				corefClusterID_ = 0;
				answer_ = string.Empty;
				headWordIndex_ = 0;
				polarityDir_ = string.Empty;
				sentiment_ = string.Empty;
				quotationIndex_ = 0;
				coarseTag_ = string.Empty;
				conllUMisc_ = string.Empty;
				wikipediaEntity_ = string.Empty;
				isNewline_ = false;
				gender_ = string.Empty;
				trueCase_ = string.Empty;
				trueCaseText_ = string.Empty;
				chineseChar_ = string.Empty;
				chineseSeg_ = string.Empty;
				chineseXMLChar_ = string.Empty;
				sectionName_ = string.Empty;
				sectionAuthor_ = string.Empty;
				sectionDate_ = string.Empty;
				sectionEndLabel_ = string.Empty;
				parent_ = string.Empty;
				corefMentionIndex_ = Java.Util.Collections.EmptyList();
				entityMentionIndex_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Token(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				int mutable_bitField1_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								word_ = bs;
								break;
							}

							case 18:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000002));
								pos_ = bs;
								break;
							}

							case 26:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000004));
								value_ = bs;
								break;
							}

							case 34:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000008));
								category_ = bs;
								break;
							}

							case 42:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000010));
								before_ = bs;
								break;
							}

							case 50:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000020));
								after_ = bs;
								break;
							}

							case 58:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000040));
								originalText_ = bs;
								break;
							}

							case 66:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000080));
								ner_ = bs;
								break;
							}

							case 74:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000400));
								normalizedNER_ = bs;
								break;
							}

							case 82:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000800));
								lemma_ = bs;
								break;
							}

							case 88:
							{
								bitField0_ |= unchecked((int)(0x00001000));
								beginChar_ = input.ReadUInt32();
								break;
							}

							case 96:
							{
								bitField0_ |= unchecked((int)(0x00002000));
								endChar_ = input.ReadUInt32();
								break;
							}

							case 104:
							{
								bitField0_ |= unchecked((int)(0x00004000));
								utterance_ = input.ReadUInt32();
								break;
							}

							case 114:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00008000));
								speaker_ = bs;
								break;
							}

							case 120:
							{
								bitField0_ |= unchecked((int)(0x00010000));
								beginIndex_ = input.ReadUInt32();
								break;
							}

							case 128:
							{
								bitField0_ |= unchecked((int)(0x00020000));
								endIndex_ = input.ReadUInt32();
								break;
							}

							case 136:
							{
								bitField0_ |= unchecked((int)(0x00040000));
								tokenBeginIndex_ = input.ReadUInt32();
								break;
							}

							case 144:
							{
								bitField0_ |= unchecked((int)(0x00080000));
								tokenEndIndex_ = input.ReadUInt32();
								break;
							}

							case 154:
							{
								CoreNLPProtos.Timex.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
								{
									subBuilder = ((CoreNLPProtos.Timex.Builder)timexValue_.ToBuilder());
								}
								timexValue_ = input.ReadMessage(CoreNLPProtos.Timex.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(timexValue_);
									timexValue_ = ((CoreNLPProtos.Timex)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00100000));
								break;
							}

							case 168:
							{
								bitField0_ |= unchecked((int)(0x00200000));
								hasXmlContext_ = input.ReadBool();
								break;
							}

							case 178:
							{
								ByteString bs = input.ReadBytes();
								if (!((mutable_bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
								{
									xmlContext_ = new LazyStringArrayList();
									mutable_bitField0_ |= unchecked((int)(0x00400000));
								}
								xmlContext_.Add(bs);
								break;
							}

							case 184:
							{
								bitField0_ |= unchecked((int)(0x00400000));
								corefClusterID_ = input.ReadUInt32();
								break;
							}

							case 194:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00800000));
								answer_ = bs;
								break;
							}

							case 208:
							{
								bitField0_ |= unchecked((int)(0x01000000));
								headWordIndex_ = input.ReadUInt32();
								break;
							}

							case 218:
							{
								CoreNLPProtos.Operator.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
								{
									subBuilder = ((CoreNLPProtos.Operator.Builder)operator_.ToBuilder());
								}
								operator_ = input.ReadMessage(CoreNLPProtos.Operator.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(operator_);
									operator_ = ((CoreNLPProtos.Operator)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x02000000));
								break;
							}

							case 226:
							{
								CoreNLPProtos.Polarity.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
								{
									subBuilder = ((CoreNLPProtos.Polarity.Builder)polarity_.ToBuilder());
								}
								polarity_ = input.ReadMessage(CoreNLPProtos.Polarity.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(polarity_);
									polarity_ = ((CoreNLPProtos.Polarity)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x04000000));
								break;
							}

							case 234:
							{
								CoreNLPProtos.Span.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
								{
									subBuilder = ((CoreNLPProtos.Span.Builder)span_.ToBuilder());
								}
								span_ = input.ReadMessage(CoreNLPProtos.Span.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(span_);
									span_ = ((CoreNLPProtos.Span)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x10000000));
								break;
							}

							case 242:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x20000000));
								sentiment_ = bs;
								break;
							}

							case 248:
							{
								bitField0_ |= unchecked((int)(0x40000000));
								quotationIndex_ = input.ReadInt32();
								break;
							}

							case 258:
							{
								CoreNLPProtos.MapStringString.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
								{
									subBuilder = ((CoreNLPProtos.MapStringString.Builder)conllUFeatures_.ToBuilder());
								}
								conllUFeatures_ = input.ReadMessage(CoreNLPProtos.MapStringString.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(conllUFeatures_);
									conllUFeatures_ = ((CoreNLPProtos.MapStringString)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x80000000));
								break;
							}

							case 266:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000001));
								coarseTag_ = bs;
								break;
							}

							case 274:
							{
								CoreNLPProtos.Span.Builder subBuilder = null;
								if (((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									subBuilder = ((CoreNLPProtos.Span.Builder)conllUTokenSpan_.ToBuilder());
								}
								conllUTokenSpan_ = input.ReadMessage(CoreNLPProtos.Span.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(conllUTokenSpan_);
									conllUTokenSpan_ = ((CoreNLPProtos.Span)subBuilder.BuildPartial());
								}
								bitField1_ |= unchecked((int)(0x00000002));
								break;
							}

							case 282:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000004));
								conllUMisc_ = bs;
								break;
							}

							case 290:
							{
								CoreNLPProtos.MapStringString.Builder subBuilder = null;
								if (((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
								{
									subBuilder = ((CoreNLPProtos.MapStringString.Builder)conllUSecondaryDeps_.ToBuilder());
								}
								conllUSecondaryDeps_ = input.ReadMessage(CoreNLPProtos.MapStringString.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(conllUSecondaryDeps_);
									conllUSecondaryDeps_ = ((CoreNLPProtos.MapStringString)subBuilder.BuildPartial());
								}
								bitField1_ |= unchecked((int)(0x00000008));
								break;
							}

							case 298:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000010));
								wikipediaEntity_ = bs;
								break;
							}

							case 304:
							{
								bitField1_ |= unchecked((int)(0x00000020));
								isNewline_ = input.ReadBool();
								break;
							}

							case 314:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x08000000));
								polarityDir_ = bs;
								break;
							}

							case 410:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000040));
								gender_ = bs;
								break;
							}

							case 418:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000080));
								trueCase_ = bs;
								break;
							}

							case 426:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000100));
								trueCaseText_ = bs;
								break;
							}

							case 434:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000200));
								chineseChar_ = bs;
								break;
							}

							case 442:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000400));
								chineseSeg_ = bs;
								break;
							}

							case 450:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00001000));
								sectionName_ = bs;
								break;
							}

							case 458:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00002000));
								sectionAuthor_ = bs;
								break;
							}

							case 466:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00004000));
								sectionDate_ = bs;
								break;
							}

							case 474:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00008000));
								sectionEndLabel_ = bs;
								break;
							}

							case 482:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00000800));
								chineseXMLChar_ = bs;
								break;
							}

							case 490:
							{
								ByteString bs = input.ReadBytes();
								bitField1_ |= unchecked((int)(0x00010000));
								parent_ = bs;
								break;
							}

							case 498:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000100));
								coarseNER_ = bs;
								break;
							}

							case 506:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000200));
								fineGrainedNER_ = bs;
								break;
							}

							case 512:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
								{
									corefMentionIndex_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00040000));
								}
								corefMentionIndex_.Add(input.ReadUInt32());
								break;
							}

							case 514:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField1_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))) && input.GetBytesUntilLimit() > 0)
								{
									corefMentionIndex_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00040000));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									corefMentionIndex_.Add(input.ReadUInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 520:
							{
								bitField1_ |= unchecked((int)(0x00020000));
								entityMentionIndex_ = input.ReadUInt32();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
					{
						xmlContext_ = xmlContext_.GetUnmodifiableView();
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						corefMentionIndex_ = Java.Util.Collections.UnmodifiableList(corefMentionIndex_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Token_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Token_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Token), typeof(CoreNLPProtos.Token.Builder));
			}

			private int bitField0_;

			private int bitField1_;

			public const int WordFieldNumber = 1;

			private volatile object word_;

			/// <summary>
			/// <pre>
			/// Fields set by the default annotators [new CoreNLP(new Properties())]
			/// </pre>
			/// <code>optional string word = 1;</code>
			/// </summary>
			public bool HasWord()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary>
			/// <pre>
			/// Fields set by the default annotators [new CoreNLP(new Properties())]
			/// </pre>
			/// <code>optional string word = 1;</code>
			/// </summary>
			public string GetWord()
			{
				object @ref = word_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						word_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Fields set by the default annotators [new CoreNLP(new Properties())]
			/// </pre>
			/// <code>optional string word = 1;</code>
			/// </summary>
			public ByteString GetWordBytes()
			{
				object @ref = word_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					word_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int PosFieldNumber = 2;

			private volatile object pos_;

			/// <summary>
			/// <pre>
			/// The word's part of speech tag
			/// </pre>
			/// <code>optional string pos = 2;</code>
			/// </summary>
			public bool HasPos()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary>
			/// <pre>
			/// The word's part of speech tag
			/// </pre>
			/// <code>optional string pos = 2;</code>
			/// </summary>
			public string GetPos()
			{
				object @ref = pos_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						pos_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's part of speech tag
			/// </pre>
			/// <code>optional string pos = 2;</code>
			/// </summary>
			public ByteString GetPosBytes()
			{
				object @ref = pos_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					pos_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ValueFieldNumber = 3;

			private volatile object value_;

			/// <summary>
			/// <pre>
			/// The word's 'value', (e.g., parse tree node)
			/// </pre>
			/// <code>optional string value = 3;</code>
			/// </summary>
			public bool HasValue()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary>
			/// <pre>
			/// The word's 'value', (e.g., parse tree node)
			/// </pre>
			/// <code>optional string value = 3;</code>
			/// </summary>
			public string GetValue()
			{
				object @ref = value_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						value_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's 'value', (e.g., parse tree node)
			/// </pre>
			/// <code>optional string value = 3;</code>
			/// </summary>
			public ByteString GetValueBytes()
			{
				object @ref = value_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					value_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int CategoryFieldNumber = 4;

			private volatile object category_;

			/// <summary>
			/// <pre>
			/// The word's 'category' (e.g., parse tree node)
			/// </pre>
			/// <code>optional string category = 4;</code>
			/// </summary>
			public bool HasCategory()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary>
			/// <pre>
			/// The word's 'category' (e.g., parse tree node)
			/// </pre>
			/// <code>optional string category = 4;</code>
			/// </summary>
			public string GetCategory()
			{
				object @ref = category_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						category_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's 'category' (e.g., parse tree node)
			/// </pre>
			/// <code>optional string category = 4;</code>
			/// </summary>
			public ByteString GetCategoryBytes()
			{
				object @ref = category_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					category_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int BeforeFieldNumber = 5;

			private volatile object before_;

			/// <summary>
			/// <pre>
			/// The whitespace/xml before the token
			/// </pre>
			/// <code>optional string before = 5;</code>
			/// </summary>
			public bool HasBefore()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary>
			/// <pre>
			/// The whitespace/xml before the token
			/// </pre>
			/// <code>optional string before = 5;</code>
			/// </summary>
			public string GetBefore()
			{
				object @ref = before_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						before_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The whitespace/xml before the token
			/// </pre>
			/// <code>optional string before = 5;</code>
			/// </summary>
			public ByteString GetBeforeBytes()
			{
				object @ref = before_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					before_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int AfterFieldNumber = 6;

			private volatile object after_;

			/// <summary>
			/// <pre>
			/// The whitespace/xml after the token
			/// </pre>
			/// <code>optional string after = 6;</code>
			/// </summary>
			public bool HasAfter()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary>
			/// <pre>
			/// The whitespace/xml after the token
			/// </pre>
			/// <code>optional string after = 6;</code>
			/// </summary>
			public string GetAfter()
			{
				object @ref = after_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						after_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The whitespace/xml after the token
			/// </pre>
			/// <code>optional string after = 6;</code>
			/// </summary>
			public ByteString GetAfterBytes()
			{
				object @ref = after_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					after_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int OriginaltextFieldNumber = 7;

			private volatile object originalText_;

			/// <summary>
			/// <pre>
			/// The original text for this token
			/// </pre>
			/// <code>optional string originalText = 7;</code>
			/// </summary>
			public bool HasOriginalText()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary>
			/// <pre>
			/// The original text for this token
			/// </pre>
			/// <code>optional string originalText = 7;</code>
			/// </summary>
			public string GetOriginalText()
			{
				object @ref = originalText_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						originalText_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The original text for this token
			/// </pre>
			/// <code>optional string originalText = 7;</code>
			/// </summary>
			public ByteString GetOriginalTextBytes()
			{
				object @ref = originalText_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					originalText_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int NerFieldNumber = 8;

			private volatile object ner_;

			/// <summary>
			/// <pre>
			/// The word's NER tag
			/// </pre>
			/// <code>optional string ner = 8;</code>
			/// </summary>
			public bool HasNer()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary>
			/// <pre>
			/// The word's NER tag
			/// </pre>
			/// <code>optional string ner = 8;</code>
			/// </summary>
			public string GetNer()
			{
				object @ref = ner_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						ner_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's NER tag
			/// </pre>
			/// <code>optional string ner = 8;</code>
			/// </summary>
			public ByteString GetNerBytes()
			{
				object @ref = ner_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					ner_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int CoarsenerFieldNumber = 62;

			private volatile object coarseNER_;

			/// <summary>
			/// <pre>
			/// The word's coarse NER tag
			/// </pre>
			/// <code>optional string coarseNER = 62;</code>
			/// </summary>
			public bool HasCoarseNER()
			{
				return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary>
			/// <pre>
			/// The word's coarse NER tag
			/// </pre>
			/// <code>optional string coarseNER = 62;</code>
			/// </summary>
			public string GetCoarseNER()
			{
				object @ref = coarseNER_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						coarseNER_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's coarse NER tag
			/// </pre>
			/// <code>optional string coarseNER = 62;</code>
			/// </summary>
			public ByteString GetCoarseNERBytes()
			{
				object @ref = coarseNER_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					coarseNER_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int FinegrainednerFieldNumber = 63;

			private volatile object fineGrainedNER_;

			/// <summary>
			/// <pre>
			/// The word's fine-grained NER tag
			/// </pre>
			/// <code>optional string fineGrainedNER = 63;</code>
			/// </summary>
			public bool HasFineGrainedNER()
			{
				return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
			}

			/// <summary>
			/// <pre>
			/// The word's fine-grained NER tag
			/// </pre>
			/// <code>optional string fineGrainedNER = 63;</code>
			/// </summary>
			public string GetFineGrainedNER()
			{
				object @ref = fineGrainedNER_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						fineGrainedNER_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's fine-grained NER tag
			/// </pre>
			/// <code>optional string fineGrainedNER = 63;</code>
			/// </summary>
			public ByteString GetFineGrainedNERBytes()
			{
				object @ref = fineGrainedNER_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					fineGrainedNER_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int NormalizednerFieldNumber = 9;

			private volatile object normalizedNER_;

			/// <summary>
			/// <pre>
			/// The word's normalized NER tag
			/// </pre>
			/// <code>optional string normalizedNER = 9;</code>
			/// </summary>
			public bool HasNormalizedNER()
			{
				return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
			}

			/// <summary>
			/// <pre>
			/// The word's normalized NER tag
			/// </pre>
			/// <code>optional string normalizedNER = 9;</code>
			/// </summary>
			public string GetNormalizedNER()
			{
				object @ref = normalizedNER_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						normalizedNER_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's normalized NER tag
			/// </pre>
			/// <code>optional string normalizedNER = 9;</code>
			/// </summary>
			public ByteString GetNormalizedNERBytes()
			{
				object @ref = normalizedNER_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					normalizedNER_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int LemmaFieldNumber = 10;

			private volatile object lemma_;

			/// <summary>
			/// <pre>
			/// The word's lemma
			/// </pre>
			/// <code>optional string lemma = 10;</code>
			/// </summary>
			public bool HasLemma()
			{
				return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
			}

			/// <summary>
			/// <pre>
			/// The word's lemma
			/// </pre>
			/// <code>optional string lemma = 10;</code>
			/// </summary>
			public string GetLemma()
			{
				object @ref = lemma_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						lemma_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The word's lemma
			/// </pre>
			/// <code>optional string lemma = 10;</code>
			/// </summary>
			public ByteString GetLemmaBytes()
			{
				object @ref = lemma_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					lemma_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int BegincharFieldNumber = 11;

			private int beginChar_;

			/// <summary>
			/// <pre>
			/// The character offset begin, in the document
			/// </pre>
			/// <code>optional uint32 beginChar = 11;</code>
			/// </summary>
			public bool HasBeginChar()
			{
				return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
			}

			/// <summary>
			/// <pre>
			/// The character offset begin, in the document
			/// </pre>
			/// <code>optional uint32 beginChar = 11;</code>
			/// </summary>
			public int GetBeginChar()
			{
				return beginChar_;
			}

			public const int EndcharFieldNumber = 12;

			private int endChar_;

			/// <summary>
			/// <pre>
			/// The character offset end, in the document
			/// </pre>
			/// <code>optional uint32 endChar = 12;</code>
			/// </summary>
			public bool HasEndChar()
			{
				return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
			}

			/// <summary>
			/// <pre>
			/// The character offset end, in the document
			/// </pre>
			/// <code>optional uint32 endChar = 12;</code>
			/// </summary>
			public int GetEndChar()
			{
				return endChar_;
			}

			public const int UtteranceFieldNumber = 13;

			private int utterance_;

			/// <summary>
			/// <pre>
			/// The utterance tag used in dcoref
			/// </pre>
			/// <code>optional uint32 utterance = 13;</code>
			/// </summary>
			public bool HasUtterance()
			{
				return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
			}

			/// <summary>
			/// <pre>
			/// The utterance tag used in dcoref
			/// </pre>
			/// <code>optional uint32 utterance = 13;</code>
			/// </summary>
			public int GetUtterance()
			{
				return utterance_;
			}

			public const int SpeakerFieldNumber = 14;

			private volatile object speaker_;

			/// <summary>
			/// <pre>
			/// The speaker speaking this word
			/// </pre>
			/// <code>optional string speaker = 14;</code>
			/// </summary>
			public bool HasSpeaker()
			{
				return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
			}

			/// <summary>
			/// <pre>
			/// The speaker speaking this word
			/// </pre>
			/// <code>optional string speaker = 14;</code>
			/// </summary>
			public string GetSpeaker()
			{
				object @ref = speaker_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						speaker_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The speaker speaking this word
			/// </pre>
			/// <code>optional string speaker = 14;</code>
			/// </summary>
			public ByteString GetSpeakerBytes()
			{
				object @ref = speaker_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					speaker_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int BeginindexFieldNumber = 15;

			private int beginIndex_;

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 beginIndex = 15;</code>
			/// </summary>
			public bool HasBeginIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
			}

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 beginIndex = 15;</code>
			/// </summary>
			public int GetBeginIndex()
			{
				return beginIndex_;
			}

			public const int EndindexFieldNumber = 16;

			private int endIndex_;

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 endIndex = 16;</code>
			/// </summary>
			public bool HasEndIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
			}

			/// <summary>
			/// <pre>
			/// The begin index of, e.g., a span
			/// </pre>
			/// <code>optional uint32 endIndex = 16;</code>
			/// </summary>
			public int GetEndIndex()
			{
				return endIndex_;
			}

			public const int TokenbeginindexFieldNumber = 17;

			private int tokenBeginIndex_;

			/// <summary>
			/// <pre>
			/// The begin index of the token
			/// </pre>
			/// <code>optional uint32 tokenBeginIndex = 17;</code>
			/// </summary>
			public bool HasTokenBeginIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000)));
			}

			/// <summary>
			/// <pre>
			/// The begin index of the token
			/// </pre>
			/// <code>optional uint32 tokenBeginIndex = 17;</code>
			/// </summary>
			public int GetTokenBeginIndex()
			{
				return tokenBeginIndex_;
			}

			public const int TokenendindexFieldNumber = 18;

			private int tokenEndIndex_;

			/// <summary>
			/// <pre>
			/// The end index of the token
			/// </pre>
			/// <code>optional uint32 tokenEndIndex = 18;</code>
			/// </summary>
			public bool HasTokenEndIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
			}

			/// <summary>
			/// <pre>
			/// The end index of the token
			/// </pre>
			/// <code>optional uint32 tokenEndIndex = 18;</code>
			/// </summary>
			public int GetTokenEndIndex()
			{
				return tokenEndIndex_;
			}

			public const int TimexvalueFieldNumber = 19;

			private CoreNLPProtos.Timex timexValue_;

			/// <summary>
			/// <pre>
			/// The time this word refers to
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
			/// </summary>
			public bool HasTimexValue()
			{
				return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
			}

			/// <summary>
			/// <pre>
			/// The time this word refers to
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
			/// </summary>
			public CoreNLPProtos.Timex GetTimexValue()
			{
				return timexValue_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timexValue_;
			}

			/// <summary>
			/// <pre>
			/// The time this word refers to
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
			/// </summary>
			public CoreNLPProtos.ITimexOrBuilder GetTimexValueOrBuilder()
			{
				return timexValue_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timexValue_;
			}

			public const int HasxmlcontextFieldNumber = 21;

			private bool hasXmlContext_;

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>optional bool hasXmlContext = 21;</code>
			/// </summary>
			public bool HasHasXmlContext()
			{
				return ((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000)));
			}

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>optional bool hasXmlContext = 21;</code>
			/// </summary>
			public bool GetHasXmlContext()
			{
				return hasXmlContext_;
			}

			public const int XmlcontextFieldNumber = 22;

			private ILazyStringList xmlContext_;

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			public IProtocolStringList GetXmlContextList()
			{
				return xmlContext_;
			}

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			public int GetXmlContextCount()
			{
				return xmlContext_.Count;
			}

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			public string GetXmlContext(int index)
			{
				return xmlContext_[index];
			}

			/// <summary>
			/// <pre>
			/// Used by clean xml annotator
			/// </pre>
			/// <code>repeated string xmlContext = 22;</code>
			/// </summary>
			public ByteString GetXmlContextBytes(int index)
			{
				return xmlContext_.GetByteString(index);
			}

			public const int CorefclusteridFieldNumber = 23;

			private int corefClusterID_;

			/// <summary>
			/// <pre>
			/// The [primary] cluster id for this token
			/// </pre>
			/// <code>optional uint32 corefClusterID = 23;</code>
			/// </summary>
			public bool HasCorefClusterID()
			{
				return ((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000)));
			}

			/// <summary>
			/// <pre>
			/// The [primary] cluster id for this token
			/// </pre>
			/// <code>optional uint32 corefClusterID = 23;</code>
			/// </summary>
			public int GetCorefClusterID()
			{
				return corefClusterID_;
			}

			public const int AnswerFieldNumber = 24;

			private volatile object answer_;

			/// <summary>
			/// <pre>
			/// A temporary annotation which is occasionally left in
			/// </pre>
			/// <code>optional string answer = 24;</code>
			/// </summary>
			public bool HasAnswer()
			{
				return ((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000)));
			}

			/// <summary>
			/// <pre>
			/// A temporary annotation which is occasionally left in
			/// </pre>
			/// <code>optional string answer = 24;</code>
			/// </summary>
			public string GetAnswer()
			{
				object @ref = answer_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						answer_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// A temporary annotation which is occasionally left in
			/// </pre>
			/// <code>optional string answer = 24;</code>
			/// </summary>
			public ByteString GetAnswerBytes()
			{
				object @ref = answer_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					answer_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int HeadwordindexFieldNumber = 26;

			private int headWordIndex_;

			/// <summary>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
			/// </pre>
			/// <code>optional uint32 headWordIndex = 26;</code>
			/// </remarks>
			public bool HasHeadWordIndex()
			{
				return ((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000)));
			}

			/// <summary>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
			/// </pre>
			/// <code>optional uint32 headWordIndex = 26;</code>
			/// </remarks>
			public int GetHeadWordIndex()
			{
				return headWordIndex_;
			}

			public const int OperatorFieldNumber = 27;

			private CoreNLPProtos.Operator operator_;

			/// <summary>
			/// <pre>
			/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
			/// </summary>
			public bool HasOperator()
			{
				return ((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000)));
			}

			/// <summary>
			/// <pre>
			/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
			/// </summary>
			public CoreNLPProtos.Operator GetOperator()
			{
				return operator_ == null ? CoreNLPProtos.Operator.GetDefaultInstance() : operator_;
			}

			/// <summary>
			/// <pre>
			/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
			/// </summary>
			public CoreNLPProtos.IOperatorOrBuilder GetOperatorOrBuilder()
			{
				return operator_ == null ? CoreNLPProtos.Operator.GetDefaultInstance() : operator_;
			}

			public const int PolarityFieldNumber = 28;

			private CoreNLPProtos.Polarity polarity_;

			/// <summary>
			/// <pre>
			/// The polarity of this word, according to Natural Logic
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
			/// </summary>
			public bool HasPolarity()
			{
				return ((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000)));
			}

			/// <summary>
			/// <pre>
			/// The polarity of this word, according to Natural Logic
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
			/// </summary>
			public CoreNLPProtos.Polarity GetPolarity()
			{
				return polarity_ == null ? CoreNLPProtos.Polarity.GetDefaultInstance() : polarity_;
			}

			/// <summary>
			/// <pre>
			/// The polarity of this word, according to Natural Logic
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
			/// </summary>
			public CoreNLPProtos.IPolarityOrBuilder GetPolarityOrBuilder()
			{
				return polarity_ == null ? CoreNLPProtos.Polarity.GetDefaultInstance() : polarity_;
			}

			public const int PolarityDirFieldNumber = 39;

			private volatile object polarityDir_;

			/// <summary>
			/// <pre>
			/// The polarity of this word, either "up", "down", or "flat"
			/// </pre>
			/// <code>optional string polarity_dir = 39;</code>
			/// </summary>
			public bool HasPolarityDir()
			{
				return ((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000)));
			}

			/// <summary>
			/// <pre>
			/// The polarity of this word, either "up", "down", or "flat"
			/// </pre>
			/// <code>optional string polarity_dir = 39;</code>
			/// </summary>
			public string GetPolarityDir()
			{
				object @ref = polarityDir_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						polarityDir_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The polarity of this word, either "up", "down", or "flat"
			/// </pre>
			/// <code>optional string polarity_dir = 39;</code>
			/// </summary>
			public ByteString GetPolarityDirBytes()
			{
				object @ref = polarityDir_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					polarityDir_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SpanFieldNumber = 29;

			private CoreNLPProtos.Span span_;

			/// <summary>
			/// <pre>
			/// The span of a leaf node of a tree
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
			/// </summary>
			public bool HasSpan()
			{
				return ((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000)));
			}

			/// <summary>
			/// <pre>
			/// The span of a leaf node of a tree
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
			/// </summary>
			public CoreNLPProtos.Span GetSpan()
			{
				return span_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : span_;
			}

			/// <summary>
			/// <pre>
			/// The span of a leaf node of a tree
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
			/// </summary>
			public CoreNLPProtos.ISpanOrBuilder GetSpanOrBuilder()
			{
				return span_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : span_;
			}

			public const int SentimentFieldNumber = 30;

			private volatile object sentiment_;

			/// <summary>
			/// <pre>
			/// The final sentiment of the sentence
			/// </pre>
			/// <code>optional string sentiment = 30;</code>
			/// </summary>
			public bool HasSentiment()
			{
				return ((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000)));
			}

			/// <summary>
			/// <pre>
			/// The final sentiment of the sentence
			/// </pre>
			/// <code>optional string sentiment = 30;</code>
			/// </summary>
			public string GetSentiment()
			{
				object @ref = sentiment_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sentiment_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The final sentiment of the sentence
			/// </pre>
			/// <code>optional string sentiment = 30;</code>
			/// </summary>
			public ByteString GetSentimentBytes()
			{
				object @ref = sentiment_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sentiment_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int QuotationindexFieldNumber = 31;

			private int quotationIndex_;

			/// <summary>
			/// <pre>
			/// The index of the quotation this token refers to
			/// </pre>
			/// <code>optional int32 quotationIndex = 31;</code>
			/// </summary>
			public bool HasQuotationIndex()
			{
				return ((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000)));
			}

			/// <summary>
			/// <pre>
			/// The index of the quotation this token refers to
			/// </pre>
			/// <code>optional int32 quotationIndex = 31;</code>
			/// </summary>
			public int GetQuotationIndex()
			{
				return quotationIndex_;
			}

			public const int ConllufeaturesFieldNumber = 32;

			private CoreNLPProtos.MapStringString conllUFeatures_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
			public bool HasConllUFeatures()
			{
				return ((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
			public CoreNLPProtos.MapStringString GetConllUFeatures()
			{
				return conllUFeatures_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUFeatures_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
			public CoreNLPProtos.IMapStringStringOrBuilder GetConllUFeaturesOrBuilder()
			{
				return conllUFeatures_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUFeatures_;
			}

			public const int CoarsetagFieldNumber = 33;

			private volatile object coarseTag_;

			/// <summary>
			/// <pre>
			/// The coarse POS tag (used to store the UPOS tag)
			/// </pre>
			/// <code>optional string coarseTag = 33;</code>
			/// </summary>
			public bool HasCoarseTag()
			{
				return ((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary>
			/// <pre>
			/// The coarse POS tag (used to store the UPOS tag)
			/// </pre>
			/// <code>optional string coarseTag = 33;</code>
			/// </summary>
			public string GetCoarseTag()
			{
				object @ref = coarseTag_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						coarseTag_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The coarse POS tag (used to store the UPOS tag)
			/// </pre>
			/// <code>optional string coarseTag = 33;</code>
			/// </summary>
			public ByteString GetCoarseTagBytes()
			{
				object @ref = coarseTag_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					coarseTag_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ConllutokenspanFieldNumber = 34;

			private CoreNLPProtos.Span conllUTokenSpan_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
			public bool HasConllUTokenSpan()
			{
				return ((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
			public CoreNLPProtos.Span GetConllUTokenSpan()
			{
				return conllUTokenSpan_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : conllUTokenSpan_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
			public CoreNLPProtos.ISpanOrBuilder GetConllUTokenSpanOrBuilder()
			{
				return conllUTokenSpan_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : conllUTokenSpan_;
			}

			public const int ConllumiscFieldNumber = 35;

			private volatile object conllUMisc_;

			/// <summary><code>optional string conllUMisc = 35;</code></summary>
			public bool HasConllUMisc()
			{
				return ((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional string conllUMisc = 35;</code></summary>
			public string GetConllUMisc()
			{
				object @ref = conllUMisc_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						conllUMisc_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string conllUMisc = 35;</code></summary>
			public ByteString GetConllUMiscBytes()
			{
				object @ref = conllUMisc_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					conllUMisc_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ConllusecondarydepsFieldNumber = 36;

			private CoreNLPProtos.MapStringString conllUSecondaryDeps_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
			public bool HasConllUSecondaryDeps()
			{
				return ((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
			public CoreNLPProtos.MapStringString GetConllUSecondaryDeps()
			{
				return conllUSecondaryDeps_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUSecondaryDeps_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
			public CoreNLPProtos.IMapStringStringOrBuilder GetConllUSecondaryDepsOrBuilder()
			{
				return conllUSecondaryDeps_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUSecondaryDeps_;
			}

			public const int WikipediaentityFieldNumber = 37;

			private volatile object wikipediaEntity_;

			/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
			public bool HasWikipediaEntity()
			{
				return ((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
			public string GetWikipediaEntity()
			{
				object @ref = wikipediaEntity_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						wikipediaEntity_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
			public ByteString GetWikipediaEntityBytes()
			{
				object @ref = wikipediaEntity_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					wikipediaEntity_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int IsnewlineFieldNumber = 38;

			private bool isNewline_;

			/// <summary><code>optional bool isNewline = 38;</code></summary>
			public bool HasIsNewline()
			{
				return ((bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional bool isNewline = 38;</code></summary>
			public bool GetIsNewline()
			{
				return isNewline_;
			}

			public const int GenderFieldNumber = 51;

			private volatile object gender_;

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional string gender = 51;</code>
			/// </summary>
			public bool HasGender()
			{
				return ((bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional string gender = 51;</code>
			/// </summary>
			public string GetGender()
			{
				object @ref = gender_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						gender_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Fields set by other annotators in CoreNLP
			/// </pre>
			/// <code>optional string gender = 51;</code>
			/// </summary>
			public ByteString GetGenderBytes()
			{
				object @ref = gender_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					gender_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int TruecaseFieldNumber = 52;

			private volatile object trueCase_;

			/// <summary>
			/// <pre>
			/// true case type of token
			/// </pre>
			/// <code>optional string trueCase = 52;</code>
			/// </summary>
			public bool HasTrueCase()
			{
				return ((bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary>
			/// <pre>
			/// true case type of token
			/// </pre>
			/// <code>optional string trueCase = 52;</code>
			/// </summary>
			public string GetTrueCase()
			{
				object @ref = trueCase_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						trueCase_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// true case type of token
			/// </pre>
			/// <code>optional string trueCase = 52;</code>
			/// </summary>
			public ByteString GetTrueCaseBytes()
			{
				object @ref = trueCase_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					trueCase_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int TruecasetextFieldNumber = 53;

			private volatile object trueCaseText_;

			/// <summary>
			/// <pre>
			/// true case gloss of token
			/// </pre>
			/// <code>optional string trueCaseText = 53;</code>
			/// </summary>
			public bool HasTrueCaseText()
			{
				return ((bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary>
			/// <pre>
			/// true case gloss of token
			/// </pre>
			/// <code>optional string trueCaseText = 53;</code>
			/// </summary>
			public string GetTrueCaseText()
			{
				object @ref = trueCaseText_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						trueCaseText_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// true case gloss of token
			/// </pre>
			/// <code>optional string trueCaseText = 53;</code>
			/// </summary>
			public ByteString GetTrueCaseTextBytes()
			{
				object @ref = trueCaseText_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					trueCaseText_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ChinesecharFieldNumber = 54;

			private volatile object chineseChar_;

			/// <summary>
			/// <pre>
			/// Chinese character info
			/// </pre>
			/// <code>optional string chineseChar = 54;</code>
			/// </summary>
			public bool HasChineseChar()
			{
				return ((bitField1_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
			}

			/// <summary>
			/// <pre>
			/// Chinese character info
			/// </pre>
			/// <code>optional string chineseChar = 54;</code>
			/// </summary>
			public string GetChineseChar()
			{
				object @ref = chineseChar_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						chineseChar_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Chinese character info
			/// </pre>
			/// <code>optional string chineseChar = 54;</code>
			/// </summary>
			public ByteString GetChineseCharBytes()
			{
				object @ref = chineseChar_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					chineseChar_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ChinesesegFieldNumber = 55;

			private volatile object chineseSeg_;

			/// <summary><code>optional string chineseSeg = 55;</code></summary>
			public bool HasChineseSeg()
			{
				return ((bitField1_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
			}

			/// <summary><code>optional string chineseSeg = 55;</code></summary>
			public string GetChineseSeg()
			{
				object @ref = chineseSeg_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						chineseSeg_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string chineseSeg = 55;</code></summary>
			public ByteString GetChineseSegBytes()
			{
				object @ref = chineseSeg_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					chineseSeg_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ChinesexmlcharFieldNumber = 60;

			private volatile object chineseXMLChar_;

			/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
			public bool HasChineseXMLChar()
			{
				return ((bitField1_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
			}

			/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
			public string GetChineseXMLChar()
			{
				object @ref = chineseXMLChar_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						chineseXMLChar_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
			public ByteString GetChineseXMLCharBytes()
			{
				object @ref = chineseXMLChar_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					chineseXMLChar_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectionnameFieldNumber = 56;

			private volatile object sectionName_;

			/// <summary>
			/// <pre>
			/// Section info
			/// </pre>
			/// <code>optional string sectionName = 56;</code>
			/// </summary>
			public bool HasSectionName()
			{
				return ((bitField1_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
			}

			/// <summary>
			/// <pre>
			/// Section info
			/// </pre>
			/// <code>optional string sectionName = 56;</code>
			/// </summary>
			public string GetSectionName()
			{
				object @ref = sectionName_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sectionName_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Section info
			/// </pre>
			/// <code>optional string sectionName = 56;</code>
			/// </summary>
			public ByteString GetSectionNameBytes()
			{
				object @ref = sectionName_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sectionName_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectionauthorFieldNumber = 57;

			private volatile object sectionAuthor_;

			/// <summary><code>optional string sectionAuthor = 57;</code></summary>
			public bool HasSectionAuthor()
			{
				return ((bitField1_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
			}

			/// <summary><code>optional string sectionAuthor = 57;</code></summary>
			public string GetSectionAuthor()
			{
				object @ref = sectionAuthor_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sectionAuthor_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string sectionAuthor = 57;</code></summary>
			public ByteString GetSectionAuthorBytes()
			{
				object @ref = sectionAuthor_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sectionAuthor_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectiondateFieldNumber = 58;

			private volatile object sectionDate_;

			/// <summary><code>optional string sectionDate = 58;</code></summary>
			public bool HasSectionDate()
			{
				return ((bitField1_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
			}

			/// <summary><code>optional string sectionDate = 58;</code></summary>
			public string GetSectionDate()
			{
				object @ref = sectionDate_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sectionDate_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string sectionDate = 58;</code></summary>
			public ByteString GetSectionDateBytes()
			{
				object @ref = sectionDate_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sectionDate_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SectionendlabelFieldNumber = 59;

			private volatile object sectionEndLabel_;

			/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
			public bool HasSectionEndLabel()
			{
				return ((bitField1_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
			}

			/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
			public string GetSectionEndLabel()
			{
				object @ref = sectionEndLabel_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						sectionEndLabel_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
			public ByteString GetSectionEndLabelBytes()
			{
				object @ref = sectionEndLabel_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					sectionEndLabel_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ParentFieldNumber = 61;

			private volatile object parent_;

			/// <summary>
			/// <pre>
			/// French tokens have parents
			/// </pre>
			/// <code>optional string parent = 61;</code>
			/// </summary>
			public bool HasParent()
			{
				return ((bitField1_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
			}

			/// <summary>
			/// <pre>
			/// French tokens have parents
			/// </pre>
			/// <code>optional string parent = 61;</code>
			/// </summary>
			public string GetParent()
			{
				object @ref = parent_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						parent_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// French tokens have parents
			/// </pre>
			/// <code>optional string parent = 61;</code>
			/// </summary>
			public ByteString GetParentBytes()
			{
				object @ref = parent_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					parent_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int CorefmentionindexFieldNumber = 64;

			private IList<int> corefMentionIndex_;

			/// <summary>
			/// <pre>
			/// mention index info
			/// </pre>
			/// <code>repeated uint32 corefMentionIndex = 64;</code>
			/// </summary>
			public IList<int> GetCorefMentionIndexList()
			{
				return corefMentionIndex_;
			}

			/// <summary>
			/// <pre>
			/// mention index info
			/// </pre>
			/// <code>repeated uint32 corefMentionIndex = 64;</code>
			/// </summary>
			public int GetCorefMentionIndexCount()
			{
				return corefMentionIndex_.Count;
			}

			/// <summary>
			/// <pre>
			/// mention index info
			/// </pre>
			/// <code>repeated uint32 corefMentionIndex = 64;</code>
			/// </summary>
			public int GetCorefMentionIndex(int index)
			{
				return corefMentionIndex_[index];
			}

			public const int EntitymentionindexFieldNumber = 65;

			private int entityMentionIndex_;

			/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
			public bool HasEntityMentionIndex()
			{
				return ((bitField1_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
			}

			/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
			public int GetEntityMentionIndex()
			{
				return entityMentionIndex_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (HasOperator())
				{
					if (!GetOperator().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasPolarity())
				{
					if (!GetPolarity().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasSpan())
				{
					if (!GetSpan().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (HasConllUTokenSpan())
				{
					if (!GetConllUTokenSpan().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (!ExtensionsAreInitialized())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				GeneratedMessageV3.ExtendableMessage.ExtensionWriter extensionWriter = NewExtensionWriter();
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 1, word_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					GeneratedMessageV3.WriteString(output, 2, pos_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 3, value_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					GeneratedMessageV3.WriteString(output, 4, category_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					GeneratedMessageV3.WriteString(output, 5, before_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					GeneratedMessageV3.WriteString(output, 6, after_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					GeneratedMessageV3.WriteString(output, 7, originalText_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					GeneratedMessageV3.WriteString(output, 8, ner_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					GeneratedMessageV3.WriteString(output, 9, normalizedNER_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					GeneratedMessageV3.WriteString(output, 10, lemma_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					output.WriteUInt32(11, beginChar_);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					output.WriteUInt32(12, endChar_);
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					output.WriteUInt32(13, utterance_);
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					GeneratedMessageV3.WriteString(output, 14, speaker_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					output.WriteUInt32(15, beginIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					output.WriteUInt32(16, endIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					output.WriteUInt32(17, tokenBeginIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					output.WriteUInt32(18, tokenEndIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					output.WriteMessage(19, GetTimexValue());
				}
				if (((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
				{
					output.WriteBool(21, hasXmlContext_);
				}
				for (int i = 0; i < xmlContext_.Count; i++)
				{
					GeneratedMessageV3.WriteString(output, 22, xmlContext_.GetRaw(i));
				}
				if (((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
				{
					output.WriteUInt32(23, corefClusterID_);
				}
				if (((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
				{
					GeneratedMessageV3.WriteString(output, 24, answer_);
				}
				if (((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
				{
					output.WriteUInt32(26, headWordIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
				{
					output.WriteMessage(27, GetOperator());
				}
				if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
				{
					output.WriteMessage(28, GetPolarity());
				}
				if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
				{
					output.WriteMessage(29, GetSpan());
				}
				if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
				{
					GeneratedMessageV3.WriteString(output, 30, sentiment_);
				}
				if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
				{
					output.WriteInt32(31, quotationIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
				{
					output.WriteMessage(32, GetConllUFeatures());
				}
				if (((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 33, coarseTag_);
				}
				if (((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteMessage(34, GetConllUTokenSpan());
				}
				if (((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 35, conllUMisc_);
				}
				if (((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteMessage(36, GetConllUSecondaryDeps());
				}
				if (((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					GeneratedMessageV3.WriteString(output, 37, wikipediaEntity_);
				}
				if (((bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteBool(38, isNewline_);
				}
				if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
				{
					GeneratedMessageV3.WriteString(output, 39, polarityDir_);
				}
				if (((bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					GeneratedMessageV3.WriteString(output, 51, gender_);
				}
				if (((bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					GeneratedMessageV3.WriteString(output, 52, trueCase_);
				}
				if (((bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					GeneratedMessageV3.WriteString(output, 53, trueCaseText_);
				}
				if (((bitField1_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					GeneratedMessageV3.WriteString(output, 54, chineseChar_);
				}
				if (((bitField1_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					GeneratedMessageV3.WriteString(output, 55, chineseSeg_);
				}
				if (((bitField1_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					GeneratedMessageV3.WriteString(output, 56, sectionName_);
				}
				if (((bitField1_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					GeneratedMessageV3.WriteString(output, 57, sectionAuthor_);
				}
				if (((bitField1_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					GeneratedMessageV3.WriteString(output, 58, sectionDate_);
				}
				if (((bitField1_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					GeneratedMessageV3.WriteString(output, 59, sectionEndLabel_);
				}
				if (((bitField1_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					GeneratedMessageV3.WriteString(output, 60, chineseXMLChar_);
				}
				if (((bitField1_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					GeneratedMessageV3.WriteString(output, 61, parent_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					GeneratedMessageV3.WriteString(output, 62, coarseNER_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					GeneratedMessageV3.WriteString(output, 63, fineGrainedNER_);
				}
				for (int i_1 = 0; i_1 < corefMentionIndex_.Count; i_1++)
				{
					output.WriteUInt32(64, corefMentionIndex_[i_1]);
				}
				if (((bitField1_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					output.WriteUInt32(65, entityMentionIndex_);
				}
				extensionWriter.WriteUntil(256, output);
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, word_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += GeneratedMessageV3.ComputeStringSize(2, pos_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(3, value_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += GeneratedMessageV3.ComputeStringSize(4, category_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += GeneratedMessageV3.ComputeStringSize(5, before_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += GeneratedMessageV3.ComputeStringSize(6, after_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += GeneratedMessageV3.ComputeStringSize(7, originalText_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += GeneratedMessageV3.ComputeStringSize(8, ner_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					size += GeneratedMessageV3.ComputeStringSize(9, normalizedNER_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					size += GeneratedMessageV3.ComputeStringSize(10, lemma_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(11, beginChar_);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(12, endChar_);
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(13, utterance_);
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(14, speaker_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(15, beginIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(16, endIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(17, tokenBeginIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(18, tokenEndIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					size += CodedOutputStream.ComputeMessageSize(19, GetTimexValue());
				}
				if (((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
				{
					size += CodedOutputStream.ComputeBoolSize(21, hasXmlContext_);
				}
				{
					int dataSize = 0;
					for (int i = 0; i < xmlContext_.Count; i++)
					{
						dataSize += ComputeStringSizeNoTag(xmlContext_.GetRaw(i));
					}
					size += dataSize;
					size += 2 * GetXmlContextList().Count;
				}
				if (((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(23, corefClusterID_);
				}
				if (((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(24, answer_);
				}
				if (((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(26, headWordIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(27, GetOperator());
				}
				if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(28, GetPolarity());
				}
				if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(29, GetSpan());
				}
				if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(30, sentiment_);
				}
				if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
				{
					size += CodedOutputStream.ComputeInt32Size(31, quotationIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(32, GetConllUFeatures());
				}
				if (((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(33, coarseTag_);
				}
				if (((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeMessageSize(34, GetConllUTokenSpan());
				}
				if (((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(35, conllUMisc_);
				}
				if (((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeMessageSize(36, GetConllUSecondaryDeps());
				}
				if (((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += GeneratedMessageV3.ComputeStringSize(37, wikipediaEntity_);
				}
				if (((bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeBoolSize(38, isNewline_);
				}
				if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(39, polarityDir_);
				}
				if (((bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += GeneratedMessageV3.ComputeStringSize(51, gender_);
				}
				if (((bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += GeneratedMessageV3.ComputeStringSize(52, trueCase_);
				}
				if (((bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += GeneratedMessageV3.ComputeStringSize(53, trueCaseText_);
				}
				if (((bitField1_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					size += GeneratedMessageV3.ComputeStringSize(54, chineseChar_);
				}
				if (((bitField1_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					size += GeneratedMessageV3.ComputeStringSize(55, chineseSeg_);
				}
				if (((bitField1_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(56, sectionName_);
				}
				if (((bitField1_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(57, sectionAuthor_);
				}
				if (((bitField1_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(58, sectionDate_);
				}
				if (((bitField1_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(59, sectionEndLabel_);
				}
				if (((bitField1_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					size += GeneratedMessageV3.ComputeStringSize(60, chineseXMLChar_);
				}
				if (((bitField1_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(61, parent_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += GeneratedMessageV3.ComputeStringSize(62, coarseNER_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					size += GeneratedMessageV3.ComputeStringSize(63, fineGrainedNER_);
				}
				{
					int dataSize = 0;
					for (int i = 0; i < corefMentionIndex_.Count; i++)
					{
						dataSize += CodedOutputStream.ComputeUInt32SizeNoTag(corefMentionIndex_[i]);
					}
					size += dataSize;
					size += 2 * GetCorefMentionIndexList().Count;
				}
				if (((bitField1_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(65, entityMentionIndex_);
				}
				size += ExtensionsSerializedSize();
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Token))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Token other = (CoreNLPProtos.Token)obj;
				bool result = true;
				result = result && (HasWord() == other.HasWord());
				if (HasWord())
				{
					result = result && GetWord().Equals(other.GetWord());
				}
				result = result && (HasPos() == other.HasPos());
				if (HasPos())
				{
					result = result && GetPos().Equals(other.GetPos());
				}
				result = result && (HasValue() == other.HasValue());
				if (HasValue())
				{
					result = result && GetValue().Equals(other.GetValue());
				}
				result = result && (HasCategory() == other.HasCategory());
				if (HasCategory())
				{
					result = result && GetCategory().Equals(other.GetCategory());
				}
				result = result && (HasBefore() == other.HasBefore());
				if (HasBefore())
				{
					result = result && GetBefore().Equals(other.GetBefore());
				}
				result = result && (HasAfter() == other.HasAfter());
				if (HasAfter())
				{
					result = result && GetAfter().Equals(other.GetAfter());
				}
				result = result && (HasOriginalText() == other.HasOriginalText());
				if (HasOriginalText())
				{
					result = result && GetOriginalText().Equals(other.GetOriginalText());
				}
				result = result && (HasNer() == other.HasNer());
				if (HasNer())
				{
					result = result && GetNer().Equals(other.GetNer());
				}
				result = result && (HasCoarseNER() == other.HasCoarseNER());
				if (HasCoarseNER())
				{
					result = result && GetCoarseNER().Equals(other.GetCoarseNER());
				}
				result = result && (HasFineGrainedNER() == other.HasFineGrainedNER());
				if (HasFineGrainedNER())
				{
					result = result && GetFineGrainedNER().Equals(other.GetFineGrainedNER());
				}
				result = result && (HasNormalizedNER() == other.HasNormalizedNER());
				if (HasNormalizedNER())
				{
					result = result && GetNormalizedNER().Equals(other.GetNormalizedNER());
				}
				result = result && (HasLemma() == other.HasLemma());
				if (HasLemma())
				{
					result = result && GetLemma().Equals(other.GetLemma());
				}
				result = result && (HasBeginChar() == other.HasBeginChar());
				if (HasBeginChar())
				{
					result = result && (GetBeginChar() == other.GetBeginChar());
				}
				result = result && (HasEndChar() == other.HasEndChar());
				if (HasEndChar())
				{
					result = result && (GetEndChar() == other.GetEndChar());
				}
				result = result && (HasUtterance() == other.HasUtterance());
				if (HasUtterance())
				{
					result = result && (GetUtterance() == other.GetUtterance());
				}
				result = result && (HasSpeaker() == other.HasSpeaker());
				if (HasSpeaker())
				{
					result = result && GetSpeaker().Equals(other.GetSpeaker());
				}
				result = result && (HasBeginIndex() == other.HasBeginIndex());
				if (HasBeginIndex())
				{
					result = result && (GetBeginIndex() == other.GetBeginIndex());
				}
				result = result && (HasEndIndex() == other.HasEndIndex());
				if (HasEndIndex())
				{
					result = result && (GetEndIndex() == other.GetEndIndex());
				}
				result = result && (HasTokenBeginIndex() == other.HasTokenBeginIndex());
				if (HasTokenBeginIndex())
				{
					result = result && (GetTokenBeginIndex() == other.GetTokenBeginIndex());
				}
				result = result && (HasTokenEndIndex() == other.HasTokenEndIndex());
				if (HasTokenEndIndex())
				{
					result = result && (GetTokenEndIndex() == other.GetTokenEndIndex());
				}
				result = result && (HasTimexValue() == other.HasTimexValue());
				if (HasTimexValue())
				{
					result = result && GetTimexValue().Equals(other.GetTimexValue());
				}
				result = result && (HasHasXmlContext() == other.HasHasXmlContext());
				if (HasHasXmlContext())
				{
					result = result && (GetHasXmlContext() == other.GetHasXmlContext());
				}
				result = result && GetXmlContextList().Equals(other.GetXmlContextList());
				result = result && (HasCorefClusterID() == other.HasCorefClusterID());
				if (HasCorefClusterID())
				{
					result = result && (GetCorefClusterID() == other.GetCorefClusterID());
				}
				result = result && (HasAnswer() == other.HasAnswer());
				if (HasAnswer())
				{
					result = result && GetAnswer().Equals(other.GetAnswer());
				}
				result = result && (HasHeadWordIndex() == other.HasHeadWordIndex());
				if (HasHeadWordIndex())
				{
					result = result && (GetHeadWordIndex() == other.GetHeadWordIndex());
				}
				result = result && (HasOperator() == other.HasOperator());
				if (HasOperator())
				{
					result = result && GetOperator().Equals(other.GetOperator());
				}
				result = result && (HasPolarity() == other.HasPolarity());
				if (HasPolarity())
				{
					result = result && GetPolarity().Equals(other.GetPolarity());
				}
				result = result && (HasPolarityDir() == other.HasPolarityDir());
				if (HasPolarityDir())
				{
					result = result && GetPolarityDir().Equals(other.GetPolarityDir());
				}
				result = result && (HasSpan() == other.HasSpan());
				if (HasSpan())
				{
					result = result && GetSpan().Equals(other.GetSpan());
				}
				result = result && (HasSentiment() == other.HasSentiment());
				if (HasSentiment())
				{
					result = result && GetSentiment().Equals(other.GetSentiment());
				}
				result = result && (HasQuotationIndex() == other.HasQuotationIndex());
				if (HasQuotationIndex())
				{
					result = result && (GetQuotationIndex() == other.GetQuotationIndex());
				}
				result = result && (HasConllUFeatures() == other.HasConllUFeatures());
				if (HasConllUFeatures())
				{
					result = result && GetConllUFeatures().Equals(other.GetConllUFeatures());
				}
				result = result && (HasCoarseTag() == other.HasCoarseTag());
				if (HasCoarseTag())
				{
					result = result && GetCoarseTag().Equals(other.GetCoarseTag());
				}
				result = result && (HasConllUTokenSpan() == other.HasConllUTokenSpan());
				if (HasConllUTokenSpan())
				{
					result = result && GetConllUTokenSpan().Equals(other.GetConllUTokenSpan());
				}
				result = result && (HasConllUMisc() == other.HasConllUMisc());
				if (HasConllUMisc())
				{
					result = result && GetConllUMisc().Equals(other.GetConllUMisc());
				}
				result = result && (HasConllUSecondaryDeps() == other.HasConllUSecondaryDeps());
				if (HasConllUSecondaryDeps())
				{
					result = result && GetConllUSecondaryDeps().Equals(other.GetConllUSecondaryDeps());
				}
				result = result && (HasWikipediaEntity() == other.HasWikipediaEntity());
				if (HasWikipediaEntity())
				{
					result = result && GetWikipediaEntity().Equals(other.GetWikipediaEntity());
				}
				result = result && (HasIsNewline() == other.HasIsNewline());
				if (HasIsNewline())
				{
					result = result && (GetIsNewline() == other.GetIsNewline());
				}
				result = result && (HasGender() == other.HasGender());
				if (HasGender())
				{
					result = result && GetGender().Equals(other.GetGender());
				}
				result = result && (HasTrueCase() == other.HasTrueCase());
				if (HasTrueCase())
				{
					result = result && GetTrueCase().Equals(other.GetTrueCase());
				}
				result = result && (HasTrueCaseText() == other.HasTrueCaseText());
				if (HasTrueCaseText())
				{
					result = result && GetTrueCaseText().Equals(other.GetTrueCaseText());
				}
				result = result && (HasChineseChar() == other.HasChineseChar());
				if (HasChineseChar())
				{
					result = result && GetChineseChar().Equals(other.GetChineseChar());
				}
				result = result && (HasChineseSeg() == other.HasChineseSeg());
				if (HasChineseSeg())
				{
					result = result && GetChineseSeg().Equals(other.GetChineseSeg());
				}
				result = result && (HasChineseXMLChar() == other.HasChineseXMLChar());
				if (HasChineseXMLChar())
				{
					result = result && GetChineseXMLChar().Equals(other.GetChineseXMLChar());
				}
				result = result && (HasSectionName() == other.HasSectionName());
				if (HasSectionName())
				{
					result = result && GetSectionName().Equals(other.GetSectionName());
				}
				result = result && (HasSectionAuthor() == other.HasSectionAuthor());
				if (HasSectionAuthor())
				{
					result = result && GetSectionAuthor().Equals(other.GetSectionAuthor());
				}
				result = result && (HasSectionDate() == other.HasSectionDate());
				if (HasSectionDate())
				{
					result = result && GetSectionDate().Equals(other.GetSectionDate());
				}
				result = result && (HasSectionEndLabel() == other.HasSectionEndLabel());
				if (HasSectionEndLabel())
				{
					result = result && GetSectionEndLabel().Equals(other.GetSectionEndLabel());
				}
				result = result && (HasParent() == other.HasParent());
				if (HasParent())
				{
					result = result && GetParent().Equals(other.GetParent());
				}
				result = result && GetCorefMentionIndexList().Equals(other.GetCorefMentionIndexList());
				result = result && (HasEntityMentionIndex() == other.HasEntityMentionIndex());
				if (HasEntityMentionIndex())
				{
					result = result && (GetEntityMentionIndex() == other.GetEntityMentionIndex());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				result = result && GetExtensionFields().Equals(other.GetExtensionFields());
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasWord())
				{
					hash = (37 * hash) + WordFieldNumber;
					hash = (53 * hash) + GetWord().GetHashCode();
				}
				if (HasPos())
				{
					hash = (37 * hash) + PosFieldNumber;
					hash = (53 * hash) + GetPos().GetHashCode();
				}
				if (HasValue())
				{
					hash = (37 * hash) + ValueFieldNumber;
					hash = (53 * hash) + GetValue().GetHashCode();
				}
				if (HasCategory())
				{
					hash = (37 * hash) + CategoryFieldNumber;
					hash = (53 * hash) + GetCategory().GetHashCode();
				}
				if (HasBefore())
				{
					hash = (37 * hash) + BeforeFieldNumber;
					hash = (53 * hash) + GetBefore().GetHashCode();
				}
				if (HasAfter())
				{
					hash = (37 * hash) + AfterFieldNumber;
					hash = (53 * hash) + GetAfter().GetHashCode();
				}
				if (HasOriginalText())
				{
					hash = (37 * hash) + OriginaltextFieldNumber;
					hash = (53 * hash) + GetOriginalText().GetHashCode();
				}
				if (HasNer())
				{
					hash = (37 * hash) + NerFieldNumber;
					hash = (53 * hash) + GetNer().GetHashCode();
				}
				if (HasCoarseNER())
				{
					hash = (37 * hash) + CoarsenerFieldNumber;
					hash = (53 * hash) + GetCoarseNER().GetHashCode();
				}
				if (HasFineGrainedNER())
				{
					hash = (37 * hash) + FinegrainednerFieldNumber;
					hash = (53 * hash) + GetFineGrainedNER().GetHashCode();
				}
				if (HasNormalizedNER())
				{
					hash = (37 * hash) + NormalizednerFieldNumber;
					hash = (53 * hash) + GetNormalizedNER().GetHashCode();
				}
				if (HasLemma())
				{
					hash = (37 * hash) + LemmaFieldNumber;
					hash = (53 * hash) + GetLemma().GetHashCode();
				}
				if (HasBeginChar())
				{
					hash = (37 * hash) + BegincharFieldNumber;
					hash = (53 * hash) + GetBeginChar();
				}
				if (HasEndChar())
				{
					hash = (37 * hash) + EndcharFieldNumber;
					hash = (53 * hash) + GetEndChar();
				}
				if (HasUtterance())
				{
					hash = (37 * hash) + UtteranceFieldNumber;
					hash = (53 * hash) + GetUtterance();
				}
				if (HasSpeaker())
				{
					hash = (37 * hash) + SpeakerFieldNumber;
					hash = (53 * hash) + GetSpeaker().GetHashCode();
				}
				if (HasBeginIndex())
				{
					hash = (37 * hash) + BeginindexFieldNumber;
					hash = (53 * hash) + GetBeginIndex();
				}
				if (HasEndIndex())
				{
					hash = (37 * hash) + EndindexFieldNumber;
					hash = (53 * hash) + GetEndIndex();
				}
				if (HasTokenBeginIndex())
				{
					hash = (37 * hash) + TokenbeginindexFieldNumber;
					hash = (53 * hash) + GetTokenBeginIndex();
				}
				if (HasTokenEndIndex())
				{
					hash = (37 * hash) + TokenendindexFieldNumber;
					hash = (53 * hash) + GetTokenEndIndex();
				}
				if (HasTimexValue())
				{
					hash = (37 * hash) + TimexvalueFieldNumber;
					hash = (53 * hash) + GetTimexValue().GetHashCode();
				}
				if (HasHasXmlContext())
				{
					hash = (37 * hash) + HasxmlcontextFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasXmlContext());
				}
				if (GetXmlContextCount() > 0)
				{
					hash = (37 * hash) + XmlcontextFieldNumber;
					hash = (53 * hash) + GetXmlContextList().GetHashCode();
				}
				if (HasCorefClusterID())
				{
					hash = (37 * hash) + CorefclusteridFieldNumber;
					hash = (53 * hash) + GetCorefClusterID();
				}
				if (HasAnswer())
				{
					hash = (37 * hash) + AnswerFieldNumber;
					hash = (53 * hash) + GetAnswer().GetHashCode();
				}
				if (HasHeadWordIndex())
				{
					hash = (37 * hash) + HeadwordindexFieldNumber;
					hash = (53 * hash) + GetHeadWordIndex();
				}
				if (HasOperator())
				{
					hash = (37 * hash) + OperatorFieldNumber;
					hash = (53 * hash) + GetOperator().GetHashCode();
				}
				if (HasPolarity())
				{
					hash = (37 * hash) + PolarityFieldNumber;
					hash = (53 * hash) + GetPolarity().GetHashCode();
				}
				if (HasPolarityDir())
				{
					hash = (37 * hash) + PolarityDirFieldNumber;
					hash = (53 * hash) + GetPolarityDir().GetHashCode();
				}
				if (HasSpan())
				{
					hash = (37 * hash) + SpanFieldNumber;
					hash = (53 * hash) + GetSpan().GetHashCode();
				}
				if (HasSentiment())
				{
					hash = (37 * hash) + SentimentFieldNumber;
					hash = (53 * hash) + GetSentiment().GetHashCode();
				}
				if (HasQuotationIndex())
				{
					hash = (37 * hash) + QuotationindexFieldNumber;
					hash = (53 * hash) + GetQuotationIndex();
				}
				if (HasConllUFeatures())
				{
					hash = (37 * hash) + ConllufeaturesFieldNumber;
					hash = (53 * hash) + GetConllUFeatures().GetHashCode();
				}
				if (HasCoarseTag())
				{
					hash = (37 * hash) + CoarsetagFieldNumber;
					hash = (53 * hash) + GetCoarseTag().GetHashCode();
				}
				if (HasConllUTokenSpan())
				{
					hash = (37 * hash) + ConllutokenspanFieldNumber;
					hash = (53 * hash) + GetConllUTokenSpan().GetHashCode();
				}
				if (HasConllUMisc())
				{
					hash = (37 * hash) + ConllumiscFieldNumber;
					hash = (53 * hash) + GetConllUMisc().GetHashCode();
				}
				if (HasConllUSecondaryDeps())
				{
					hash = (37 * hash) + ConllusecondarydepsFieldNumber;
					hash = (53 * hash) + GetConllUSecondaryDeps().GetHashCode();
				}
				if (HasWikipediaEntity())
				{
					hash = (37 * hash) + WikipediaentityFieldNumber;
					hash = (53 * hash) + GetWikipediaEntity().GetHashCode();
				}
				if (HasIsNewline())
				{
					hash = (37 * hash) + IsnewlineFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetIsNewline());
				}
				if (HasGender())
				{
					hash = (37 * hash) + GenderFieldNumber;
					hash = (53 * hash) + GetGender().GetHashCode();
				}
				if (HasTrueCase())
				{
					hash = (37 * hash) + TruecaseFieldNumber;
					hash = (53 * hash) + GetTrueCase().GetHashCode();
				}
				if (HasTrueCaseText())
				{
					hash = (37 * hash) + TruecasetextFieldNumber;
					hash = (53 * hash) + GetTrueCaseText().GetHashCode();
				}
				if (HasChineseChar())
				{
					hash = (37 * hash) + ChinesecharFieldNumber;
					hash = (53 * hash) + GetChineseChar().GetHashCode();
				}
				if (HasChineseSeg())
				{
					hash = (37 * hash) + ChinesesegFieldNumber;
					hash = (53 * hash) + GetChineseSeg().GetHashCode();
				}
				if (HasChineseXMLChar())
				{
					hash = (37 * hash) + ChinesexmlcharFieldNumber;
					hash = (53 * hash) + GetChineseXMLChar().GetHashCode();
				}
				if (HasSectionName())
				{
					hash = (37 * hash) + SectionnameFieldNumber;
					hash = (53 * hash) + GetSectionName().GetHashCode();
				}
				if (HasSectionAuthor())
				{
					hash = (37 * hash) + SectionauthorFieldNumber;
					hash = (53 * hash) + GetSectionAuthor().GetHashCode();
				}
				if (HasSectionDate())
				{
					hash = (37 * hash) + SectiondateFieldNumber;
					hash = (53 * hash) + GetSectionDate().GetHashCode();
				}
				if (HasSectionEndLabel())
				{
					hash = (37 * hash) + SectionendlabelFieldNumber;
					hash = (53 * hash) + GetSectionEndLabel().GetHashCode();
				}
				if (HasParent())
				{
					hash = (37 * hash) + ParentFieldNumber;
					hash = (53 * hash) + GetParent().GetHashCode();
				}
				if (GetCorefMentionIndexCount() > 0)
				{
					hash = (37 * hash) + CorefmentionindexFieldNumber;
					hash = (53 * hash) + GetCorefMentionIndexList().GetHashCode();
				}
				if (HasEntityMentionIndex())
				{
					hash = (37 * hash) + EntitymentionindexFieldNumber;
					hash = (53 * hash) + GetEntityMentionIndex();
				}
				hash = HashFields(hash, GetExtensionFields());
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Token ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Token ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Token ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Token ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Token ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Token ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Token ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Token ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Token ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Token ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Token.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Token.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Token.Builder NewBuilder(CoreNLPProtos.Token prototype)
			{
				return ((CoreNLPProtos.Token.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Token.Builder() : new CoreNLPProtos.Token.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Token.Builder builder = new CoreNLPProtos.Token.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// The serialized version of a Token (a CoreLabel).
			/// </summary>
			/// <remarks>
			/// <pre>
			/// The serialized version of a Token (a CoreLabel).
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Token</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.ExtendableBuilder<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder>, CoreNLPProtos.ITokenOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Token)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Token_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Token_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Token), typeof(CoreNLPProtos.Token.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Token.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetTimexValueFieldBuilder();
						GetOperatorFieldBuilder();
						GetPolarityFieldBuilder();
						GetSpanFieldBuilder();
						GetConllUFeaturesFieldBuilder();
						GetConllUTokenSpanFieldBuilder();
						GetConllUSecondaryDepsFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					word_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					pos_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					value_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					category_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					before_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					after_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					originalText_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					ner_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					coarseNER_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					fineGrainedNER_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					normalizedNER_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					lemma_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					beginChar_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					endChar_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					utterance_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					speaker_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					beginIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					endIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					tokenBeginIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
					tokenEndIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					if (timexValueBuilder_ == null)
					{
						timexValue_ = null;
					}
					else
					{
						timexValueBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					hasXmlContext_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
					xmlContext_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
					corefClusterID_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00800000)));
					answer_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x01000000)));
					headWordIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x02000000)));
					if (operatorBuilder_ == null)
					{
						operator_ = null;
					}
					else
					{
						operatorBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
					if (polarityBuilder_ == null)
					{
						polarity_ = null;
					}
					else
					{
						polarityBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
					polarityDir_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x10000000)));
					if (spanBuilder_ == null)
					{
						span_ = null;
					}
					else
					{
						spanBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
					sentiment_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
					quotationIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x80000000)));
					if (conllUFeaturesBuilder_ == null)
					{
						conllUFeatures_ = null;
					}
					else
					{
						conllUFeaturesBuilder_.Clear();
					}
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
					coarseTag_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
					if (conllUTokenSpanBuilder_ == null)
					{
						conllUTokenSpan_ = null;
					}
					else
					{
						conllUTokenSpanBuilder_.Clear();
					}
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
					conllUMisc_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
					if (conllUSecondaryDepsBuilder_ == null)
					{
						conllUSecondaryDeps_ = null;
					}
					else
					{
						conllUSecondaryDepsBuilder_.Clear();
					}
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
					wikipediaEntity_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
					isNewline_ = false;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
					gender_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
					trueCase_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
					trueCaseText_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000200)));
					chineseChar_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000400)));
					chineseSeg_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000800)));
					chineseXMLChar_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00001000)));
					sectionName_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00002000)));
					sectionAuthor_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00004000)));
					sectionDate_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00008000)));
					sectionEndLabel_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00010000)));
					parent_ = string.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00020000)));
					corefMentionIndex_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00040000)));
					entityMentionIndex_ = 0;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00080000)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Token_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Token.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Token result = ((CoreNLPProtos.Token)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Token result = new CoreNLPProtos.Token(this);
					int from_bitField0_ = bitField0_;
					int from_bitField1_ = bitField1_;
					int to_bitField0_ = 0;
					int to_bitField1_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.word_ = word_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.pos_ = pos_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.value_ = value_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.category_ = category_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.before_ = before_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.after_ = after_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.originalText_ = originalText_;
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					result.ner_ = ner_;
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000100));
					}
					result.coarseNER_ = coarseNER_;
					if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x00000200));
					}
					result.fineGrainedNER_ = fineGrainedNER_;
					if (((from_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x00000400));
					}
					result.normalizedNER_ = normalizedNER_;
					if (((from_bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField0_ |= unchecked((int)(0x00000800));
					}
					result.lemma_ = lemma_;
					if (((from_bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
					{
						to_bitField0_ |= unchecked((int)(0x00001000));
					}
					result.beginChar_ = beginChar_;
					if (((from_bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
					{
						to_bitField0_ |= unchecked((int)(0x00002000));
					}
					result.endChar_ = endChar_;
					if (((from_bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
					{
						to_bitField0_ |= unchecked((int)(0x00004000));
					}
					result.utterance_ = utterance_;
					if (((from_bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
					{
						to_bitField0_ |= unchecked((int)(0x00008000));
					}
					result.speaker_ = speaker_;
					if (((from_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						to_bitField0_ |= unchecked((int)(0x00010000));
					}
					result.beginIndex_ = beginIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						to_bitField0_ |= unchecked((int)(0x00020000));
					}
					result.endIndex_ = endIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						to_bitField0_ |= unchecked((int)(0x00040000));
					}
					result.tokenBeginIndex_ = tokenBeginIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
					{
						to_bitField0_ |= unchecked((int)(0x00080000));
					}
					result.tokenEndIndex_ = tokenEndIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
					{
						to_bitField0_ |= unchecked((int)(0x00100000));
					}
					if (timexValueBuilder_ == null)
					{
						result.timexValue_ = timexValue_;
					}
					else
					{
						result.timexValue_ = timexValueBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
					{
						to_bitField0_ |= unchecked((int)(0x00200000));
					}
					result.hasXmlContext_ = hasXmlContext_;
					if (((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
					{
						xmlContext_ = xmlContext_.GetUnmodifiableView();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
					}
					result.xmlContext_ = xmlContext_;
					if (((from_bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
					{
						to_bitField0_ |= unchecked((int)(0x00400000));
					}
					result.corefClusterID_ = corefClusterID_;
					if (((from_bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
					{
						to_bitField0_ |= unchecked((int)(0x00800000));
					}
					result.answer_ = answer_;
					if (((from_bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
					{
						to_bitField0_ |= unchecked((int)(0x01000000));
					}
					result.headWordIndex_ = headWordIndex_;
					if (((from_bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
					{
						to_bitField0_ |= unchecked((int)(0x02000000));
					}
					if (operatorBuilder_ == null)
					{
						result.operator_ = operator_;
					}
					else
					{
						result.operator_ = operatorBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
					{
						to_bitField0_ |= unchecked((int)(0x04000000));
					}
					if (polarityBuilder_ == null)
					{
						result.polarity_ = polarity_;
					}
					else
					{
						result.polarity_ = polarityBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
					{
						to_bitField0_ |= unchecked((int)(0x08000000));
					}
					result.polarityDir_ = polarityDir_;
					if (((from_bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
					{
						to_bitField0_ |= unchecked((int)(0x10000000));
					}
					if (spanBuilder_ == null)
					{
						result.span_ = span_;
					}
					else
					{
						result.span_ = spanBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
					{
						to_bitField0_ |= unchecked((int)(0x20000000));
					}
					result.sentiment_ = sentiment_;
					if (((from_bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
					{
						to_bitField0_ |= unchecked((int)(0x40000000));
					}
					result.quotationIndex_ = quotationIndex_;
					if (((from_bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x80000000));
					}
					if (conllUFeaturesBuilder_ == null)
					{
						result.conllUFeatures_ = conllUFeatures_;
					}
					else
					{
						result.conllUFeatures_ = conllUFeaturesBuilder_.Build();
					}
					if (((from_bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField1_ |= unchecked((int)(0x00000001));
					}
					result.coarseTag_ = coarseTag_;
					if (((from_bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField1_ |= unchecked((int)(0x00000002));
					}
					if (conllUTokenSpanBuilder_ == null)
					{
						result.conllUTokenSpan_ = conllUTokenSpan_;
					}
					else
					{
						result.conllUTokenSpan_ = conllUTokenSpanBuilder_.Build();
					}
					if (((from_bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField1_ |= unchecked((int)(0x00000004));
					}
					result.conllUMisc_ = conllUMisc_;
					if (((from_bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField1_ |= unchecked((int)(0x00000008));
					}
					if (conllUSecondaryDepsBuilder_ == null)
					{
						result.conllUSecondaryDeps_ = conllUSecondaryDeps_;
					}
					else
					{
						result.conllUSecondaryDeps_ = conllUSecondaryDepsBuilder_.Build();
					}
					if (((from_bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField1_ |= unchecked((int)(0x00000010));
					}
					result.wikipediaEntity_ = wikipediaEntity_;
					if (((from_bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField1_ |= unchecked((int)(0x00000020));
					}
					result.isNewline_ = isNewline_;
					if (((from_bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField1_ |= unchecked((int)(0x00000040));
					}
					result.gender_ = gender_;
					if (((from_bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField1_ |= unchecked((int)(0x00000080));
					}
					result.trueCase_ = trueCase_;
					if (((from_bitField1_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField1_ |= unchecked((int)(0x00000100));
					}
					result.trueCaseText_ = trueCaseText_;
					if (((from_bitField1_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField1_ |= unchecked((int)(0x00000200));
					}
					result.chineseChar_ = chineseChar_;
					if (((from_bitField1_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField1_ |= unchecked((int)(0x00000400));
					}
					result.chineseSeg_ = chineseSeg_;
					if (((from_bitField1_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
					{
						to_bitField1_ |= unchecked((int)(0x00000800));
					}
					result.chineseXMLChar_ = chineseXMLChar_;
					if (((from_bitField1_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
					{
						to_bitField1_ |= unchecked((int)(0x00001000));
					}
					result.sectionName_ = sectionName_;
					if (((from_bitField1_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
					{
						to_bitField1_ |= unchecked((int)(0x00002000));
					}
					result.sectionAuthor_ = sectionAuthor_;
					if (((from_bitField1_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
					{
						to_bitField1_ |= unchecked((int)(0x00004000));
					}
					result.sectionDate_ = sectionDate_;
					if (((from_bitField1_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						to_bitField1_ |= unchecked((int)(0x00008000));
					}
					result.sectionEndLabel_ = sectionEndLabel_;
					if (((from_bitField1_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						to_bitField1_ |= unchecked((int)(0x00010000));
					}
					result.parent_ = parent_;
					if (((bitField1_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						corefMentionIndex_ = Java.Util.Collections.UnmodifiableList(corefMentionIndex_);
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00040000)));
					}
					result.corefMentionIndex_ = corefMentionIndex_;
					if (((from_bitField1_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
					{
						to_bitField1_ |= unchecked((int)(0x00020000));
					}
					result.entityMentionIndex_ = entityMentionIndex_;
					result.bitField0_ = to_bitField0_;
					result.bitField1_ = to_bitField1_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Token.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Token.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Token.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Token.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Token.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Token.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Token.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Token.Builder SetExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Token, Type> extension, Type value)
				{
					return (CoreNLPProtos.Token.Builder)base.SetExtension(extension, value);
				}

				public override CoreNLPProtos.Token.Builder SetExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Token, IList<Type>> extension, int index, Type value)
				{
					return (CoreNLPProtos.Token.Builder)base.SetExtension(extension, index, value);
				}

				public override CoreNLPProtos.Token.Builder AddExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Token, IList<Type>> extension, Type value)
				{
					return (CoreNLPProtos.Token.Builder)base.AddExtension(extension, value);
				}

				public override CoreNLPProtos.Token.Builder ClearExtension<Type>(GeneratedMessage.GeneratedExtension<CoreNLPProtos.Token, object> extension)
				{
					return (CoreNLPProtos.Token.Builder)base.ClearExtension(extension);
				}

				public override CoreNLPProtos.Token.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Token)
					{
						return MergeFrom((CoreNLPProtos.Token)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Token.Builder MergeFrom(CoreNLPProtos.Token other)
				{
					if (other == CoreNLPProtos.Token.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasWord())
					{
						bitField0_ |= unchecked((int)(0x00000001));
						word_ = other.word_;
						OnChanged();
					}
					if (other.HasPos())
					{
						bitField0_ |= unchecked((int)(0x00000002));
						pos_ = other.pos_;
						OnChanged();
					}
					if (other.HasValue())
					{
						bitField0_ |= unchecked((int)(0x00000004));
						value_ = other.value_;
						OnChanged();
					}
					if (other.HasCategory())
					{
						bitField0_ |= unchecked((int)(0x00000008));
						category_ = other.category_;
						OnChanged();
					}
					if (other.HasBefore())
					{
						bitField0_ |= unchecked((int)(0x00000010));
						before_ = other.before_;
						OnChanged();
					}
					if (other.HasAfter())
					{
						bitField0_ |= unchecked((int)(0x00000020));
						after_ = other.after_;
						OnChanged();
					}
					if (other.HasOriginalText())
					{
						bitField0_ |= unchecked((int)(0x00000040));
						originalText_ = other.originalText_;
						OnChanged();
					}
					if (other.HasNer())
					{
						bitField0_ |= unchecked((int)(0x00000080));
						ner_ = other.ner_;
						OnChanged();
					}
					if (other.HasCoarseNER())
					{
						bitField0_ |= unchecked((int)(0x00000100));
						coarseNER_ = other.coarseNER_;
						OnChanged();
					}
					if (other.HasFineGrainedNER())
					{
						bitField0_ |= unchecked((int)(0x00000200));
						fineGrainedNER_ = other.fineGrainedNER_;
						OnChanged();
					}
					if (other.HasNormalizedNER())
					{
						bitField0_ |= unchecked((int)(0x00000400));
						normalizedNER_ = other.normalizedNER_;
						OnChanged();
					}
					if (other.HasLemma())
					{
						bitField0_ |= unchecked((int)(0x00000800));
						lemma_ = other.lemma_;
						OnChanged();
					}
					if (other.HasBeginChar())
					{
						SetBeginChar(other.GetBeginChar());
					}
					if (other.HasEndChar())
					{
						SetEndChar(other.GetEndChar());
					}
					if (other.HasUtterance())
					{
						SetUtterance(other.GetUtterance());
					}
					if (other.HasSpeaker())
					{
						bitField0_ |= unchecked((int)(0x00008000));
						speaker_ = other.speaker_;
						OnChanged();
					}
					if (other.HasBeginIndex())
					{
						SetBeginIndex(other.GetBeginIndex());
					}
					if (other.HasEndIndex())
					{
						SetEndIndex(other.GetEndIndex());
					}
					if (other.HasTokenBeginIndex())
					{
						SetTokenBeginIndex(other.GetTokenBeginIndex());
					}
					if (other.HasTokenEndIndex())
					{
						SetTokenEndIndex(other.GetTokenEndIndex());
					}
					if (other.HasTimexValue())
					{
						MergeTimexValue(other.GetTimexValue());
					}
					if (other.HasHasXmlContext())
					{
						SetHasXmlContext(other.GetHasXmlContext());
					}
					if (!other.xmlContext_.IsEmpty())
					{
						if (xmlContext_.IsEmpty())
						{
							xmlContext_ = other.xmlContext_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
						}
						else
						{
							EnsureXmlContextIsMutable();
							Sharpen.Collections.AddAll(xmlContext_, other.xmlContext_);
						}
						OnChanged();
					}
					if (other.HasCorefClusterID())
					{
						SetCorefClusterID(other.GetCorefClusterID());
					}
					if (other.HasAnswer())
					{
						bitField0_ |= unchecked((int)(0x01000000));
						answer_ = other.answer_;
						OnChanged();
					}
					if (other.HasHeadWordIndex())
					{
						SetHeadWordIndex(other.GetHeadWordIndex());
					}
					if (other.HasOperator())
					{
						MergeOperator(other.GetOperator());
					}
					if (other.HasPolarity())
					{
						MergePolarity(other.GetPolarity());
					}
					if (other.HasPolarityDir())
					{
						bitField0_ |= unchecked((int)(0x10000000));
						polarityDir_ = other.polarityDir_;
						OnChanged();
					}
					if (other.HasSpan())
					{
						MergeSpan(other.GetSpan());
					}
					if (other.HasSentiment())
					{
						bitField0_ |= unchecked((int)(0x40000000));
						sentiment_ = other.sentiment_;
						OnChanged();
					}
					if (other.HasQuotationIndex())
					{
						SetQuotationIndex(other.GetQuotationIndex());
					}
					if (other.HasConllUFeatures())
					{
						MergeConllUFeatures(other.GetConllUFeatures());
					}
					if (other.HasCoarseTag())
					{
						bitField1_ |= unchecked((int)(0x00000002));
						coarseTag_ = other.coarseTag_;
						OnChanged();
					}
					if (other.HasConllUTokenSpan())
					{
						MergeConllUTokenSpan(other.GetConllUTokenSpan());
					}
					if (other.HasConllUMisc())
					{
						bitField1_ |= unchecked((int)(0x00000008));
						conllUMisc_ = other.conllUMisc_;
						OnChanged();
					}
					if (other.HasConllUSecondaryDeps())
					{
						MergeConllUSecondaryDeps(other.GetConllUSecondaryDeps());
					}
					if (other.HasWikipediaEntity())
					{
						bitField1_ |= unchecked((int)(0x00000020));
						wikipediaEntity_ = other.wikipediaEntity_;
						OnChanged();
					}
					if (other.HasIsNewline())
					{
						SetIsNewline(other.GetIsNewline());
					}
					if (other.HasGender())
					{
						bitField1_ |= unchecked((int)(0x00000080));
						gender_ = other.gender_;
						OnChanged();
					}
					if (other.HasTrueCase())
					{
						bitField1_ |= unchecked((int)(0x00000100));
						trueCase_ = other.trueCase_;
						OnChanged();
					}
					if (other.HasTrueCaseText())
					{
						bitField1_ |= unchecked((int)(0x00000200));
						trueCaseText_ = other.trueCaseText_;
						OnChanged();
					}
					if (other.HasChineseChar())
					{
						bitField1_ |= unchecked((int)(0x00000400));
						chineseChar_ = other.chineseChar_;
						OnChanged();
					}
					if (other.HasChineseSeg())
					{
						bitField1_ |= unchecked((int)(0x00000800));
						chineseSeg_ = other.chineseSeg_;
						OnChanged();
					}
					if (other.HasChineseXMLChar())
					{
						bitField1_ |= unchecked((int)(0x00001000));
						chineseXMLChar_ = other.chineseXMLChar_;
						OnChanged();
					}
					if (other.HasSectionName())
					{
						bitField1_ |= unchecked((int)(0x00002000));
						sectionName_ = other.sectionName_;
						OnChanged();
					}
					if (other.HasSectionAuthor())
					{
						bitField1_ |= unchecked((int)(0x00004000));
						sectionAuthor_ = other.sectionAuthor_;
						OnChanged();
					}
					if (other.HasSectionDate())
					{
						bitField1_ |= unchecked((int)(0x00008000));
						sectionDate_ = other.sectionDate_;
						OnChanged();
					}
					if (other.HasSectionEndLabel())
					{
						bitField1_ |= unchecked((int)(0x00010000));
						sectionEndLabel_ = other.sectionEndLabel_;
						OnChanged();
					}
					if (other.HasParent())
					{
						bitField1_ |= unchecked((int)(0x00020000));
						parent_ = other.parent_;
						OnChanged();
					}
					if (!other.corefMentionIndex_.IsEmpty())
					{
						if (corefMentionIndex_.IsEmpty())
						{
							corefMentionIndex_ = other.corefMentionIndex_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00040000)));
						}
						else
						{
							EnsureCorefMentionIndexIsMutable();
							Sharpen.Collections.AddAll(corefMentionIndex_, other.corefMentionIndex_);
						}
						OnChanged();
					}
					if (other.HasEntityMentionIndex())
					{
						SetEntityMentionIndex(other.GetEntityMentionIndex());
					}
					this.MergeExtensionFields(other);
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (HasOperator())
					{
						if (!GetOperator().IsInitialized())
						{
							return false;
						}
					}
					if (HasPolarity())
					{
						if (!GetPolarity().IsInitialized())
						{
							return false;
						}
					}
					if (HasSpan())
					{
						if (!GetSpan().IsInitialized())
						{
							return false;
						}
					}
					if (HasConllUTokenSpan())
					{
						if (!GetConllUTokenSpan().IsInitialized())
						{
							return false;
						}
					}
					if (!ExtensionsAreInitialized())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Token parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Token)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int bitField1_;

				private object word_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Fields set by the default annotators [new CoreNLP(new Properties())]
				/// </pre>
				/// <code>optional string word = 1;</code>
				/// </summary>
				public bool HasWord()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary>
				/// <pre>
				/// Fields set by the default annotators [new CoreNLP(new Properties())]
				/// </pre>
				/// <code>optional string word = 1;</code>
				/// </summary>
				public string GetWord()
				{
					object @ref = word_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							word_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Fields set by the default annotators [new CoreNLP(new Properties())]
				/// </pre>
				/// <code>optional string word = 1;</code>
				/// </summary>
				public ByteString GetWordBytes()
				{
					object @ref = word_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						word_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Fields set by the default annotators [new CoreNLP(new Properties())]
				/// </pre>
				/// <code>optional string word = 1;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetWord(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					word_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Fields set by the default annotators [new CoreNLP(new Properties())]
				/// </pre>
				/// <code>optional string word = 1;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearWord()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					word_ = GetDefaultInstance().GetWord();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Fields set by the default annotators [new CoreNLP(new Properties())]
				/// </pre>
				/// <code>optional string word = 1;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetWordBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					word_ = value;
					OnChanged();
					return this;
				}

				private object pos_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's part of speech tag
				/// </pre>
				/// <code>optional string pos = 2;</code>
				/// </summary>
				public bool HasPos()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary>
				/// <pre>
				/// The word's part of speech tag
				/// </pre>
				/// <code>optional string pos = 2;</code>
				/// </summary>
				public string GetPos()
				{
					object @ref = pos_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							pos_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's part of speech tag
				/// </pre>
				/// <code>optional string pos = 2;</code>
				/// </summary>
				public ByteString GetPosBytes()
				{
					object @ref = pos_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						pos_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's part of speech tag
				/// </pre>
				/// <code>optional string pos = 2;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetPos(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					pos_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's part of speech tag
				/// </pre>
				/// <code>optional string pos = 2;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearPos()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					pos_ = GetDefaultInstance().GetPos();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's part of speech tag
				/// </pre>
				/// <code>optional string pos = 2;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetPosBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					pos_ = value;
					OnChanged();
					return this;
				}

				private object value_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's 'value', (e.g., parse tree node)
				/// </pre>
				/// <code>optional string value = 3;</code>
				/// </summary>
				public bool HasValue()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary>
				/// <pre>
				/// The word's 'value', (e.g., parse tree node)
				/// </pre>
				/// <code>optional string value = 3;</code>
				/// </summary>
				public string GetValue()
				{
					object @ref = value_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							value_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's 'value', (e.g., parse tree node)
				/// </pre>
				/// <code>optional string value = 3;</code>
				/// </summary>
				public ByteString GetValueBytes()
				{
					object @ref = value_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						value_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's 'value', (e.g., parse tree node)
				/// </pre>
				/// <code>optional string value = 3;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetValue(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					value_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's 'value', (e.g., parse tree node)
				/// </pre>
				/// <code>optional string value = 3;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearValue()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					value_ = GetDefaultInstance().GetValue();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's 'value', (e.g., parse tree node)
				/// </pre>
				/// <code>optional string value = 3;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetValueBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					value_ = value;
					OnChanged();
					return this;
				}

				private object category_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's 'category' (e.g., parse tree node)
				/// </pre>
				/// <code>optional string category = 4;</code>
				/// </summary>
				public bool HasCategory()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary>
				/// <pre>
				/// The word's 'category' (e.g., parse tree node)
				/// </pre>
				/// <code>optional string category = 4;</code>
				/// </summary>
				public string GetCategory()
				{
					object @ref = category_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							category_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's 'category' (e.g., parse tree node)
				/// </pre>
				/// <code>optional string category = 4;</code>
				/// </summary>
				public ByteString GetCategoryBytes()
				{
					object @ref = category_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						category_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's 'category' (e.g., parse tree node)
				/// </pre>
				/// <code>optional string category = 4;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCategory(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					category_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's 'category' (e.g., parse tree node)
				/// </pre>
				/// <code>optional string category = 4;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearCategory()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					category_ = GetDefaultInstance().GetCategory();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's 'category' (e.g., parse tree node)
				/// </pre>
				/// <code>optional string category = 4;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCategoryBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					category_ = value;
					OnChanged();
					return this;
				}

				private object before_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The whitespace/xml before the token
				/// </pre>
				/// <code>optional string before = 5;</code>
				/// </summary>
				public bool HasBefore()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml before the token
				/// </pre>
				/// <code>optional string before = 5;</code>
				/// </summary>
				public string GetBefore()
				{
					object @ref = before_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							before_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml before the token
				/// </pre>
				/// <code>optional string before = 5;</code>
				/// </summary>
				public ByteString GetBeforeBytes()
				{
					object @ref = before_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						before_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml before the token
				/// </pre>
				/// <code>optional string before = 5;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetBefore(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					before_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml before the token
				/// </pre>
				/// <code>optional string before = 5;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearBefore()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					before_ = GetDefaultInstance().GetBefore();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml before the token
				/// </pre>
				/// <code>optional string before = 5;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetBeforeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					before_ = value;
					OnChanged();
					return this;
				}

				private object after_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The whitespace/xml after the token
				/// </pre>
				/// <code>optional string after = 6;</code>
				/// </summary>
				public bool HasAfter()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml after the token
				/// </pre>
				/// <code>optional string after = 6;</code>
				/// </summary>
				public string GetAfter()
				{
					object @ref = after_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							after_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml after the token
				/// </pre>
				/// <code>optional string after = 6;</code>
				/// </summary>
				public ByteString GetAfterBytes()
				{
					object @ref = after_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						after_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml after the token
				/// </pre>
				/// <code>optional string after = 6;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetAfter(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					after_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml after the token
				/// </pre>
				/// <code>optional string after = 6;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearAfter()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					after_ = GetDefaultInstance().GetAfter();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The whitespace/xml after the token
				/// </pre>
				/// <code>optional string after = 6;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetAfterBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					after_ = value;
					OnChanged();
					return this;
				}

				private object originalText_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The original text for this token
				/// </pre>
				/// <code>optional string originalText = 7;</code>
				/// </summary>
				public bool HasOriginalText()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary>
				/// <pre>
				/// The original text for this token
				/// </pre>
				/// <code>optional string originalText = 7;</code>
				/// </summary>
				public string GetOriginalText()
				{
					object @ref = originalText_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							originalText_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The original text for this token
				/// </pre>
				/// <code>optional string originalText = 7;</code>
				/// </summary>
				public ByteString GetOriginalTextBytes()
				{
					object @ref = originalText_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						originalText_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The original text for this token
				/// </pre>
				/// <code>optional string originalText = 7;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetOriginalText(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000040));
					originalText_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The original text for this token
				/// </pre>
				/// <code>optional string originalText = 7;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearOriginalText()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					originalText_ = GetDefaultInstance().GetOriginalText();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The original text for this token
				/// </pre>
				/// <code>optional string originalText = 7;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetOriginalTextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000040));
					originalText_ = value;
					OnChanged();
					return this;
				}

				private object ner_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's NER tag
				/// </pre>
				/// <code>optional string ner = 8;</code>
				/// </summary>
				public bool HasNer()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary>
				/// <pre>
				/// The word's NER tag
				/// </pre>
				/// <code>optional string ner = 8;</code>
				/// </summary>
				public string GetNer()
				{
					object @ref = ner_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							ner_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's NER tag
				/// </pre>
				/// <code>optional string ner = 8;</code>
				/// </summary>
				public ByteString GetNerBytes()
				{
					object @ref = ner_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						ner_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's NER tag
				/// </pre>
				/// <code>optional string ner = 8;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetNer(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					ner_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's NER tag
				/// </pre>
				/// <code>optional string ner = 8;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearNer()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					ner_ = GetDefaultInstance().GetNer();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's NER tag
				/// </pre>
				/// <code>optional string ner = 8;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetNerBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					ner_ = value;
					OnChanged();
					return this;
				}

				private object coarseNER_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's coarse NER tag
				/// </pre>
				/// <code>optional string coarseNER = 62;</code>
				/// </summary>
				public bool HasCoarseNER()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary>
				/// <pre>
				/// The word's coarse NER tag
				/// </pre>
				/// <code>optional string coarseNER = 62;</code>
				/// </summary>
				public string GetCoarseNER()
				{
					object @ref = coarseNER_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							coarseNER_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's coarse NER tag
				/// </pre>
				/// <code>optional string coarseNER = 62;</code>
				/// </summary>
				public ByteString GetCoarseNERBytes()
				{
					object @ref = coarseNER_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						coarseNER_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's coarse NER tag
				/// </pre>
				/// <code>optional string coarseNER = 62;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCoarseNER(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000100));
					coarseNER_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's coarse NER tag
				/// </pre>
				/// <code>optional string coarseNER = 62;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearCoarseNER()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					coarseNER_ = GetDefaultInstance().GetCoarseNER();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's coarse NER tag
				/// </pre>
				/// <code>optional string coarseNER = 62;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCoarseNERBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000100));
					coarseNER_ = value;
					OnChanged();
					return this;
				}

				private object fineGrainedNER_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's fine-grained NER tag
				/// </pre>
				/// <code>optional string fineGrainedNER = 63;</code>
				/// </summary>
				public bool HasFineGrainedNER()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary>
				/// <pre>
				/// The word's fine-grained NER tag
				/// </pre>
				/// <code>optional string fineGrainedNER = 63;</code>
				/// </summary>
				public string GetFineGrainedNER()
				{
					object @ref = fineGrainedNER_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							fineGrainedNER_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's fine-grained NER tag
				/// </pre>
				/// <code>optional string fineGrainedNER = 63;</code>
				/// </summary>
				public ByteString GetFineGrainedNERBytes()
				{
					object @ref = fineGrainedNER_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						fineGrainedNER_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's fine-grained NER tag
				/// </pre>
				/// <code>optional string fineGrainedNER = 63;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetFineGrainedNER(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					fineGrainedNER_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's fine-grained NER tag
				/// </pre>
				/// <code>optional string fineGrainedNER = 63;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearFineGrainedNER()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					fineGrainedNER_ = GetDefaultInstance().GetFineGrainedNER();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's fine-grained NER tag
				/// </pre>
				/// <code>optional string fineGrainedNER = 63;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetFineGrainedNERBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					fineGrainedNER_ = value;
					OnChanged();
					return this;
				}

				private object normalizedNER_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's normalized NER tag
				/// </pre>
				/// <code>optional string normalizedNER = 9;</code>
				/// </summary>
				public bool HasNormalizedNER()
				{
					return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary>
				/// <pre>
				/// The word's normalized NER tag
				/// </pre>
				/// <code>optional string normalizedNER = 9;</code>
				/// </summary>
				public string GetNormalizedNER()
				{
					object @ref = normalizedNER_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							normalizedNER_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's normalized NER tag
				/// </pre>
				/// <code>optional string normalizedNER = 9;</code>
				/// </summary>
				public ByteString GetNormalizedNERBytes()
				{
					object @ref = normalizedNER_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						normalizedNER_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's normalized NER tag
				/// </pre>
				/// <code>optional string normalizedNER = 9;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetNormalizedNER(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					normalizedNER_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's normalized NER tag
				/// </pre>
				/// <code>optional string normalizedNER = 9;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearNormalizedNER()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					normalizedNER_ = GetDefaultInstance().GetNormalizedNER();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's normalized NER tag
				/// </pre>
				/// <code>optional string normalizedNER = 9;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetNormalizedNERBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					normalizedNER_ = value;
					OnChanged();
					return this;
				}

				private object lemma_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The word's lemma
				/// </pre>
				/// <code>optional string lemma = 10;</code>
				/// </summary>
				public bool HasLemma()
				{
					return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary>
				/// <pre>
				/// The word's lemma
				/// </pre>
				/// <code>optional string lemma = 10;</code>
				/// </summary>
				public string GetLemma()
				{
					object @ref = lemma_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							lemma_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's lemma
				/// </pre>
				/// <code>optional string lemma = 10;</code>
				/// </summary>
				public ByteString GetLemmaBytes()
				{
					object @ref = lemma_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						lemma_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The word's lemma
				/// </pre>
				/// <code>optional string lemma = 10;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetLemma(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000800));
					lemma_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's lemma
				/// </pre>
				/// <code>optional string lemma = 10;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearLemma()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					lemma_ = GetDefaultInstance().GetLemma();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The word's lemma
				/// </pre>
				/// <code>optional string lemma = 10;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetLemmaBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000800));
					lemma_ = value;
					OnChanged();
					return this;
				}

				private int beginChar_;

				/// <summary>
				/// <pre>
				/// The character offset begin, in the document
				/// </pre>
				/// <code>optional uint32 beginChar = 11;</code>
				/// </summary>
				public bool HasBeginChar()
				{
					return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
				}

				/// <summary>
				/// <pre>
				/// The character offset begin, in the document
				/// </pre>
				/// <code>optional uint32 beginChar = 11;</code>
				/// </summary>
				public int GetBeginChar()
				{
					return beginChar_;
				}

				/// <summary>
				/// <pre>
				/// The character offset begin, in the document
				/// </pre>
				/// <code>optional uint32 beginChar = 11;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetBeginChar(int value)
				{
					bitField0_ |= unchecked((int)(0x00001000));
					beginChar_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The character offset begin, in the document
				/// </pre>
				/// <code>optional uint32 beginChar = 11;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearBeginChar()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					beginChar_ = 0;
					OnChanged();
					return this;
				}

				private int endChar_;

				/// <summary>
				/// <pre>
				/// The character offset end, in the document
				/// </pre>
				/// <code>optional uint32 endChar = 12;</code>
				/// </summary>
				public bool HasEndChar()
				{
					return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
				}

				/// <summary>
				/// <pre>
				/// The character offset end, in the document
				/// </pre>
				/// <code>optional uint32 endChar = 12;</code>
				/// </summary>
				public int GetEndChar()
				{
					return endChar_;
				}

				/// <summary>
				/// <pre>
				/// The character offset end, in the document
				/// </pre>
				/// <code>optional uint32 endChar = 12;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetEndChar(int value)
				{
					bitField0_ |= unchecked((int)(0x00002000));
					endChar_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The character offset end, in the document
				/// </pre>
				/// <code>optional uint32 endChar = 12;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearEndChar()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					endChar_ = 0;
					OnChanged();
					return this;
				}

				private int utterance_;

				/// <summary>
				/// <pre>
				/// The utterance tag used in dcoref
				/// </pre>
				/// <code>optional uint32 utterance = 13;</code>
				/// </summary>
				public bool HasUtterance()
				{
					return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
				}

				/// <summary>
				/// <pre>
				/// The utterance tag used in dcoref
				/// </pre>
				/// <code>optional uint32 utterance = 13;</code>
				/// </summary>
				public int GetUtterance()
				{
					return utterance_;
				}

				/// <summary>
				/// <pre>
				/// The utterance tag used in dcoref
				/// </pre>
				/// <code>optional uint32 utterance = 13;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetUtterance(int value)
				{
					bitField0_ |= unchecked((int)(0x00004000));
					utterance_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The utterance tag used in dcoref
				/// </pre>
				/// <code>optional uint32 utterance = 13;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearUtterance()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					utterance_ = 0;
					OnChanged();
					return this;
				}

				private object speaker_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The speaker speaking this word
				/// </pre>
				/// <code>optional string speaker = 14;</code>
				/// </summary>
				public bool HasSpeaker()
				{
					return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
				}

				/// <summary>
				/// <pre>
				/// The speaker speaking this word
				/// </pre>
				/// <code>optional string speaker = 14;</code>
				/// </summary>
				public string GetSpeaker()
				{
					object @ref = speaker_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							speaker_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The speaker speaking this word
				/// </pre>
				/// <code>optional string speaker = 14;</code>
				/// </summary>
				public ByteString GetSpeakerBytes()
				{
					object @ref = speaker_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						speaker_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The speaker speaking this word
				/// </pre>
				/// <code>optional string speaker = 14;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSpeaker(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00008000));
					speaker_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The speaker speaking this word
				/// </pre>
				/// <code>optional string speaker = 14;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearSpeaker()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					speaker_ = GetDefaultInstance().GetSpeaker();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The speaker speaking this word
				/// </pre>
				/// <code>optional string speaker = 14;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSpeakerBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00008000));
					speaker_ = value;
					OnChanged();
					return this;
				}

				private int beginIndex_;

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 beginIndex = 15;</code>
				/// </summary>
				public bool HasBeginIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
				}

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 beginIndex = 15;</code>
				/// </summary>
				public int GetBeginIndex()
				{
					return beginIndex_;
				}

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 beginIndex = 15;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetBeginIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00010000));
					beginIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 beginIndex = 15;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearBeginIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					beginIndex_ = 0;
					OnChanged();
					return this;
				}

				private int endIndex_;

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 endIndex = 16;</code>
				/// </summary>
				public bool HasEndIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
				}

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 endIndex = 16;</code>
				/// </summary>
				public int GetEndIndex()
				{
					return endIndex_;
				}

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 endIndex = 16;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetEndIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00020000));
					endIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The begin index of, e.g., a span
				/// </pre>
				/// <code>optional uint32 endIndex = 16;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearEndIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					endIndex_ = 0;
					OnChanged();
					return this;
				}

				private int tokenBeginIndex_;

				/// <summary>
				/// <pre>
				/// The begin index of the token
				/// </pre>
				/// <code>optional uint32 tokenBeginIndex = 17;</code>
				/// </summary>
				public bool HasTokenBeginIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000)));
				}

				/// <summary>
				/// <pre>
				/// The begin index of the token
				/// </pre>
				/// <code>optional uint32 tokenBeginIndex = 17;</code>
				/// </summary>
				public int GetTokenBeginIndex()
				{
					return tokenBeginIndex_;
				}

				/// <summary>
				/// <pre>
				/// The begin index of the token
				/// </pre>
				/// <code>optional uint32 tokenBeginIndex = 17;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTokenBeginIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00040000));
					tokenBeginIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The begin index of the token
				/// </pre>
				/// <code>optional uint32 tokenBeginIndex = 17;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearTokenBeginIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
					tokenBeginIndex_ = 0;
					OnChanged();
					return this;
				}

				private int tokenEndIndex_;

				/// <summary>
				/// <pre>
				/// The end index of the token
				/// </pre>
				/// <code>optional uint32 tokenEndIndex = 18;</code>
				/// </summary>
				public bool HasTokenEndIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
				}

				/// <summary>
				/// <pre>
				/// The end index of the token
				/// </pre>
				/// <code>optional uint32 tokenEndIndex = 18;</code>
				/// </summary>
				public int GetTokenEndIndex()
				{
					return tokenEndIndex_;
				}

				/// <summary>
				/// <pre>
				/// The end index of the token
				/// </pre>
				/// <code>optional uint32 tokenEndIndex = 18;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTokenEndIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00080000));
					tokenEndIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The end index of the token
				/// </pre>
				/// <code>optional uint32 tokenEndIndex = 18;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearTokenEndIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					tokenEndIndex_ = 0;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.Timex timexValue_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.Timex, CoreNLPProtos.Timex.Builder, CoreNLPProtos.ITimexOrBuilder> timexValueBuilder_;

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public bool HasTimexValue()
				{
					return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public CoreNLPProtos.Timex GetTimexValue()
				{
					if (timexValueBuilder_ == null)
					{
						return timexValue_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timexValue_;
					}
					else
					{
						return timexValueBuilder_.GetMessage();
					}
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTimexValue(CoreNLPProtos.Timex value)
				{
					if (timexValueBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						timexValue_ = value;
						OnChanged();
					}
					else
					{
						timexValueBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTimexValue(CoreNLPProtos.Timex.Builder builderForValue)
				{
					if (timexValueBuilder_ == null)
					{
						timexValue_ = ((CoreNLPProtos.Timex)builderForValue.Build());
						OnChanged();
					}
					else
					{
						timexValueBuilder_.SetMessage(((CoreNLPProtos.Timex)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder MergeTimexValue(CoreNLPProtos.Timex value)
				{
					if (timexValueBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))) && timexValue_ != null && timexValue_ != CoreNLPProtos.Timex.GetDefaultInstance())
						{
							timexValue_ = ((CoreNLPProtos.Timex)CoreNLPProtos.Timex.NewBuilder(timexValue_).MergeFrom(value).BuildPartial());
						}
						else
						{
							timexValue_ = value;
						}
						OnChanged();
					}
					else
					{
						timexValueBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearTimexValue()
				{
					if (timexValueBuilder_ == null)
					{
						timexValue_ = null;
						OnChanged();
					}
					else
					{
						timexValueBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public CoreNLPProtos.Timex.Builder GetTimexValueBuilder()
				{
					bitField0_ |= unchecked((int)(0x00100000));
					OnChanged();
					return GetTimexValueFieldBuilder().GetBuilder();
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				public CoreNLPProtos.ITimexOrBuilder GetTimexValueOrBuilder()
				{
					if (timexValueBuilder_ != null)
					{
						return timexValueBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return timexValue_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timexValue_;
					}
				}

				/// <summary>
				/// <pre>
				/// The time this word refers to
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;</code>
				/// </summary>
				private SingleFieldBuilderV3<CoreNLPProtos.Timex, CoreNLPProtos.Timex.Builder, CoreNLPProtos.ITimexOrBuilder> GetTimexValueFieldBuilder()
				{
					if (timexValueBuilder_ == null)
					{
						timexValueBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.Timex, CoreNLPProtos.Timex.Builder, CoreNLPProtos.ITimexOrBuilder>(GetTimexValue(), GetParentForChildren(), IsClean());
						timexValue_ = null;
					}
					return timexValueBuilder_;
				}

				private bool hasXmlContext_;

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>optional bool hasXmlContext = 21;</code>
				/// </summary>
				public bool HasHasXmlContext()
				{
					return ((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000)));
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>optional bool hasXmlContext = 21;</code>
				/// </summary>
				public bool GetHasXmlContext()
				{
					return hasXmlContext_;
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>optional bool hasXmlContext = 21;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetHasXmlContext(bool value)
				{
					bitField0_ |= unchecked((int)(0x00200000));
					hasXmlContext_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>optional bool hasXmlContext = 21;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearHasXmlContext()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
					hasXmlContext_ = false;
					OnChanged();
					return this;
				}

				private ILazyStringList xmlContext_ = LazyStringArrayList.Empty;

				private void EnsureXmlContextIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
					{
						xmlContext_ = new LazyStringArrayList(xmlContext_);
						bitField0_ |= unchecked((int)(0x00400000));
					}
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public IProtocolStringList GetXmlContextList()
				{
					return xmlContext_.GetUnmodifiableView();
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public int GetXmlContextCount()
				{
					return xmlContext_.Count;
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public string GetXmlContext(int index)
				{
					return xmlContext_[index];
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public ByteString GetXmlContextBytes(int index)
				{
					return xmlContext_.GetByteString(index);
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetXmlContext(int index, string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureXmlContextIsMutable();
					xmlContext_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder AddXmlContext(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureXmlContextIsMutable();
					xmlContext_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder AddAllXmlContext(IEnumerable<string> values)
				{
					EnsureXmlContextIsMutable();
					AbstractMessageLite.Builder.AddAll(values, xmlContext_);
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearXmlContext()
				{
					xmlContext_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Used by clean xml annotator
				/// </pre>
				/// <code>repeated string xmlContext = 22;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder AddXmlContextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureXmlContextIsMutable();
					xmlContext_.Add(value);
					OnChanged();
					return this;
				}

				private int corefClusterID_;

				/// <summary>
				/// <pre>
				/// The [primary] cluster id for this token
				/// </pre>
				/// <code>optional uint32 corefClusterID = 23;</code>
				/// </summary>
				public bool HasCorefClusterID()
				{
					return ((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000)));
				}

				/// <summary>
				/// <pre>
				/// The [primary] cluster id for this token
				/// </pre>
				/// <code>optional uint32 corefClusterID = 23;</code>
				/// </summary>
				public int GetCorefClusterID()
				{
					return corefClusterID_;
				}

				/// <summary>
				/// <pre>
				/// The [primary] cluster id for this token
				/// </pre>
				/// <code>optional uint32 corefClusterID = 23;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCorefClusterID(int value)
				{
					bitField0_ |= unchecked((int)(0x00800000));
					corefClusterID_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The [primary] cluster id for this token
				/// </pre>
				/// <code>optional uint32 corefClusterID = 23;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearCorefClusterID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00800000)));
					corefClusterID_ = 0;
					OnChanged();
					return this;
				}

				private object answer_ = string.Empty;

				/// <summary>
				/// <pre>
				/// A temporary annotation which is occasionally left in
				/// </pre>
				/// <code>optional string answer = 24;</code>
				/// </summary>
				public bool HasAnswer()
				{
					return ((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000)));
				}

				/// <summary>
				/// <pre>
				/// A temporary annotation which is occasionally left in
				/// </pre>
				/// <code>optional string answer = 24;</code>
				/// </summary>
				public string GetAnswer()
				{
					object @ref = answer_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							answer_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// A temporary annotation which is occasionally left in
				/// </pre>
				/// <code>optional string answer = 24;</code>
				/// </summary>
				public ByteString GetAnswerBytes()
				{
					object @ref = answer_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						answer_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// A temporary annotation which is occasionally left in
				/// </pre>
				/// <code>optional string answer = 24;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetAnswer(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x01000000));
					answer_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// A temporary annotation which is occasionally left in
				/// </pre>
				/// <code>optional string answer = 24;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearAnswer()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x01000000)));
					answer_ = GetDefaultInstance().GetAnswer();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// A temporary annotation which is occasionally left in
				/// </pre>
				/// <code>optional string answer = 24;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetAnswerBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x01000000));
					answer_ = value;
					OnChanged();
					return this;
				}

				private int headWordIndex_;

				/// <summary>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
				/// </pre>
				/// <code>optional uint32 headWordIndex = 26;</code>
				/// </remarks>
				public bool HasHeadWordIndex()
				{
					return ((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000)));
				}

				/// <summary>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
				/// </pre>
				/// <code>optional uint32 headWordIndex = 26;</code>
				/// </remarks>
				public int GetHeadWordIndex()
				{
					return headWordIndex_;
				}

				/// <summary>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
				/// </pre>
				/// <code>optional uint32 headWordIndex = 26;</code>
				/// </remarks>
				public CoreNLPProtos.Token.Builder SetHeadWordIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x02000000));
					headWordIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word.
				/// </summary>
				/// <remarks>
				/// <pre>
				/// optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
				/// </pre>
				/// <code>optional uint32 headWordIndex = 26;</code>
				/// </remarks>
				public CoreNLPProtos.Token.Builder ClearHeadWordIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x02000000)));
					headWordIndex_ = 0;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.Operator operator_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.Operator, CoreNLPProtos.Operator.Builder, CoreNLPProtos.IOperatorOrBuilder> operatorBuilder_;

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public bool HasOperator()
				{
					return ((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000)));
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public CoreNLPProtos.Operator GetOperator()
				{
					if (operatorBuilder_ == null)
					{
						return operator_ == null ? CoreNLPProtos.Operator.GetDefaultInstance() : operator_;
					}
					else
					{
						return operatorBuilder_.GetMessage();
					}
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetOperator(CoreNLPProtos.Operator value)
				{
					if (operatorBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						operator_ = value;
						OnChanged();
					}
					else
					{
						operatorBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x04000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetOperator(CoreNLPProtos.Operator.Builder builderForValue)
				{
					if (operatorBuilder_ == null)
					{
						operator_ = ((CoreNLPProtos.Operator)builderForValue.Build());
						OnChanged();
					}
					else
					{
						operatorBuilder_.SetMessage(((CoreNLPProtos.Operator)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x04000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder MergeOperator(CoreNLPProtos.Operator value)
				{
					if (operatorBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))) && operator_ != null && operator_ != CoreNLPProtos.Operator.GetDefaultInstance())
						{
							operator_ = ((CoreNLPProtos.Operator)CoreNLPProtos.Operator.NewBuilder(operator_).MergeFrom(value).BuildPartial());
						}
						else
						{
							operator_ = value;
						}
						OnChanged();
					}
					else
					{
						operatorBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x04000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearOperator()
				{
					if (operatorBuilder_ == null)
					{
						operator_ = null;
						OnChanged();
					}
					else
					{
						operatorBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
					return this;
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public CoreNLPProtos.Operator.Builder GetOperatorBuilder()
				{
					bitField0_ |= unchecked((int)(0x04000000));
					OnChanged();
					return GetOperatorFieldBuilder().GetBuilder();
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				public CoreNLPProtos.IOperatorOrBuilder GetOperatorOrBuilder()
				{
					if (operatorBuilder_ != null)
					{
						return operatorBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return operator_ == null ? CoreNLPProtos.Operator.GetDefaultInstance() : operator_;
					}
				}

				/// <summary>
				/// <pre>
				/// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Operator operator = 27;</code>
				/// </summary>
				private SingleFieldBuilderV3<CoreNLPProtos.Operator, CoreNLPProtos.Operator.Builder, CoreNLPProtos.IOperatorOrBuilder> GetOperatorFieldBuilder()
				{
					if (operatorBuilder_ == null)
					{
						operatorBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.Operator, CoreNLPProtos.Operator.Builder, CoreNLPProtos.IOperatorOrBuilder>(GetOperator(), GetParentForChildren(), IsClean());
						operator_ = null;
					}
					return operatorBuilder_;
				}

				private CoreNLPProtos.Polarity polarity_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.Polarity, CoreNLPProtos.Polarity.Builder, CoreNLPProtos.IPolarityOrBuilder> polarityBuilder_;

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public bool HasPolarity()
				{
					return ((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000)));
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public CoreNLPProtos.Polarity GetPolarity()
				{
					if (polarityBuilder_ == null)
					{
						return polarity_ == null ? CoreNLPProtos.Polarity.GetDefaultInstance() : polarity_;
					}
					else
					{
						return polarityBuilder_.GetMessage();
					}
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetPolarity(CoreNLPProtos.Polarity value)
				{
					if (polarityBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						polarity_ = value;
						OnChanged();
					}
					else
					{
						polarityBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x08000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetPolarity(CoreNLPProtos.Polarity.Builder builderForValue)
				{
					if (polarityBuilder_ == null)
					{
						polarity_ = ((CoreNLPProtos.Polarity)builderForValue.Build());
						OnChanged();
					}
					else
					{
						polarityBuilder_.SetMessage(((CoreNLPProtos.Polarity)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x08000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder MergePolarity(CoreNLPProtos.Polarity value)
				{
					if (polarityBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))) && polarity_ != null && polarity_ != CoreNLPProtos.Polarity.GetDefaultInstance())
						{
							polarity_ = ((CoreNLPProtos.Polarity)CoreNLPProtos.Polarity.NewBuilder(polarity_).MergeFrom(value).BuildPartial());
						}
						else
						{
							polarity_ = value;
						}
						OnChanged();
					}
					else
					{
						polarityBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x08000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearPolarity()
				{
					if (polarityBuilder_ == null)
					{
						polarity_ = null;
						OnChanged();
					}
					else
					{
						polarityBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public CoreNLPProtos.Polarity.Builder GetPolarityBuilder()
				{
					bitField0_ |= unchecked((int)(0x08000000));
					OnChanged();
					return GetPolarityFieldBuilder().GetBuilder();
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				public CoreNLPProtos.IPolarityOrBuilder GetPolarityOrBuilder()
				{
					if (polarityBuilder_ != null)
					{
						return polarityBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return polarity_ == null ? CoreNLPProtos.Polarity.GetDefaultInstance() : polarity_;
					}
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, according to Natural Logic
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;</code>
				/// </summary>
				private SingleFieldBuilderV3<CoreNLPProtos.Polarity, CoreNLPProtos.Polarity.Builder, CoreNLPProtos.IPolarityOrBuilder> GetPolarityFieldBuilder()
				{
					if (polarityBuilder_ == null)
					{
						polarityBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.Polarity, CoreNLPProtos.Polarity.Builder, CoreNLPProtos.IPolarityOrBuilder>(GetPolarity(), GetParentForChildren(), IsClean());
						polarity_ = null;
					}
					return polarityBuilder_;
				}

				private object polarityDir_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The polarity of this word, either "up", "down", or "flat"
				/// </pre>
				/// <code>optional string polarity_dir = 39;</code>
				/// </summary>
				public bool HasPolarityDir()
				{
					return ((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000)));
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, either "up", "down", or "flat"
				/// </pre>
				/// <code>optional string polarity_dir = 39;</code>
				/// </summary>
				public string GetPolarityDir()
				{
					object @ref = polarityDir_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							polarityDir_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, either "up", "down", or "flat"
				/// </pre>
				/// <code>optional string polarity_dir = 39;</code>
				/// </summary>
				public ByteString GetPolarityDirBytes()
				{
					object @ref = polarityDir_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						polarityDir_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, either "up", "down", or "flat"
				/// </pre>
				/// <code>optional string polarity_dir = 39;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetPolarityDir(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x10000000));
					polarityDir_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, either "up", "down", or "flat"
				/// </pre>
				/// <code>optional string polarity_dir = 39;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearPolarityDir()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x10000000)));
					polarityDir_ = GetDefaultInstance().GetPolarityDir();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The polarity of this word, either "up", "down", or "flat"
				/// </pre>
				/// <code>optional string polarity_dir = 39;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetPolarityDirBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x10000000));
					polarityDir_ = value;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.Span span_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.Span, CoreNLPProtos.Span.Builder, CoreNLPProtos.ISpanOrBuilder> spanBuilder_;

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public bool HasSpan()
				{
					return ((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000)));
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public CoreNLPProtos.Span GetSpan()
				{
					if (spanBuilder_ == null)
					{
						return span_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : span_;
					}
					else
					{
						return spanBuilder_.GetMessage();
					}
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSpan(CoreNLPProtos.Span value)
				{
					if (spanBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						span_ = value;
						OnChanged();
					}
					else
					{
						spanBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x20000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSpan(CoreNLPProtos.Span.Builder builderForValue)
				{
					if (spanBuilder_ == null)
					{
						span_ = ((CoreNLPProtos.Span)builderForValue.Build());
						OnChanged();
					}
					else
					{
						spanBuilder_.SetMessage(((CoreNLPProtos.Span)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x20000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder MergeSpan(CoreNLPProtos.Span value)
				{
					if (spanBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))) && span_ != null && span_ != CoreNLPProtos.Span.GetDefaultInstance())
						{
							span_ = ((CoreNLPProtos.Span)CoreNLPProtos.Span.NewBuilder(span_).MergeFrom(value).BuildPartial());
						}
						else
						{
							span_ = value;
						}
						OnChanged();
					}
					else
					{
						spanBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x20000000));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearSpan()
				{
					if (spanBuilder_ == null)
					{
						span_ = null;
						OnChanged();
					}
					else
					{
						spanBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public CoreNLPProtos.Span.Builder GetSpanBuilder()
				{
					bitField0_ |= unchecked((int)(0x20000000));
					OnChanged();
					return GetSpanFieldBuilder().GetBuilder();
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				public CoreNLPProtos.ISpanOrBuilder GetSpanOrBuilder()
				{
					if (spanBuilder_ != null)
					{
						return spanBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return span_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : span_;
					}
				}

				/// <summary>
				/// <pre>
				/// The span of a leaf node of a tree
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.Span span = 29;</code>
				/// </summary>
				private SingleFieldBuilderV3<CoreNLPProtos.Span, CoreNLPProtos.Span.Builder, CoreNLPProtos.ISpanOrBuilder> GetSpanFieldBuilder()
				{
					if (spanBuilder_ == null)
					{
						spanBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.Span, CoreNLPProtos.Span.Builder, CoreNLPProtos.ISpanOrBuilder>(GetSpan(), GetParentForChildren(), IsClean());
						span_ = null;
					}
					return spanBuilder_;
				}

				private object sentiment_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The final sentiment of the sentence
				/// </pre>
				/// <code>optional string sentiment = 30;</code>
				/// </summary>
				public bool HasSentiment()
				{
					return ((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000)));
				}

				/// <summary>
				/// <pre>
				/// The final sentiment of the sentence
				/// </pre>
				/// <code>optional string sentiment = 30;</code>
				/// </summary>
				public string GetSentiment()
				{
					object @ref = sentiment_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sentiment_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The final sentiment of the sentence
				/// </pre>
				/// <code>optional string sentiment = 30;</code>
				/// </summary>
				public ByteString GetSentimentBytes()
				{
					object @ref = sentiment_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sentiment_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The final sentiment of the sentence
				/// </pre>
				/// <code>optional string sentiment = 30;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSentiment(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x40000000));
					sentiment_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The final sentiment of the sentence
				/// </pre>
				/// <code>optional string sentiment = 30;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearSentiment()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
					sentiment_ = GetDefaultInstance().GetSentiment();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The final sentiment of the sentence
				/// </pre>
				/// <code>optional string sentiment = 30;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSentimentBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x40000000));
					sentiment_ = value;
					OnChanged();
					return this;
				}

				private int quotationIndex_;

				/// <summary>
				/// <pre>
				/// The index of the quotation this token refers to
				/// </pre>
				/// <code>optional int32 quotationIndex = 31;</code>
				/// </summary>
				public bool HasQuotationIndex()
				{
					return ((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000)));
				}

				/// <summary>
				/// <pre>
				/// The index of the quotation this token refers to
				/// </pre>
				/// <code>optional int32 quotationIndex = 31;</code>
				/// </summary>
				public int GetQuotationIndex()
				{
					return quotationIndex_;
				}

				/// <summary>
				/// <pre>
				/// The index of the quotation this token refers to
				/// </pre>
				/// <code>optional int32 quotationIndex = 31;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetQuotationIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x80000000));
					quotationIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The index of the quotation this token refers to
				/// </pre>
				/// <code>optional int32 quotationIndex = 31;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearQuotationIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x80000000)));
					quotationIndex_ = 0;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.MapStringString conllUFeatures_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.MapStringString, CoreNLPProtos.MapStringString.Builder, CoreNLPProtos.IMapStringStringOrBuilder> conllUFeaturesBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public bool HasConllUFeatures()
				{
					return ((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public CoreNLPProtos.MapStringString GetConllUFeatures()
				{
					if (conllUFeaturesBuilder_ == null)
					{
						return conllUFeatures_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUFeatures_;
					}
					else
					{
						return conllUFeaturesBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUFeatures(CoreNLPProtos.MapStringString value)
				{
					if (conllUFeaturesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						conllUFeatures_ = value;
						OnChanged();
					}
					else
					{
						conllUFeaturesBuilder_.SetMessage(value);
					}
					bitField1_ |= unchecked((int)(0x00000001));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUFeatures(CoreNLPProtos.MapStringString.Builder builderForValue)
				{
					if (conllUFeaturesBuilder_ == null)
					{
						conllUFeatures_ = ((CoreNLPProtos.MapStringString)builderForValue.Build());
						OnChanged();
					}
					else
					{
						conllUFeaturesBuilder_.SetMessage(((CoreNLPProtos.MapStringString)builderForValue.Build()));
					}
					bitField1_ |= unchecked((int)(0x00000001));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public CoreNLPProtos.Token.Builder MergeConllUFeatures(CoreNLPProtos.MapStringString value)
				{
					if (conllUFeaturesBuilder_ == null)
					{
						if (((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))) && conllUFeatures_ != null && conllUFeatures_ != CoreNLPProtos.MapStringString.GetDefaultInstance())
						{
							conllUFeatures_ = ((CoreNLPProtos.MapStringString)CoreNLPProtos.MapStringString.NewBuilder(conllUFeatures_).MergeFrom(value).BuildPartial());
						}
						else
						{
							conllUFeatures_ = value;
						}
						OnChanged();
					}
					else
					{
						conllUFeaturesBuilder_.MergeFrom(value);
					}
					bitField1_ |= unchecked((int)(0x00000001));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public CoreNLPProtos.Token.Builder ClearConllUFeatures()
				{
					if (conllUFeaturesBuilder_ == null)
					{
						conllUFeatures_ = null;
						OnChanged();
					}
					else
					{
						conllUFeaturesBuilder_.Clear();
					}
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public CoreNLPProtos.MapStringString.Builder GetConllUFeaturesBuilder()
				{
					bitField1_ |= unchecked((int)(0x00000001));
					OnChanged();
					return GetConllUFeaturesFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				public CoreNLPProtos.IMapStringStringOrBuilder GetConllUFeaturesOrBuilder()
				{
					if (conllUFeaturesBuilder_ != null)
					{
						return conllUFeaturesBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return conllUFeatures_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUFeatures_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.MapStringString, CoreNLPProtos.MapStringString.Builder, CoreNLPProtos.IMapStringStringOrBuilder> GetConllUFeaturesFieldBuilder()
				{
					if (conllUFeaturesBuilder_ == null)
					{
						conllUFeaturesBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.MapStringString, CoreNLPProtos.MapStringString.Builder, CoreNLPProtos.IMapStringStringOrBuilder>(GetConllUFeatures(), GetParentForChildren(), IsClean());
						conllUFeatures_ = null;
					}
					return conllUFeaturesBuilder_;
				}

				private object coarseTag_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The coarse POS tag (used to store the UPOS tag)
				/// </pre>
				/// <code>optional string coarseTag = 33;</code>
				/// </summary>
				public bool HasCoarseTag()
				{
					return ((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary>
				/// <pre>
				/// The coarse POS tag (used to store the UPOS tag)
				/// </pre>
				/// <code>optional string coarseTag = 33;</code>
				/// </summary>
				public string GetCoarseTag()
				{
					object @ref = coarseTag_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							coarseTag_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The coarse POS tag (used to store the UPOS tag)
				/// </pre>
				/// <code>optional string coarseTag = 33;</code>
				/// </summary>
				public ByteString GetCoarseTagBytes()
				{
					object @ref = coarseTag_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						coarseTag_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The coarse POS tag (used to store the UPOS tag)
				/// </pre>
				/// <code>optional string coarseTag = 33;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCoarseTag(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000002));
					coarseTag_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The coarse POS tag (used to store the UPOS tag)
				/// </pre>
				/// <code>optional string coarseTag = 33;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearCoarseTag()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
					coarseTag_ = GetDefaultInstance().GetCoarseTag();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The coarse POS tag (used to store the UPOS tag)
				/// </pre>
				/// <code>optional string coarseTag = 33;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCoarseTagBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000002));
					coarseTag_ = value;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.Span conllUTokenSpan_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.Span, CoreNLPProtos.Span.Builder, CoreNLPProtos.ISpanOrBuilder> conllUTokenSpanBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public bool HasConllUTokenSpan()
				{
					return ((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public CoreNLPProtos.Span GetConllUTokenSpan()
				{
					if (conllUTokenSpanBuilder_ == null)
					{
						return conllUTokenSpan_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : conllUTokenSpan_;
					}
					else
					{
						return conllUTokenSpanBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUTokenSpan(CoreNLPProtos.Span value)
				{
					if (conllUTokenSpanBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						conllUTokenSpan_ = value;
						OnChanged();
					}
					else
					{
						conllUTokenSpanBuilder_.SetMessage(value);
					}
					bitField1_ |= unchecked((int)(0x00000004));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUTokenSpan(CoreNLPProtos.Span.Builder builderForValue)
				{
					if (conllUTokenSpanBuilder_ == null)
					{
						conllUTokenSpan_ = ((CoreNLPProtos.Span)builderForValue.Build());
						OnChanged();
					}
					else
					{
						conllUTokenSpanBuilder_.SetMessage(((CoreNLPProtos.Span)builderForValue.Build()));
					}
					bitField1_ |= unchecked((int)(0x00000004));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public CoreNLPProtos.Token.Builder MergeConllUTokenSpan(CoreNLPProtos.Span value)
				{
					if (conllUTokenSpanBuilder_ == null)
					{
						if (((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))) && conllUTokenSpan_ != null && conllUTokenSpan_ != CoreNLPProtos.Span.GetDefaultInstance())
						{
							conllUTokenSpan_ = ((CoreNLPProtos.Span)CoreNLPProtos.Span.NewBuilder(conllUTokenSpan_).MergeFrom(value).BuildPartial());
						}
						else
						{
							conllUTokenSpan_ = value;
						}
						OnChanged();
					}
					else
					{
						conllUTokenSpanBuilder_.MergeFrom(value);
					}
					bitField1_ |= unchecked((int)(0x00000004));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public CoreNLPProtos.Token.Builder ClearConllUTokenSpan()
				{
					if (conllUTokenSpanBuilder_ == null)
					{
						conllUTokenSpan_ = null;
						OnChanged();
					}
					else
					{
						conllUTokenSpanBuilder_.Clear();
					}
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public CoreNLPProtos.Span.Builder GetConllUTokenSpanBuilder()
				{
					bitField1_ |= unchecked((int)(0x00000004));
					OnChanged();
					return GetConllUTokenSpanFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				public CoreNLPProtos.ISpanOrBuilder GetConllUTokenSpanOrBuilder()
				{
					if (conllUTokenSpanBuilder_ != null)
					{
						return conllUTokenSpanBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return conllUTokenSpan_ == null ? CoreNLPProtos.Span.GetDefaultInstance() : conllUTokenSpan_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.Span, CoreNLPProtos.Span.Builder, CoreNLPProtos.ISpanOrBuilder> GetConllUTokenSpanFieldBuilder()
				{
					if (conllUTokenSpanBuilder_ == null)
					{
						conllUTokenSpanBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.Span, CoreNLPProtos.Span.Builder, CoreNLPProtos.ISpanOrBuilder>(GetConllUTokenSpan(), GetParentForChildren(), IsClean());
						conllUTokenSpan_ = null;
					}
					return conllUTokenSpanBuilder_;
				}

				private object conllUMisc_ = string.Empty;

				/// <summary><code>optional string conllUMisc = 35;</code></summary>
				public bool HasConllUMisc()
				{
					return ((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional string conllUMisc = 35;</code></summary>
				public string GetConllUMisc()
				{
					object @ref = conllUMisc_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							conllUMisc_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string conllUMisc = 35;</code></summary>
				public ByteString GetConllUMiscBytes()
				{
					object @ref = conllUMisc_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						conllUMisc_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string conllUMisc = 35;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUMisc(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000008));
					conllUMisc_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string conllUMisc = 35;</code></summary>
				public CoreNLPProtos.Token.Builder ClearConllUMisc()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
					conllUMisc_ = GetDefaultInstance().GetConllUMisc();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string conllUMisc = 35;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUMiscBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000008));
					conllUMisc_ = value;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.MapStringString conllUSecondaryDeps_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.MapStringString, CoreNLPProtos.MapStringString.Builder, CoreNLPProtos.IMapStringStringOrBuilder> conllUSecondaryDepsBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public bool HasConllUSecondaryDeps()
				{
					return ((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public CoreNLPProtos.MapStringString GetConllUSecondaryDeps()
				{
					if (conllUSecondaryDepsBuilder_ == null)
					{
						return conllUSecondaryDeps_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUSecondaryDeps_;
					}
					else
					{
						return conllUSecondaryDepsBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUSecondaryDeps(CoreNLPProtos.MapStringString value)
				{
					if (conllUSecondaryDepsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						conllUSecondaryDeps_ = value;
						OnChanged();
					}
					else
					{
						conllUSecondaryDepsBuilder_.SetMessage(value);
					}
					bitField1_ |= unchecked((int)(0x00000010));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public CoreNLPProtos.Token.Builder SetConllUSecondaryDeps(CoreNLPProtos.MapStringString.Builder builderForValue)
				{
					if (conllUSecondaryDepsBuilder_ == null)
					{
						conllUSecondaryDeps_ = ((CoreNLPProtos.MapStringString)builderForValue.Build());
						OnChanged();
					}
					else
					{
						conllUSecondaryDepsBuilder_.SetMessage(((CoreNLPProtos.MapStringString)builderForValue.Build()));
					}
					bitField1_ |= unchecked((int)(0x00000010));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public CoreNLPProtos.Token.Builder MergeConllUSecondaryDeps(CoreNLPProtos.MapStringString value)
				{
					if (conllUSecondaryDepsBuilder_ == null)
					{
						if (((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))) && conllUSecondaryDeps_ != null && conllUSecondaryDeps_ != CoreNLPProtos.MapStringString.GetDefaultInstance())
						{
							conllUSecondaryDeps_ = ((CoreNLPProtos.MapStringString)CoreNLPProtos.MapStringString.NewBuilder(conllUSecondaryDeps_).MergeFrom(value).BuildPartial());
						}
						else
						{
							conllUSecondaryDeps_ = value;
						}
						OnChanged();
					}
					else
					{
						conllUSecondaryDepsBuilder_.MergeFrom(value);
					}
					bitField1_ |= unchecked((int)(0x00000010));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public CoreNLPProtos.Token.Builder ClearConllUSecondaryDeps()
				{
					if (conllUSecondaryDepsBuilder_ == null)
					{
						conllUSecondaryDeps_ = null;
						OnChanged();
					}
					else
					{
						conllUSecondaryDepsBuilder_.Clear();
					}
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public CoreNLPProtos.MapStringString.Builder GetConllUSecondaryDepsBuilder()
				{
					bitField1_ |= unchecked((int)(0x00000010));
					OnChanged();
					return GetConllUSecondaryDepsFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				public CoreNLPProtos.IMapStringStringOrBuilder GetConllUSecondaryDepsOrBuilder()
				{
					if (conllUSecondaryDepsBuilder_ != null)
					{
						return conllUSecondaryDepsBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return conllUSecondaryDeps_ == null ? CoreNLPProtos.MapStringString.GetDefaultInstance() : conllUSecondaryDeps_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.MapStringString conllUSecondaryDeps = 36;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.MapStringString, CoreNLPProtos.MapStringString.Builder, CoreNLPProtos.IMapStringStringOrBuilder> GetConllUSecondaryDepsFieldBuilder()
				{
					if (conllUSecondaryDepsBuilder_ == null)
					{
						conllUSecondaryDepsBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.MapStringString, CoreNLPProtos.MapStringString.Builder, CoreNLPProtos.IMapStringStringOrBuilder>(GetConllUSecondaryDeps(), GetParentForChildren(), IsClean());
						conllUSecondaryDeps_ = null;
					}
					return conllUSecondaryDepsBuilder_;
				}

				private object wikipediaEntity_ = string.Empty;

				/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
				public bool HasWikipediaEntity()
				{
					return ((bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
				public string GetWikipediaEntity()
				{
					object @ref = wikipediaEntity_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							wikipediaEntity_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
				public ByteString GetWikipediaEntityBytes()
				{
					object @ref = wikipediaEntity_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						wikipediaEntity_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
				public CoreNLPProtos.Token.Builder SetWikipediaEntity(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000020));
					wikipediaEntity_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
				public CoreNLPProtos.Token.Builder ClearWikipediaEntity()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
					wikipediaEntity_ = GetDefaultInstance().GetWikipediaEntity();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string wikipediaEntity = 37;</code></summary>
				public CoreNLPProtos.Token.Builder SetWikipediaEntityBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000020));
					wikipediaEntity_ = value;
					OnChanged();
					return this;
				}

				private bool isNewline_;

				/// <summary><code>optional bool isNewline = 38;</code></summary>
				public bool HasIsNewline()
				{
					return ((bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional bool isNewline = 38;</code></summary>
				public bool GetIsNewline()
				{
					return isNewline_;
				}

				/// <summary><code>optional bool isNewline = 38;</code></summary>
				public CoreNLPProtos.Token.Builder SetIsNewline(bool value)
				{
					bitField1_ |= unchecked((int)(0x00000040));
					isNewline_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool isNewline = 38;</code></summary>
				public CoreNLPProtos.Token.Builder ClearIsNewline()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
					isNewline_ = false;
					OnChanged();
					return this;
				}

				private object gender_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional string gender = 51;</code>
				/// </summary>
				public bool HasGender()
				{
					return ((bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional string gender = 51;</code>
				/// </summary>
				public string GetGender()
				{
					object @ref = gender_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							gender_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional string gender = 51;</code>
				/// </summary>
				public ByteString GetGenderBytes()
				{
					object @ref = gender_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						gender_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional string gender = 51;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetGender(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000080));
					gender_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional string gender = 51;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearGender()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
					gender_ = GetDefaultInstance().GetGender();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Fields set by other annotators in CoreNLP
				/// </pre>
				/// <code>optional string gender = 51;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetGenderBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000080));
					gender_ = value;
					OnChanged();
					return this;
				}

				private object trueCase_ = string.Empty;

				/// <summary>
				/// <pre>
				/// true case type of token
				/// </pre>
				/// <code>optional string trueCase = 52;</code>
				/// </summary>
				public bool HasTrueCase()
				{
					return ((bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary>
				/// <pre>
				/// true case type of token
				/// </pre>
				/// <code>optional string trueCase = 52;</code>
				/// </summary>
				public string GetTrueCase()
				{
					object @ref = trueCase_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							trueCase_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// true case type of token
				/// </pre>
				/// <code>optional string trueCase = 52;</code>
				/// </summary>
				public ByteString GetTrueCaseBytes()
				{
					object @ref = trueCase_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						trueCase_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// true case type of token
				/// </pre>
				/// <code>optional string trueCase = 52;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTrueCase(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000100));
					trueCase_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// true case type of token
				/// </pre>
				/// <code>optional string trueCase = 52;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearTrueCase()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
					trueCase_ = GetDefaultInstance().GetTrueCase();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// true case type of token
				/// </pre>
				/// <code>optional string trueCase = 52;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTrueCaseBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000100));
					trueCase_ = value;
					OnChanged();
					return this;
				}

				private object trueCaseText_ = string.Empty;

				/// <summary>
				/// <pre>
				/// true case gloss of token
				/// </pre>
				/// <code>optional string trueCaseText = 53;</code>
				/// </summary>
				public bool HasTrueCaseText()
				{
					return ((bitField1_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary>
				/// <pre>
				/// true case gloss of token
				/// </pre>
				/// <code>optional string trueCaseText = 53;</code>
				/// </summary>
				public string GetTrueCaseText()
				{
					object @ref = trueCaseText_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							trueCaseText_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// true case gloss of token
				/// </pre>
				/// <code>optional string trueCaseText = 53;</code>
				/// </summary>
				public ByteString GetTrueCaseTextBytes()
				{
					object @ref = trueCaseText_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						trueCaseText_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// true case gloss of token
				/// </pre>
				/// <code>optional string trueCaseText = 53;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTrueCaseText(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000200));
					trueCaseText_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// true case gloss of token
				/// </pre>
				/// <code>optional string trueCaseText = 53;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearTrueCaseText()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000200)));
					trueCaseText_ = GetDefaultInstance().GetTrueCaseText();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// true case gloss of token
				/// </pre>
				/// <code>optional string trueCaseText = 53;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetTrueCaseTextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000200));
					trueCaseText_ = value;
					OnChanged();
					return this;
				}

				private object chineseChar_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Chinese character info
				/// </pre>
				/// <code>optional string chineseChar = 54;</code>
				/// </summary>
				public bool HasChineseChar()
				{
					return ((bitField1_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary>
				/// <pre>
				/// Chinese character info
				/// </pre>
				/// <code>optional string chineseChar = 54;</code>
				/// </summary>
				public string GetChineseChar()
				{
					object @ref = chineseChar_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							chineseChar_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Chinese character info
				/// </pre>
				/// <code>optional string chineseChar = 54;</code>
				/// </summary>
				public ByteString GetChineseCharBytes()
				{
					object @ref = chineseChar_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						chineseChar_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Chinese character info
				/// </pre>
				/// <code>optional string chineseChar = 54;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetChineseChar(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000400));
					chineseChar_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Chinese character info
				/// </pre>
				/// <code>optional string chineseChar = 54;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearChineseChar()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000400)));
					chineseChar_ = GetDefaultInstance().GetChineseChar();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Chinese character info
				/// </pre>
				/// <code>optional string chineseChar = 54;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetChineseCharBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000400));
					chineseChar_ = value;
					OnChanged();
					return this;
				}

				private object chineseSeg_ = string.Empty;

				/// <summary><code>optional string chineseSeg = 55;</code></summary>
				public bool HasChineseSeg()
				{
					return ((bitField1_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary><code>optional string chineseSeg = 55;</code></summary>
				public string GetChineseSeg()
				{
					object @ref = chineseSeg_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							chineseSeg_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string chineseSeg = 55;</code></summary>
				public ByteString GetChineseSegBytes()
				{
					object @ref = chineseSeg_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						chineseSeg_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string chineseSeg = 55;</code></summary>
				public CoreNLPProtos.Token.Builder SetChineseSeg(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000800));
					chineseSeg_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string chineseSeg = 55;</code></summary>
				public CoreNLPProtos.Token.Builder ClearChineseSeg()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000800)));
					chineseSeg_ = GetDefaultInstance().GetChineseSeg();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string chineseSeg = 55;</code></summary>
				public CoreNLPProtos.Token.Builder SetChineseSegBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00000800));
					chineseSeg_ = value;
					OnChanged();
					return this;
				}

				private object chineseXMLChar_ = string.Empty;

				/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
				public bool HasChineseXMLChar()
				{
					return ((bitField1_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
				}

				/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
				public string GetChineseXMLChar()
				{
					object @ref = chineseXMLChar_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							chineseXMLChar_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
				public ByteString GetChineseXMLCharBytes()
				{
					object @ref = chineseXMLChar_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						chineseXMLChar_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
				public CoreNLPProtos.Token.Builder SetChineseXMLChar(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00001000));
					chineseXMLChar_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
				public CoreNLPProtos.Token.Builder ClearChineseXMLChar()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00001000)));
					chineseXMLChar_ = GetDefaultInstance().GetChineseXMLChar();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string chineseXMLChar = 60;</code></summary>
				public CoreNLPProtos.Token.Builder SetChineseXMLCharBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00001000));
					chineseXMLChar_ = value;
					OnChanged();
					return this;
				}

				private object sectionName_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Section info
				/// </pre>
				/// <code>optional string sectionName = 56;</code>
				/// </summary>
				public bool HasSectionName()
				{
					return ((bitField1_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
				}

				/// <summary>
				/// <pre>
				/// Section info
				/// </pre>
				/// <code>optional string sectionName = 56;</code>
				/// </summary>
				public string GetSectionName()
				{
					object @ref = sectionName_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sectionName_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Section info
				/// </pre>
				/// <code>optional string sectionName = 56;</code>
				/// </summary>
				public ByteString GetSectionNameBytes()
				{
					object @ref = sectionName_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sectionName_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Section info
				/// </pre>
				/// <code>optional string sectionName = 56;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSectionName(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00002000));
					sectionName_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Section info
				/// </pre>
				/// <code>optional string sectionName = 56;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearSectionName()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00002000)));
					sectionName_ = GetDefaultInstance().GetSectionName();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Section info
				/// </pre>
				/// <code>optional string sectionName = 56;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetSectionNameBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00002000));
					sectionName_ = value;
					OnChanged();
					return this;
				}

				private object sectionAuthor_ = string.Empty;

				/// <summary><code>optional string sectionAuthor = 57;</code></summary>
				public bool HasSectionAuthor()
				{
					return ((bitField1_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
				}

				/// <summary><code>optional string sectionAuthor = 57;</code></summary>
				public string GetSectionAuthor()
				{
					object @ref = sectionAuthor_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sectionAuthor_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string sectionAuthor = 57;</code></summary>
				public ByteString GetSectionAuthorBytes()
				{
					object @ref = sectionAuthor_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sectionAuthor_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string sectionAuthor = 57;</code></summary>
				public CoreNLPProtos.Token.Builder SetSectionAuthor(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00004000));
					sectionAuthor_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sectionAuthor = 57;</code></summary>
				public CoreNLPProtos.Token.Builder ClearSectionAuthor()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00004000)));
					sectionAuthor_ = GetDefaultInstance().GetSectionAuthor();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sectionAuthor = 57;</code></summary>
				public CoreNLPProtos.Token.Builder SetSectionAuthorBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00004000));
					sectionAuthor_ = value;
					OnChanged();
					return this;
				}

				private object sectionDate_ = string.Empty;

				/// <summary><code>optional string sectionDate = 58;</code></summary>
				public bool HasSectionDate()
				{
					return ((bitField1_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
				}

				/// <summary><code>optional string sectionDate = 58;</code></summary>
				public string GetSectionDate()
				{
					object @ref = sectionDate_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sectionDate_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string sectionDate = 58;</code></summary>
				public ByteString GetSectionDateBytes()
				{
					object @ref = sectionDate_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sectionDate_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string sectionDate = 58;</code></summary>
				public CoreNLPProtos.Token.Builder SetSectionDate(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00008000));
					sectionDate_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sectionDate = 58;</code></summary>
				public CoreNLPProtos.Token.Builder ClearSectionDate()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00008000)));
					sectionDate_ = GetDefaultInstance().GetSectionDate();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sectionDate = 58;</code></summary>
				public CoreNLPProtos.Token.Builder SetSectionDateBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00008000));
					sectionDate_ = value;
					OnChanged();
					return this;
				}

				private object sectionEndLabel_ = string.Empty;

				/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
				public bool HasSectionEndLabel()
				{
					return ((bitField1_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
				}

				/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
				public string GetSectionEndLabel()
				{
					object @ref = sectionEndLabel_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							sectionEndLabel_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
				public ByteString GetSectionEndLabelBytes()
				{
					object @ref = sectionEndLabel_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						sectionEndLabel_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
				public CoreNLPProtos.Token.Builder SetSectionEndLabel(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00010000));
					sectionEndLabel_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
				public CoreNLPProtos.Token.Builder ClearSectionEndLabel()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00010000)));
					sectionEndLabel_ = GetDefaultInstance().GetSectionEndLabel();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string sectionEndLabel = 59;</code></summary>
				public CoreNLPProtos.Token.Builder SetSectionEndLabelBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00010000));
					sectionEndLabel_ = value;
					OnChanged();
					return this;
				}

				private object parent_ = string.Empty;

				/// <summary>
				/// <pre>
				/// French tokens have parents
				/// </pre>
				/// <code>optional string parent = 61;</code>
				/// </summary>
				public bool HasParent()
				{
					return ((bitField1_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
				}

				/// <summary>
				/// <pre>
				/// French tokens have parents
				/// </pre>
				/// <code>optional string parent = 61;</code>
				/// </summary>
				public string GetParent()
				{
					object @ref = parent_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							parent_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// French tokens have parents
				/// </pre>
				/// <code>optional string parent = 61;</code>
				/// </summary>
				public ByteString GetParentBytes()
				{
					object @ref = parent_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						parent_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// French tokens have parents
				/// </pre>
				/// <code>optional string parent = 61;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetParent(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00020000));
					parent_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// French tokens have parents
				/// </pre>
				/// <code>optional string parent = 61;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearParent()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00020000)));
					parent_ = GetDefaultInstance().GetParent();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// French tokens have parents
				/// </pre>
				/// <code>optional string parent = 61;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetParentBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField1_ |= unchecked((int)(0x00020000));
					parent_ = value;
					OnChanged();
					return this;
				}

				private IList<int> corefMentionIndex_ = Java.Util.Collections.EmptyList();

				private void EnsureCorefMentionIndexIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						corefMentionIndex_ = new List<int>(corefMentionIndex_);
						bitField1_ |= unchecked((int)(0x00040000));
					}
				}

				/// <summary>
				/// <pre>
				/// mention index info
				/// </pre>
				/// <code>repeated uint32 corefMentionIndex = 64;</code>
				/// </summary>
				public IList<int> GetCorefMentionIndexList()
				{
					return Java.Util.Collections.UnmodifiableList(corefMentionIndex_);
				}

				/// <summary>
				/// <pre>
				/// mention index info
				/// </pre>
				/// <code>repeated uint32 corefMentionIndex = 64;</code>
				/// </summary>
				public int GetCorefMentionIndexCount()
				{
					return corefMentionIndex_.Count;
				}

				/// <summary>
				/// <pre>
				/// mention index info
				/// </pre>
				/// <code>repeated uint32 corefMentionIndex = 64;</code>
				/// </summary>
				public int GetCorefMentionIndex(int index)
				{
					return corefMentionIndex_[index];
				}

				/// <summary>
				/// <pre>
				/// mention index info
				/// </pre>
				/// <code>repeated uint32 corefMentionIndex = 64;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder SetCorefMentionIndex(int index, int value)
				{
					EnsureCorefMentionIndexIsMutable();
					corefMentionIndex_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// mention index info
				/// </pre>
				/// <code>repeated uint32 corefMentionIndex = 64;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder AddCorefMentionIndex(int value)
				{
					EnsureCorefMentionIndexIsMutable();
					corefMentionIndex_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// mention index info
				/// </pre>
				/// <code>repeated uint32 corefMentionIndex = 64;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder AddAllCorefMentionIndex<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureCorefMentionIndexIsMutable();
					AbstractMessageLite.Builder.AddAll(values, corefMentionIndex_);
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// mention index info
				/// </pre>
				/// <code>repeated uint32 corefMentionIndex = 64;</code>
				/// </summary>
				public CoreNLPProtos.Token.Builder ClearCorefMentionIndex()
				{
					corefMentionIndex_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00040000)));
					OnChanged();
					return this;
				}

				private int entityMentionIndex_;

				/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
				public bool HasEntityMentionIndex()
				{
					return ((bitField1_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
				}

				/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
				public int GetEntityMentionIndex()
				{
					return entityMentionIndex_;
				}

				/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
				public CoreNLPProtos.Token.Builder SetEntityMentionIndex(int value)
				{
					bitField1_ |= unchecked((int)(0x00080000));
					entityMentionIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 entityMentionIndex = 65;</code></summary>
				public CoreNLPProtos.Token.Builder ClearEntityMentionIndex()
				{
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00080000)));
					entityMentionIndex_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Token.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Token)
			}

			private static readonly CoreNLPProtos.Token DefaultInstance;

			static Token()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Token)
				DefaultInstance = new CoreNLPProtos.Token();
			}

			public static CoreNLPProtos.Token GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_25745 : AbstractParser<CoreNLPProtos.Token>
			{
				public _AbstractParser_25745()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Token ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Token(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Token> Parser = new _AbstractParser_25745();

			public static IParser<CoreNLPProtos.Token> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IQuoteOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Quote)
			/// <summary><code>optional string text = 1;</code></summary>
			bool HasText();

			/// <summary><code>optional string text = 1;</code></summary>
			string GetText();

			/// <summary><code>optional string text = 1;</code></summary>
			ByteString GetTextBytes();

			/// <summary><code>optional uint32 begin = 2;</code></summary>
			bool HasBegin();

			/// <summary><code>optional uint32 begin = 2;</code></summary>
			int GetBegin();

			/// <summary><code>optional uint32 end = 3;</code></summary>
			bool HasEnd();

			/// <summary><code>optional uint32 end = 3;</code></summary>
			int GetEnd();

			/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
			bool HasSentenceBegin();

			/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
			int GetSentenceBegin();

			/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
			bool HasSentenceEnd();

			/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
			int GetSentenceEnd();

			/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
			bool HasTokenBegin();

			/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
			int GetTokenBegin();

			/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
			bool HasTokenEnd();

			/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
			int GetTokenEnd();

			/// <summary><code>optional string docid = 9;</code></summary>
			bool HasDocid();

			/// <summary><code>optional string docid = 9;</code></summary>
			string GetDocid();

			/// <summary><code>optional string docid = 9;</code></summary>
			ByteString GetDocidBytes();

			/// <summary><code>optional uint32 index = 10;</code></summary>
			bool HasIndex();

			/// <summary><code>optional uint32 index = 10;</code></summary>
			int GetIndex();

			/// <summary><code>optional string author = 11;</code></summary>
			bool HasAuthor();

			/// <summary><code>optional string author = 11;</code></summary>
			string GetAuthor();

			/// <summary><code>optional string author = 11;</code></summary>
			ByteString GetAuthorBytes();

			/// <summary><code>optional string mention = 12;</code></summary>
			bool HasMention();

			/// <summary><code>optional string mention = 12;</code></summary>
			string GetMention();

			/// <summary><code>optional string mention = 12;</code></summary>
			ByteString GetMentionBytes();

			/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
			bool HasMentionBegin();

			/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
			int GetMentionBegin();

			/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
			bool HasMentionEnd();

			/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
			int GetMentionEnd();

			/// <summary><code>optional string mentionType = 15;</code></summary>
			bool HasMentionType();

			/// <summary><code>optional string mentionType = 15;</code></summary>
			string GetMentionType();

			/// <summary><code>optional string mentionType = 15;</code></summary>
			ByteString GetMentionTypeBytes();

			/// <summary><code>optional string mentionSieve = 16;</code></summary>
			bool HasMentionSieve();

			/// <summary><code>optional string mentionSieve = 16;</code></summary>
			string GetMentionSieve();

			/// <summary><code>optional string mentionSieve = 16;</code></summary>
			ByteString GetMentionSieveBytes();

			/// <summary><code>optional string speaker = 17;</code></summary>
			bool HasSpeaker();

			/// <summary><code>optional string speaker = 17;</code></summary>
			string GetSpeaker();

			/// <summary><code>optional string speaker = 17;</code></summary>
			ByteString GetSpeakerBytes();

			/// <summary><code>optional string speakerSieve = 18;</code></summary>
			bool HasSpeakerSieve();

			/// <summary><code>optional string speakerSieve = 18;</code></summary>
			string GetSpeakerSieve();

			/// <summary><code>optional string speakerSieve = 18;</code></summary>
			ByteString GetSpeakerSieveBytes();

			/// <summary><code>optional string canonicalMention = 19;</code></summary>
			bool HasCanonicalMention();

			/// <summary><code>optional string canonicalMention = 19;</code></summary>
			string GetCanonicalMention();

			/// <summary><code>optional string canonicalMention = 19;</code></summary>
			ByteString GetCanonicalMentionBytes();

			/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
			bool HasCanonicalMentionBegin();

			/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
			int GetCanonicalMentionBegin();

			/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
			bool HasCanonicalMentionEnd();

			/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
			int GetCanonicalMentionEnd();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
			bool HasAttributionDependencyGraph();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
			CoreNLPProtos.DependencyGraph GetAttributionDependencyGraph();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetAttributionDependencyGraphOrBuilder();
		}

		/// <summary>
		/// <pre>
		/// A quotation marker in text
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Quote</c>
		/// </summary>
		[System.Serializable]
		public sealed class Quote : GeneratedMessageV3, CoreNLPProtos.IQuoteOrBuilder
		{
			private Quote(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Quote()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Quote)
				// Use Quote.newBuilder() to construct.
				text_ = string.Empty;
				begin_ = 0;
				end_ = 0;
				sentenceBegin_ = 0;
				sentenceEnd_ = 0;
				tokenBegin_ = 0;
				tokenEnd_ = 0;
				docid_ = string.Empty;
				index_ = 0;
				author_ = string.Empty;
				mention_ = string.Empty;
				mentionBegin_ = 0;
				mentionEnd_ = 0;
				mentionType_ = string.Empty;
				mentionSieve_ = string.Empty;
				speaker_ = string.Empty;
				speakerSieve_ = string.Empty;
				canonicalMention_ = string.Empty;
				canonicalMentionBegin_ = 0;
				canonicalMentionEnd_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Quote(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								text_ = bs;
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								begin_ = input.ReadUInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								end_ = input.ReadUInt32();
								break;
							}

							case 40:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								sentenceBegin_ = input.ReadUInt32();
								break;
							}

							case 48:
							{
								bitField0_ |= unchecked((int)(0x00000010));
								sentenceEnd_ = input.ReadUInt32();
								break;
							}

							case 56:
							{
								bitField0_ |= unchecked((int)(0x00000020));
								tokenBegin_ = input.ReadUInt32();
								break;
							}

							case 64:
							{
								bitField0_ |= unchecked((int)(0x00000040));
								tokenEnd_ = input.ReadUInt32();
								break;
							}

							case 74:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000080));
								docid_ = bs;
								break;
							}

							case 80:
							{
								bitField0_ |= unchecked((int)(0x00000100));
								index_ = input.ReadUInt32();
								break;
							}

							case 90:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000200));
								author_ = bs;
								break;
							}

							case 98:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000400));
								mention_ = bs;
								break;
							}

							case 104:
							{
								bitField0_ |= unchecked((int)(0x00000800));
								mentionBegin_ = input.ReadUInt32();
								break;
							}

							case 112:
							{
								bitField0_ |= unchecked((int)(0x00001000));
								mentionEnd_ = input.ReadUInt32();
								break;
							}

							case 122:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00002000));
								mentionType_ = bs;
								break;
							}

							case 130:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00004000));
								mentionSieve_ = bs;
								break;
							}

							case 138:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00008000));
								speaker_ = bs;
								break;
							}

							case 146:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00010000));
								speakerSieve_ = bs;
								break;
							}

							case 154:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00020000));
								canonicalMention_ = bs;
								break;
							}

							case 160:
							{
								bitField0_ |= unchecked((int)(0x00040000));
								canonicalMentionBegin_ = input.ReadUInt32();
								break;
							}

							case 168:
							{
								bitField0_ |= unchecked((int)(0x00080000));
								canonicalMentionEnd_ = input.ReadUInt32();
								break;
							}

							case 178:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)attributionDependencyGraph_.ToBuilder());
								}
								attributionDependencyGraph_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(attributionDependencyGraph_);
									attributionDependencyGraph_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00100000));
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Quote_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Quote_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Quote), typeof(CoreNLPProtos.Quote.Builder));
			}

			private int bitField0_;

			public const int TextFieldNumber = 1;

			private volatile object text_;

			/// <summary><code>optional string text = 1;</code></summary>
			public bool HasText()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional string text = 1;</code></summary>
			public string GetText()
			{
				object @ref = text_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						text_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string text = 1;</code></summary>
			public ByteString GetTextBytes()
			{
				object @ref = text_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					text_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int BeginFieldNumber = 2;

			private int begin_;

			/// <summary><code>optional uint32 begin = 2;</code></summary>
			public bool HasBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional uint32 begin = 2;</code></summary>
			public int GetBegin()
			{
				return begin_;
			}

			public const int EndFieldNumber = 3;

			private int end_;

			/// <summary><code>optional uint32 end = 3;</code></summary>
			public bool HasEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional uint32 end = 3;</code></summary>
			public int GetEnd()
			{
				return end_;
			}

			public const int SentencebeginFieldNumber = 5;

			private int sentenceBegin_;

			/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
			public bool HasSentenceBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
			public int GetSentenceBegin()
			{
				return sentenceBegin_;
			}

			public const int SentenceendFieldNumber = 6;

			private int sentenceEnd_;

			/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
			public bool HasSentenceEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
			public int GetSentenceEnd()
			{
				return sentenceEnd_;
			}

			public const int TokenbeginFieldNumber = 7;

			private int tokenBegin_;

			/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
			public bool HasTokenBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
			public int GetTokenBegin()
			{
				return tokenBegin_;
			}

			public const int TokenendFieldNumber = 8;

			private int tokenEnd_;

			/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
			public bool HasTokenEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
			public int GetTokenEnd()
			{
				return tokenEnd_;
			}

			public const int DocidFieldNumber = 9;

			private volatile object docid_;

			/// <summary><code>optional string docid = 9;</code></summary>
			public bool HasDocid()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary><code>optional string docid = 9;</code></summary>
			public string GetDocid()
			{
				object @ref = docid_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						docid_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string docid = 9;</code></summary>
			public ByteString GetDocidBytes()
			{
				object @ref = docid_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					docid_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int IndexFieldNumber = 10;

			private int index_;

			/// <summary><code>optional uint32 index = 10;</code></summary>
			public bool HasIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary><code>optional uint32 index = 10;</code></summary>
			public int GetIndex()
			{
				return index_;
			}

			public const int AuthorFieldNumber = 11;

			private volatile object author_;

			/// <summary><code>optional string author = 11;</code></summary>
			public bool HasAuthor()
			{
				return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
			}

			/// <summary><code>optional string author = 11;</code></summary>
			public string GetAuthor()
			{
				object @ref = author_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						author_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string author = 11;</code></summary>
			public ByteString GetAuthorBytes()
			{
				object @ref = author_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					author_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int MentionFieldNumber = 12;

			private volatile object mention_;

			/// <summary><code>optional string mention = 12;</code></summary>
			public bool HasMention()
			{
				return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
			}

			/// <summary><code>optional string mention = 12;</code></summary>
			public string GetMention()
			{
				object @ref = mention_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						mention_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string mention = 12;</code></summary>
			public ByteString GetMentionBytes()
			{
				object @ref = mention_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					mention_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int MentionbeginFieldNumber = 13;

			private int mentionBegin_;

			/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
			public bool HasMentionBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
			}

			/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
			public int GetMentionBegin()
			{
				return mentionBegin_;
			}

			public const int MentionendFieldNumber = 14;

			private int mentionEnd_;

			/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
			public bool HasMentionEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
			}

			/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
			public int GetMentionEnd()
			{
				return mentionEnd_;
			}

			public const int MentiontypeFieldNumber = 15;

			private volatile object mentionType_;

			/// <summary><code>optional string mentionType = 15;</code></summary>
			public bool HasMentionType()
			{
				return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
			}

			/// <summary><code>optional string mentionType = 15;</code></summary>
			public string GetMentionType()
			{
				object @ref = mentionType_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						mentionType_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string mentionType = 15;</code></summary>
			public ByteString GetMentionTypeBytes()
			{
				object @ref = mentionType_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					mentionType_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int MentionsieveFieldNumber = 16;

			private volatile object mentionSieve_;

			/// <summary><code>optional string mentionSieve = 16;</code></summary>
			public bool HasMentionSieve()
			{
				return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
			}

			/// <summary><code>optional string mentionSieve = 16;</code></summary>
			public string GetMentionSieve()
			{
				object @ref = mentionSieve_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						mentionSieve_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string mentionSieve = 16;</code></summary>
			public ByteString GetMentionSieveBytes()
			{
				object @ref = mentionSieve_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					mentionSieve_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SpeakerFieldNumber = 17;

			private volatile object speaker_;

			/// <summary><code>optional string speaker = 17;</code></summary>
			public bool HasSpeaker()
			{
				return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
			}

			/// <summary><code>optional string speaker = 17;</code></summary>
			public string GetSpeaker()
			{
				object @ref = speaker_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						speaker_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string speaker = 17;</code></summary>
			public ByteString GetSpeakerBytes()
			{
				object @ref = speaker_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					speaker_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SpeakersieveFieldNumber = 18;

			private volatile object speakerSieve_;

			/// <summary><code>optional string speakerSieve = 18;</code></summary>
			public bool HasSpeakerSieve()
			{
				return ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
			}

			/// <summary><code>optional string speakerSieve = 18;</code></summary>
			public string GetSpeakerSieve()
			{
				object @ref = speakerSieve_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						speakerSieve_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string speakerSieve = 18;</code></summary>
			public ByteString GetSpeakerSieveBytes()
			{
				object @ref = speakerSieve_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					speakerSieve_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int CanonicalmentionFieldNumber = 19;

			private volatile object canonicalMention_;

			/// <summary><code>optional string canonicalMention = 19;</code></summary>
			public bool HasCanonicalMention()
			{
				return ((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
			}

			/// <summary><code>optional string canonicalMention = 19;</code></summary>
			public string GetCanonicalMention()
			{
				object @ref = canonicalMention_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						canonicalMention_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string canonicalMention = 19;</code></summary>
			public ByteString GetCanonicalMentionBytes()
			{
				object @ref = canonicalMention_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					canonicalMention_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int CanonicalmentionbeginFieldNumber = 20;

			private int canonicalMentionBegin_;

			/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
			public bool HasCanonicalMentionBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000)));
			}

			/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
			public int GetCanonicalMentionBegin()
			{
				return canonicalMentionBegin_;
			}

			public const int CanonicalmentionendFieldNumber = 21;

			private int canonicalMentionEnd_;

			/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
			public bool HasCanonicalMentionEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
			}

			/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
			public int GetCanonicalMentionEnd()
			{
				return canonicalMentionEnd_;
			}

			public const int AttributiondependencygraphFieldNumber = 22;

			private CoreNLPProtos.DependencyGraph attributionDependencyGraph_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
			public bool HasAttributionDependencyGraph()
			{
				return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
			public CoreNLPProtos.DependencyGraph GetAttributionDependencyGraph()
			{
				return attributionDependencyGraph_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : attributionDependencyGraph_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetAttributionDependencyGraphOrBuilder()
			{
				return attributionDependencyGraph_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : attributionDependencyGraph_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (HasAttributionDependencyGraph())
				{
					if (!GetAttributionDependencyGraph().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 1, text_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(2, begin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteUInt32(3, end_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteUInt32(5, sentenceBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteUInt32(6, sentenceEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteUInt32(7, tokenBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteUInt32(8, tokenEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					GeneratedMessageV3.WriteString(output, 9, docid_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					output.WriteUInt32(10, index_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					GeneratedMessageV3.WriteString(output, 11, author_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					GeneratedMessageV3.WriteString(output, 12, mention_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					output.WriteUInt32(13, mentionBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					output.WriteUInt32(14, mentionEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					GeneratedMessageV3.WriteString(output, 15, mentionType_);
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					GeneratedMessageV3.WriteString(output, 16, mentionSieve_);
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					GeneratedMessageV3.WriteString(output, 17, speaker_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					GeneratedMessageV3.WriteString(output, 18, speakerSieve_);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					GeneratedMessageV3.WriteString(output, 19, canonicalMention_);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					output.WriteUInt32(20, canonicalMentionBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					output.WriteUInt32(21, canonicalMentionEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					output.WriteMessage(22, GetAttributionDependencyGraph());
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, text_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, begin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, end_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeUInt32Size(5, sentenceBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeUInt32Size(6, sentenceEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeUInt32Size(7, tokenBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeUInt32Size(8, tokenEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += GeneratedMessageV3.ComputeStringSize(9, docid_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += CodedOutputStream.ComputeUInt32Size(10, index_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					size += GeneratedMessageV3.ComputeStringSize(11, author_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					size += GeneratedMessageV3.ComputeStringSize(12, mention_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					size += CodedOutputStream.ComputeUInt32Size(13, mentionBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(14, mentionEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(15, mentionType_);
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(16, mentionSieve_);
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(17, speaker_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(18, speakerSieve_);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					size += GeneratedMessageV3.ComputeStringSize(19, canonicalMention_);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(20, canonicalMentionBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(21, canonicalMentionEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					size += CodedOutputStream.ComputeMessageSize(22, GetAttributionDependencyGraph());
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Quote))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Quote other = (CoreNLPProtos.Quote)obj;
				bool result = true;
				result = result && (HasText() == other.HasText());
				if (HasText())
				{
					result = result && GetText().Equals(other.GetText());
				}
				result = result && (HasBegin() == other.HasBegin());
				if (HasBegin())
				{
					result = result && (GetBegin() == other.GetBegin());
				}
				result = result && (HasEnd() == other.HasEnd());
				if (HasEnd())
				{
					result = result && (GetEnd() == other.GetEnd());
				}
				result = result && (HasSentenceBegin() == other.HasSentenceBegin());
				if (HasSentenceBegin())
				{
					result = result && (GetSentenceBegin() == other.GetSentenceBegin());
				}
				result = result && (HasSentenceEnd() == other.HasSentenceEnd());
				if (HasSentenceEnd())
				{
					result = result && (GetSentenceEnd() == other.GetSentenceEnd());
				}
				result = result && (HasTokenBegin() == other.HasTokenBegin());
				if (HasTokenBegin())
				{
					result = result && (GetTokenBegin() == other.GetTokenBegin());
				}
				result = result && (HasTokenEnd() == other.HasTokenEnd());
				if (HasTokenEnd())
				{
					result = result && (GetTokenEnd() == other.GetTokenEnd());
				}
				result = result && (HasDocid() == other.HasDocid());
				if (HasDocid())
				{
					result = result && GetDocid().Equals(other.GetDocid());
				}
				result = result && (HasIndex() == other.HasIndex());
				if (HasIndex())
				{
					result = result && (GetIndex() == other.GetIndex());
				}
				result = result && (HasAuthor() == other.HasAuthor());
				if (HasAuthor())
				{
					result = result && GetAuthor().Equals(other.GetAuthor());
				}
				result = result && (HasMention() == other.HasMention());
				if (HasMention())
				{
					result = result && GetMention().Equals(other.GetMention());
				}
				result = result && (HasMentionBegin() == other.HasMentionBegin());
				if (HasMentionBegin())
				{
					result = result && (GetMentionBegin() == other.GetMentionBegin());
				}
				result = result && (HasMentionEnd() == other.HasMentionEnd());
				if (HasMentionEnd())
				{
					result = result && (GetMentionEnd() == other.GetMentionEnd());
				}
				result = result && (HasMentionType() == other.HasMentionType());
				if (HasMentionType())
				{
					result = result && GetMentionType().Equals(other.GetMentionType());
				}
				result = result && (HasMentionSieve() == other.HasMentionSieve());
				if (HasMentionSieve())
				{
					result = result && GetMentionSieve().Equals(other.GetMentionSieve());
				}
				result = result && (HasSpeaker() == other.HasSpeaker());
				if (HasSpeaker())
				{
					result = result && GetSpeaker().Equals(other.GetSpeaker());
				}
				result = result && (HasSpeakerSieve() == other.HasSpeakerSieve());
				if (HasSpeakerSieve())
				{
					result = result && GetSpeakerSieve().Equals(other.GetSpeakerSieve());
				}
				result = result && (HasCanonicalMention() == other.HasCanonicalMention());
				if (HasCanonicalMention())
				{
					result = result && GetCanonicalMention().Equals(other.GetCanonicalMention());
				}
				result = result && (HasCanonicalMentionBegin() == other.HasCanonicalMentionBegin());
				if (HasCanonicalMentionBegin())
				{
					result = result && (GetCanonicalMentionBegin() == other.GetCanonicalMentionBegin());
				}
				result = result && (HasCanonicalMentionEnd() == other.HasCanonicalMentionEnd());
				if (HasCanonicalMentionEnd())
				{
					result = result && (GetCanonicalMentionEnd() == other.GetCanonicalMentionEnd());
				}
				result = result && (HasAttributionDependencyGraph() == other.HasAttributionDependencyGraph());
				if (HasAttributionDependencyGraph())
				{
					result = result && GetAttributionDependencyGraph().Equals(other.GetAttributionDependencyGraph());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasText())
				{
					hash = (37 * hash) + TextFieldNumber;
					hash = (53 * hash) + GetText().GetHashCode();
				}
				if (HasBegin())
				{
					hash = (37 * hash) + BeginFieldNumber;
					hash = (53 * hash) + GetBegin();
				}
				if (HasEnd())
				{
					hash = (37 * hash) + EndFieldNumber;
					hash = (53 * hash) + GetEnd();
				}
				if (HasSentenceBegin())
				{
					hash = (37 * hash) + SentencebeginFieldNumber;
					hash = (53 * hash) + GetSentenceBegin();
				}
				if (HasSentenceEnd())
				{
					hash = (37 * hash) + SentenceendFieldNumber;
					hash = (53 * hash) + GetSentenceEnd();
				}
				if (HasTokenBegin())
				{
					hash = (37 * hash) + TokenbeginFieldNumber;
					hash = (53 * hash) + GetTokenBegin();
				}
				if (HasTokenEnd())
				{
					hash = (37 * hash) + TokenendFieldNumber;
					hash = (53 * hash) + GetTokenEnd();
				}
				if (HasDocid())
				{
					hash = (37 * hash) + DocidFieldNumber;
					hash = (53 * hash) + GetDocid().GetHashCode();
				}
				if (HasIndex())
				{
					hash = (37 * hash) + IndexFieldNumber;
					hash = (53 * hash) + GetIndex();
				}
				if (HasAuthor())
				{
					hash = (37 * hash) + AuthorFieldNumber;
					hash = (53 * hash) + GetAuthor().GetHashCode();
				}
				if (HasMention())
				{
					hash = (37 * hash) + MentionFieldNumber;
					hash = (53 * hash) + GetMention().GetHashCode();
				}
				if (HasMentionBegin())
				{
					hash = (37 * hash) + MentionbeginFieldNumber;
					hash = (53 * hash) + GetMentionBegin();
				}
				if (HasMentionEnd())
				{
					hash = (37 * hash) + MentionendFieldNumber;
					hash = (53 * hash) + GetMentionEnd();
				}
				if (HasMentionType())
				{
					hash = (37 * hash) + MentiontypeFieldNumber;
					hash = (53 * hash) + GetMentionType().GetHashCode();
				}
				if (HasMentionSieve())
				{
					hash = (37 * hash) + MentionsieveFieldNumber;
					hash = (53 * hash) + GetMentionSieve().GetHashCode();
				}
				if (HasSpeaker())
				{
					hash = (37 * hash) + SpeakerFieldNumber;
					hash = (53 * hash) + GetSpeaker().GetHashCode();
				}
				if (HasSpeakerSieve())
				{
					hash = (37 * hash) + SpeakersieveFieldNumber;
					hash = (53 * hash) + GetSpeakerSieve().GetHashCode();
				}
				if (HasCanonicalMention())
				{
					hash = (37 * hash) + CanonicalmentionFieldNumber;
					hash = (53 * hash) + GetCanonicalMention().GetHashCode();
				}
				if (HasCanonicalMentionBegin())
				{
					hash = (37 * hash) + CanonicalmentionbeginFieldNumber;
					hash = (53 * hash) + GetCanonicalMentionBegin();
				}
				if (HasCanonicalMentionEnd())
				{
					hash = (37 * hash) + CanonicalmentionendFieldNumber;
					hash = (53 * hash) + GetCanonicalMentionEnd();
				}
				if (HasAttributionDependencyGraph())
				{
					hash = (37 * hash) + AttributiondependencygraphFieldNumber;
					hash = (53 * hash) + GetAttributionDependencyGraph().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Quote ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Quote ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Quote ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Quote ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Quote ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Quote ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Quote ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Quote ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Quote ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Quote ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Quote.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Quote.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Quote.Builder NewBuilder(CoreNLPProtos.Quote prototype)
			{
				return ((CoreNLPProtos.Quote.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Quote.Builder() : new CoreNLPProtos.Quote.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Quote.Builder builder = new CoreNLPProtos.Quote.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A quotation marker in text
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Quote</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Quote.Builder>, CoreNLPProtos.IQuoteOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Quote)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Quote_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Quote_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Quote), typeof(CoreNLPProtos.Quote.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Quote.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetAttributionDependencyGraphFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					text_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					begin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					end_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					sentenceBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					sentenceEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					tokenBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					tokenEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					docid_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					index_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					author_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					mention_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					mentionBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					mentionEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					mentionType_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					mentionSieve_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					speaker_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					speakerSieve_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					canonicalMention_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					canonicalMentionBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
					canonicalMentionEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					if (attributionDependencyGraphBuilder_ == null)
					{
						attributionDependencyGraph_ = null;
					}
					else
					{
						attributionDependencyGraphBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Quote_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Quote.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Quote result = ((CoreNLPProtos.Quote)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Quote result = new CoreNLPProtos.Quote(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.text_ = text_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.begin_ = begin_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.end_ = end_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.sentenceBegin_ = sentenceBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.sentenceEnd_ = sentenceEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.tokenBegin_ = tokenBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.tokenEnd_ = tokenEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					result.docid_ = docid_;
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000100));
					}
					result.index_ = index_;
					if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x00000200));
					}
					result.author_ = author_;
					if (((from_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x00000400));
					}
					result.mention_ = mention_;
					if (((from_bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField0_ |= unchecked((int)(0x00000800));
					}
					result.mentionBegin_ = mentionBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
					{
						to_bitField0_ |= unchecked((int)(0x00001000));
					}
					result.mentionEnd_ = mentionEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
					{
						to_bitField0_ |= unchecked((int)(0x00002000));
					}
					result.mentionType_ = mentionType_;
					if (((from_bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
					{
						to_bitField0_ |= unchecked((int)(0x00004000));
					}
					result.mentionSieve_ = mentionSieve_;
					if (((from_bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
					{
						to_bitField0_ |= unchecked((int)(0x00008000));
					}
					result.speaker_ = speaker_;
					if (((from_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						to_bitField0_ |= unchecked((int)(0x00010000));
					}
					result.speakerSieve_ = speakerSieve_;
					if (((from_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						to_bitField0_ |= unchecked((int)(0x00020000));
					}
					result.canonicalMention_ = canonicalMention_;
					if (((from_bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						to_bitField0_ |= unchecked((int)(0x00040000));
					}
					result.canonicalMentionBegin_ = canonicalMentionBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
					{
						to_bitField0_ |= unchecked((int)(0x00080000));
					}
					result.canonicalMentionEnd_ = canonicalMentionEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
					{
						to_bitField0_ |= unchecked((int)(0x00100000));
					}
					if (attributionDependencyGraphBuilder_ == null)
					{
						result.attributionDependencyGraph_ = attributionDependencyGraph_;
					}
					else
					{
						result.attributionDependencyGraph_ = attributionDependencyGraphBuilder_.Build();
					}
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Quote.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Quote.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Quote.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Quote.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Quote.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Quote.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Quote.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Quote.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Quote)
					{
						return MergeFrom((CoreNLPProtos.Quote)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Quote.Builder MergeFrom(CoreNLPProtos.Quote other)
				{
					if (other == CoreNLPProtos.Quote.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasText())
					{
						bitField0_ |= unchecked((int)(0x00000001));
						text_ = other.text_;
						OnChanged();
					}
					if (other.HasBegin())
					{
						SetBegin(other.GetBegin());
					}
					if (other.HasEnd())
					{
						SetEnd(other.GetEnd());
					}
					if (other.HasSentenceBegin())
					{
						SetSentenceBegin(other.GetSentenceBegin());
					}
					if (other.HasSentenceEnd())
					{
						SetSentenceEnd(other.GetSentenceEnd());
					}
					if (other.HasTokenBegin())
					{
						SetTokenBegin(other.GetTokenBegin());
					}
					if (other.HasTokenEnd())
					{
						SetTokenEnd(other.GetTokenEnd());
					}
					if (other.HasDocid())
					{
						bitField0_ |= unchecked((int)(0x00000080));
						docid_ = other.docid_;
						OnChanged();
					}
					if (other.HasIndex())
					{
						SetIndex(other.GetIndex());
					}
					if (other.HasAuthor())
					{
						bitField0_ |= unchecked((int)(0x00000200));
						author_ = other.author_;
						OnChanged();
					}
					if (other.HasMention())
					{
						bitField0_ |= unchecked((int)(0x00000400));
						mention_ = other.mention_;
						OnChanged();
					}
					if (other.HasMentionBegin())
					{
						SetMentionBegin(other.GetMentionBegin());
					}
					if (other.HasMentionEnd())
					{
						SetMentionEnd(other.GetMentionEnd());
					}
					if (other.HasMentionType())
					{
						bitField0_ |= unchecked((int)(0x00002000));
						mentionType_ = other.mentionType_;
						OnChanged();
					}
					if (other.HasMentionSieve())
					{
						bitField0_ |= unchecked((int)(0x00004000));
						mentionSieve_ = other.mentionSieve_;
						OnChanged();
					}
					if (other.HasSpeaker())
					{
						bitField0_ |= unchecked((int)(0x00008000));
						speaker_ = other.speaker_;
						OnChanged();
					}
					if (other.HasSpeakerSieve())
					{
						bitField0_ |= unchecked((int)(0x00010000));
						speakerSieve_ = other.speakerSieve_;
						OnChanged();
					}
					if (other.HasCanonicalMention())
					{
						bitField0_ |= unchecked((int)(0x00020000));
						canonicalMention_ = other.canonicalMention_;
						OnChanged();
					}
					if (other.HasCanonicalMentionBegin())
					{
						SetCanonicalMentionBegin(other.GetCanonicalMentionBegin());
					}
					if (other.HasCanonicalMentionEnd())
					{
						SetCanonicalMentionEnd(other.GetCanonicalMentionEnd());
					}
					if (other.HasAttributionDependencyGraph())
					{
						MergeAttributionDependencyGraph(other.GetAttributionDependencyGraph());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (HasAttributionDependencyGraph())
					{
						if (!GetAttributionDependencyGraph().IsInitialized())
						{
							return false;
						}
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Quote parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Quote)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private object text_ = string.Empty;

				/// <summary><code>optional string text = 1;</code></summary>
				public bool HasText()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional string text = 1;</code></summary>
				public string GetText()
				{
					object @ref = text_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							text_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string text = 1;</code></summary>
				public ByteString GetTextBytes()
				{
					object @ref = text_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						text_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string text = 1;</code></summary>
				public CoreNLPProtos.Quote.Builder SetText(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					text_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string text = 1;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearText()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					text_ = GetDefaultInstance().GetText();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string text = 1;</code></summary>
				public CoreNLPProtos.Quote.Builder SetTextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					text_ = value;
					OnChanged();
					return this;
				}

				private int begin_;

				/// <summary><code>optional uint32 begin = 2;</code></summary>
				public bool HasBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional uint32 begin = 2;</code></summary>
				public int GetBegin()
				{
					return begin_;
				}

				/// <summary><code>optional uint32 begin = 2;</code></summary>
				public CoreNLPProtos.Quote.Builder SetBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					begin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 begin = 2;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					begin_ = 0;
					OnChanged();
					return this;
				}

				private int end_;

				/// <summary><code>optional uint32 end = 3;</code></summary>
				public bool HasEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional uint32 end = 3;</code></summary>
				public int GetEnd()
				{
					return end_;
				}

				/// <summary><code>optional uint32 end = 3;</code></summary>
				public CoreNLPProtos.Quote.Builder SetEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					end_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 end = 3;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					end_ = 0;
					OnChanged();
					return this;
				}

				private int sentenceBegin_;

				/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
				public bool HasSentenceBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
				public int GetSentenceBegin()
				{
					return sentenceBegin_;
				}

				/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
				public CoreNLPProtos.Quote.Builder SetSentenceBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000008));
					sentenceBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 sentenceBegin = 5;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearSentenceBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					sentenceBegin_ = 0;
					OnChanged();
					return this;
				}

				private int sentenceEnd_;

				/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
				public bool HasSentenceEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
				public int GetSentenceEnd()
				{
					return sentenceEnd_;
				}

				/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder SetSentenceEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000010));
					sentenceEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 sentenceEnd = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearSentenceEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					sentenceEnd_ = 0;
					OnChanged();
					return this;
				}

				private int tokenBegin_;

				/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
				public bool HasTokenBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
				public int GetTokenBegin()
				{
					return tokenBegin_;
				}

				/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
				public CoreNLPProtos.Quote.Builder SetTokenBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000020));
					tokenBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 tokenBegin = 7;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearTokenBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					tokenBegin_ = 0;
					OnChanged();
					return this;
				}

				private int tokenEnd_;

				/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
				public bool HasTokenEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
				public int GetTokenEnd()
				{
					return tokenEnd_;
				}

				/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
				public CoreNLPProtos.Quote.Builder SetTokenEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000040));
					tokenEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 tokenEnd = 8;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearTokenEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					tokenEnd_ = 0;
					OnChanged();
					return this;
				}

				private object docid_ = string.Empty;

				/// <summary><code>optional string docid = 9;</code></summary>
				public bool HasDocid()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary><code>optional string docid = 9;</code></summary>
				public string GetDocid()
				{
					object @ref = docid_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							docid_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string docid = 9;</code></summary>
				public ByteString GetDocidBytes()
				{
					object @ref = docid_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						docid_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string docid = 9;</code></summary>
				public CoreNLPProtos.Quote.Builder SetDocid(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					docid_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string docid = 9;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearDocid()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					docid_ = GetDefaultInstance().GetDocid();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string docid = 9;</code></summary>
				public CoreNLPProtos.Quote.Builder SetDocidBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					docid_ = value;
					OnChanged();
					return this;
				}

				private int index_;

				/// <summary><code>optional uint32 index = 10;</code></summary>
				public bool HasIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary><code>optional uint32 index = 10;</code></summary>
				public int GetIndex()
				{
					return index_;
				}

				/// <summary><code>optional uint32 index = 10;</code></summary>
				public CoreNLPProtos.Quote.Builder SetIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000100));
					index_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 index = 10;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					index_ = 0;
					OnChanged();
					return this;
				}

				private object author_ = string.Empty;

				/// <summary><code>optional string author = 11;</code></summary>
				public bool HasAuthor()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary><code>optional string author = 11;</code></summary>
				public string GetAuthor()
				{
					object @ref = author_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							author_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string author = 11;</code></summary>
				public ByteString GetAuthorBytes()
				{
					object @ref = author_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						author_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string author = 11;</code></summary>
				public CoreNLPProtos.Quote.Builder SetAuthor(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					author_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string author = 11;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearAuthor()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					author_ = GetDefaultInstance().GetAuthor();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string author = 11;</code></summary>
				public CoreNLPProtos.Quote.Builder SetAuthorBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					author_ = value;
					OnChanged();
					return this;
				}

				private object mention_ = string.Empty;

				/// <summary><code>optional string mention = 12;</code></summary>
				public bool HasMention()
				{
					return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary><code>optional string mention = 12;</code></summary>
				public string GetMention()
				{
					object @ref = mention_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							mention_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string mention = 12;</code></summary>
				public ByteString GetMentionBytes()
				{
					object @ref = mention_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						mention_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string mention = 12;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMention(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					mention_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mention = 12;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearMention()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					mention_ = GetDefaultInstance().GetMention();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mention = 12;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMentionBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					mention_ = value;
					OnChanged();
					return this;
				}

				private int mentionBegin_;

				/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
				public bool HasMentionBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
				public int GetMentionBegin()
				{
					return mentionBegin_;
				}

				/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMentionBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000800));
					mentionBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 mentionBegin = 13;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearMentionBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					mentionBegin_ = 0;
					OnChanged();
					return this;
				}

				private int mentionEnd_;

				/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
				public bool HasMentionEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
				}

				/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
				public int GetMentionEnd()
				{
					return mentionEnd_;
				}

				/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMentionEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00001000));
					mentionEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 mentionEnd = 14;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearMentionEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					mentionEnd_ = 0;
					OnChanged();
					return this;
				}

				private object mentionType_ = string.Empty;

				/// <summary><code>optional string mentionType = 15;</code></summary>
				public bool HasMentionType()
				{
					return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
				}

				/// <summary><code>optional string mentionType = 15;</code></summary>
				public string GetMentionType()
				{
					object @ref = mentionType_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							mentionType_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string mentionType = 15;</code></summary>
				public ByteString GetMentionTypeBytes()
				{
					object @ref = mentionType_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						mentionType_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string mentionType = 15;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMentionType(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00002000));
					mentionType_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionType = 15;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearMentionType()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					mentionType_ = GetDefaultInstance().GetMentionType();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionType = 15;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMentionTypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00002000));
					mentionType_ = value;
					OnChanged();
					return this;
				}

				private object mentionSieve_ = string.Empty;

				/// <summary><code>optional string mentionSieve = 16;</code></summary>
				public bool HasMentionSieve()
				{
					return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
				}

				/// <summary><code>optional string mentionSieve = 16;</code></summary>
				public string GetMentionSieve()
				{
					object @ref = mentionSieve_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							mentionSieve_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string mentionSieve = 16;</code></summary>
				public ByteString GetMentionSieveBytes()
				{
					object @ref = mentionSieve_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						mentionSieve_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string mentionSieve = 16;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMentionSieve(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00004000));
					mentionSieve_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionSieve = 16;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearMentionSieve()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					mentionSieve_ = GetDefaultInstance().GetMentionSieve();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionSieve = 16;</code></summary>
				public CoreNLPProtos.Quote.Builder SetMentionSieveBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00004000));
					mentionSieve_ = value;
					OnChanged();
					return this;
				}

				private object speaker_ = string.Empty;

				/// <summary><code>optional string speaker = 17;</code></summary>
				public bool HasSpeaker()
				{
					return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
				}

				/// <summary><code>optional string speaker = 17;</code></summary>
				public string GetSpeaker()
				{
					object @ref = speaker_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							speaker_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string speaker = 17;</code></summary>
				public ByteString GetSpeakerBytes()
				{
					object @ref = speaker_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						speaker_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string speaker = 17;</code></summary>
				public CoreNLPProtos.Quote.Builder SetSpeaker(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00008000));
					speaker_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string speaker = 17;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearSpeaker()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					speaker_ = GetDefaultInstance().GetSpeaker();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string speaker = 17;</code></summary>
				public CoreNLPProtos.Quote.Builder SetSpeakerBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00008000));
					speaker_ = value;
					OnChanged();
					return this;
				}

				private object speakerSieve_ = string.Empty;

				/// <summary><code>optional string speakerSieve = 18;</code></summary>
				public bool HasSpeakerSieve()
				{
					return ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
				}

				/// <summary><code>optional string speakerSieve = 18;</code></summary>
				public string GetSpeakerSieve()
				{
					object @ref = speakerSieve_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							speakerSieve_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string speakerSieve = 18;</code></summary>
				public ByteString GetSpeakerSieveBytes()
				{
					object @ref = speakerSieve_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						speakerSieve_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string speakerSieve = 18;</code></summary>
				public CoreNLPProtos.Quote.Builder SetSpeakerSieve(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00010000));
					speakerSieve_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string speakerSieve = 18;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearSpeakerSieve()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					speakerSieve_ = GetDefaultInstance().GetSpeakerSieve();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string speakerSieve = 18;</code></summary>
				public CoreNLPProtos.Quote.Builder SetSpeakerSieveBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00010000));
					speakerSieve_ = value;
					OnChanged();
					return this;
				}

				private object canonicalMention_ = string.Empty;

				/// <summary><code>optional string canonicalMention = 19;</code></summary>
				public bool HasCanonicalMention()
				{
					return ((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
				}

				/// <summary><code>optional string canonicalMention = 19;</code></summary>
				public string GetCanonicalMention()
				{
					object @ref = canonicalMention_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							canonicalMention_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string canonicalMention = 19;</code></summary>
				public ByteString GetCanonicalMentionBytes()
				{
					object @ref = canonicalMention_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						canonicalMention_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string canonicalMention = 19;</code></summary>
				public CoreNLPProtos.Quote.Builder SetCanonicalMention(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00020000));
					canonicalMention_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string canonicalMention = 19;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearCanonicalMention()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					canonicalMention_ = GetDefaultInstance().GetCanonicalMention();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string canonicalMention = 19;</code></summary>
				public CoreNLPProtos.Quote.Builder SetCanonicalMentionBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00020000));
					canonicalMention_ = value;
					OnChanged();
					return this;
				}

				private int canonicalMentionBegin_;

				/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
				public bool HasCanonicalMentionBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000)));
				}

				/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
				public int GetCanonicalMentionBegin()
				{
					return canonicalMentionBegin_;
				}

				/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
				public CoreNLPProtos.Quote.Builder SetCanonicalMentionBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00040000));
					canonicalMentionBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 canonicalMentionBegin = 20;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearCanonicalMentionBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
					canonicalMentionBegin_ = 0;
					OnChanged();
					return this;
				}

				private int canonicalMentionEnd_;

				/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
				public bool HasCanonicalMentionEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
				}

				/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
				public int GetCanonicalMentionEnd()
				{
					return canonicalMentionEnd_;
				}

				/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
				public CoreNLPProtos.Quote.Builder SetCanonicalMentionEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00080000));
					canonicalMentionEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 canonicalMentionEnd = 21;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearCanonicalMentionEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					canonicalMentionEnd_ = 0;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.DependencyGraph attributionDependencyGraph_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> attributionDependencyGraphBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public bool HasAttributionDependencyGraph()
				{
					return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public CoreNLPProtos.DependencyGraph GetAttributionDependencyGraph()
				{
					if (attributionDependencyGraphBuilder_ == null)
					{
						return attributionDependencyGraph_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : attributionDependencyGraph_;
					}
					else
					{
						return attributionDependencyGraphBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public CoreNLPProtos.Quote.Builder SetAttributionDependencyGraph(CoreNLPProtos.DependencyGraph value)
				{
					if (attributionDependencyGraphBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						attributionDependencyGraph_ = value;
						OnChanged();
					}
					else
					{
						attributionDependencyGraphBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public CoreNLPProtos.Quote.Builder SetAttributionDependencyGraph(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (attributionDependencyGraphBuilder_ == null)
					{
						attributionDependencyGraph_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						attributionDependencyGraphBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public CoreNLPProtos.Quote.Builder MergeAttributionDependencyGraph(CoreNLPProtos.DependencyGraph value)
				{
					if (attributionDependencyGraphBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))) && attributionDependencyGraph_ != null && attributionDependencyGraph_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							attributionDependencyGraph_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(attributionDependencyGraph_).MergeFrom(value).BuildPartial());
						}
						else
						{
							attributionDependencyGraph_ = value;
						}
						OnChanged();
					}
					else
					{
						attributionDependencyGraphBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00100000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public CoreNLPProtos.Quote.Builder ClearAttributionDependencyGraph()
				{
					if (attributionDependencyGraphBuilder_ == null)
					{
						attributionDependencyGraph_ = null;
						OnChanged();
					}
					else
					{
						attributionDependencyGraphBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder GetAttributionDependencyGraphBuilder()
				{
					bitField0_ |= unchecked((int)(0x00100000));
					OnChanged();
					return GetAttributionDependencyGraphFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetAttributionDependencyGraphOrBuilder()
				{
					if (attributionDependencyGraphBuilder_ != null)
					{
						return attributionDependencyGraphBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return attributionDependencyGraph_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : attributionDependencyGraph_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.DependencyGraph attributionDependencyGraph = 22;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetAttributionDependencyGraphFieldBuilder()
				{
					if (attributionDependencyGraphBuilder_ == null)
					{
						attributionDependencyGraphBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetAttributionDependencyGraph(), GetParentForChildren(), IsClean());
						attributionDependencyGraph_ = null;
					}
					return attributionDependencyGraphBuilder_;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Quote.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Quote)
			}

			private static readonly CoreNLPProtos.Quote DefaultInstance;

			static Quote()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Quote)
				DefaultInstance = new CoreNLPProtos.Quote();
			}

			public static CoreNLPProtos.Quote GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_28784 : AbstractParser<CoreNLPProtos.Quote>
			{
				public _AbstractParser_28784()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Quote ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Quote(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Quote> Parser = new _AbstractParser_28784();

			public static IParser<CoreNLPProtos.Quote> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IParseTreeOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.ParseTree)
			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			IList<CoreNLPProtos.ParseTree> GetChildList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			CoreNLPProtos.ParseTree GetChild(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			int GetChildCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			IList<CoreNLPProtos.IParseTreeOrBuilder> GetChildOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			CoreNLPProtos.IParseTreeOrBuilder GetChildOrBuilder(int index);

			/// <summary><code>optional string value = 2;</code></summary>
			bool HasValue();

			/// <summary><code>optional string value = 2;</code></summary>
			string GetValue();

			/// <summary><code>optional string value = 2;</code></summary>
			ByteString GetValueBytes();

			/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
			bool HasYieldBeginIndex();

			/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
			int GetYieldBeginIndex();

			/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
			bool HasYieldEndIndex();

			/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
			int GetYieldEndIndex();

			/// <summary><code>optional double score = 5;</code></summary>
			bool HasScore();

			/// <summary><code>optional double score = 5;</code></summary>
			double GetScore();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
			bool HasSentiment();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
			CoreNLPProtos.Sentiment GetSentiment();
		}

		/// <summary>
		/// <pre>
		/// A syntactic parse tree, with scores.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A syntactic parse tree, with scores.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.ParseTree</c>
		/// </remarks>
		[System.Serializable]
		public sealed class ParseTree : GeneratedMessageV3, CoreNLPProtos.IParseTreeOrBuilder
		{
			private ParseTree(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private ParseTree()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.ParseTree)
				// Use ParseTree.newBuilder() to construct.
				child_ = Java.Util.Collections.EmptyList();
				value_ = string.Empty;
				yieldBeginIndex_ = 0;
				yieldEndIndex_ = 0;
				score_ = 0D;
				sentiment_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private ParseTree(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									child_ = new List<CoreNLPProtos.ParseTree>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								child_.Add(input.ReadMessage(CoreNLPProtos.ParseTree.Parser, extensionRegistry));
								break;
							}

							case 18:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								value_ = bs;
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								yieldBeginIndex_ = input.ReadUInt32();
								break;
							}

							case 32:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								yieldEndIndex_ = input.ReadUInt32();
								break;
							}

							case 41:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								score_ = input.ReadDouble();
								break;
							}

							case 48:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.Sentiment value = CoreNLPProtos.Sentiment.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(6, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000010));
									sentiment_ = rawValue;
								}
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						child_ = Java.Util.Collections.UnmodifiableList(child_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_ParseTree_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_ParseTree_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.ParseTree), typeof(CoreNLPProtos.ParseTree.Builder));
			}

			private int bitField0_;

			public const int ChildFieldNumber = 1;

			private IList<CoreNLPProtos.ParseTree> child_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			public IList<CoreNLPProtos.ParseTree> GetChildList()
			{
				return child_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			public IList<CoreNLPProtos.IParseTreeOrBuilder> GetChildOrBuilderList()
			{
				return child_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			public int GetChildCount()
			{
				return child_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			public CoreNLPProtos.ParseTree GetChild(int index)
			{
				return child_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
			public CoreNLPProtos.IParseTreeOrBuilder GetChildOrBuilder(int index)
			{
				return child_[index];
			}

			public const int ValueFieldNumber = 2;

			private volatile object value_;

			/// <summary><code>optional string value = 2;</code></summary>
			public bool HasValue()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional string value = 2;</code></summary>
			public string GetValue()
			{
				object @ref = value_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						value_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string value = 2;</code></summary>
			public ByteString GetValueBytes()
			{
				object @ref = value_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					value_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int YieldbeginindexFieldNumber = 3;

			private int yieldBeginIndex_;

			/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
			public bool HasYieldBeginIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
			public int GetYieldBeginIndex()
			{
				return yieldBeginIndex_;
			}

			public const int YieldendindexFieldNumber = 4;

			private int yieldEndIndex_;

			/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
			public bool HasYieldEndIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
			public int GetYieldEndIndex()
			{
				return yieldEndIndex_;
			}

			public const int ScoreFieldNumber = 5;

			private double score_;

			/// <summary><code>optional double score = 5;</code></summary>
			public bool HasScore()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional double score = 5;</code></summary>
			public double GetScore()
			{
				return score_;
			}

			public const int SentimentFieldNumber = 6;

			private int sentiment_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
			public bool HasSentiment()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
			public CoreNLPProtos.Sentiment GetSentiment()
			{
				CoreNLPProtos.Sentiment result = CoreNLPProtos.Sentiment.ValueOf(sentiment_);
				return result == null ? CoreNLPProtos.Sentiment.StrongNegative : result;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				for (int i = 0; i < child_.Count; i++)
				{
					output.WriteMessage(1, child_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 2, value_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(3, yieldBeginIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteUInt32(4, yieldEndIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteDouble(5, score_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteEnum(6, sentiment_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				for (int i = 0; i < child_.Count; i++)
				{
					size += CodedOutputStream.ComputeMessageSize(1, child_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(2, value_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, yieldBeginIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeUInt32Size(4, yieldEndIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeDoubleSize(5, score_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeEnumSize(6, sentiment_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.ParseTree))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.ParseTree other = (CoreNLPProtos.ParseTree)obj;
				bool result = true;
				result = result && GetChildList().Equals(other.GetChildList());
				result = result && (HasValue() == other.HasValue());
				if (HasValue())
				{
					result = result && GetValue().Equals(other.GetValue());
				}
				result = result && (HasYieldBeginIndex() == other.HasYieldBeginIndex());
				if (HasYieldBeginIndex())
				{
					result = result && (GetYieldBeginIndex() == other.GetYieldBeginIndex());
				}
				result = result && (HasYieldEndIndex() == other.HasYieldEndIndex());
				if (HasYieldEndIndex())
				{
					result = result && (GetYieldEndIndex() == other.GetYieldEndIndex());
				}
				result = result && (HasScore() == other.HasScore());
				if (HasScore())
				{
					result = result && (double.DoubleToLongBits(GetScore()) == double.DoubleToLongBits(other.GetScore()));
				}
				result = result && (HasSentiment() == other.HasSentiment());
				if (HasSentiment())
				{
					result = result && sentiment_ == other.sentiment_;
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (GetChildCount() > 0)
				{
					hash = (37 * hash) + ChildFieldNumber;
					hash = (53 * hash) + GetChildList().GetHashCode();
				}
				if (HasValue())
				{
					hash = (37 * hash) + ValueFieldNumber;
					hash = (53 * hash) + GetValue().GetHashCode();
				}
				if (HasYieldBeginIndex())
				{
					hash = (37 * hash) + YieldbeginindexFieldNumber;
					hash = (53 * hash) + GetYieldBeginIndex();
				}
				if (HasYieldEndIndex())
				{
					hash = (37 * hash) + YieldendindexFieldNumber;
					hash = (53 * hash) + GetYieldEndIndex();
				}
				if (HasScore())
				{
					hash = (37 * hash) + ScoreFieldNumber;
					hash = (53 * hash) + Internal.HashLong(double.DoubleToLongBits(GetScore()));
				}
				if (HasSentiment())
				{
					hash = (37 * hash) + SentimentFieldNumber;
					hash = (53 * hash) + sentiment_;
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.ParseTree ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.ParseTree ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.ParseTree ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.ParseTree.Builder NewBuilder()
			{
				return ((CoreNLPProtos.ParseTree.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.ParseTree.Builder NewBuilder(CoreNLPProtos.ParseTree prototype)
			{
				return ((CoreNLPProtos.ParseTree.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.ParseTree.Builder() : new CoreNLPProtos.ParseTree.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.ParseTree.Builder builder = new CoreNLPProtos.ParseTree.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A syntactic parse tree, with scores.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A syntactic parse tree, with scores.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.ParseTree</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.ParseTree.Builder>, CoreNLPProtos.IParseTreeOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.ParseTree)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_ParseTree_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_ParseTree_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.ParseTree), typeof(CoreNLPProtos.ParseTree.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.ParseTree.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetChildFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					if (childBuilder_ == null)
					{
						child_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					else
					{
						childBuilder_.Clear();
					}
					value_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					yieldBeginIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					yieldEndIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					score_ = 0D;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					sentiment_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_ParseTree_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.ParseTree.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.ParseTree result = ((CoreNLPProtos.ParseTree)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.ParseTree result = new CoreNLPProtos.ParseTree(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (childBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
						{
							child_ = Java.Util.Collections.UnmodifiableList(child_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						result.child_ = child_;
					}
					else
					{
						result.child_ = childBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.value_ = value_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.yieldBeginIndex_ = yieldBeginIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.yieldEndIndex_ = yieldEndIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.score_ = score_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.sentiment_ = sentiment_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.ParseTree.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.ParseTree.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.ParseTree.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.ParseTree.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.ParseTree.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.ParseTree.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.ParseTree.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.ParseTree.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.ParseTree)
					{
						return MergeFrom((CoreNLPProtos.ParseTree)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.ParseTree.Builder MergeFrom(CoreNLPProtos.ParseTree other)
				{
					if (other == CoreNLPProtos.ParseTree.GetDefaultInstance())
					{
						return this;
					}
					if (childBuilder_ == null)
					{
						if (!other.child_.IsEmpty())
						{
							if (child_.IsEmpty())
							{
								child_ = other.child_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
							}
							else
							{
								EnsureChildIsMutable();
								Sharpen.Collections.AddAll(child_, other.child_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.child_.IsEmpty())
						{
							if (childBuilder_.IsEmpty())
							{
								childBuilder_.Dispose();
								childBuilder_ = null;
								child_ = other.child_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
								childBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetChildFieldBuilder() : null;
							}
							else
							{
								childBuilder_.AddAllMessages(other.child_);
							}
						}
					}
					if (other.HasValue())
					{
						bitField0_ |= unchecked((int)(0x00000002));
						value_ = other.value_;
						OnChanged();
					}
					if (other.HasYieldBeginIndex())
					{
						SetYieldBeginIndex(other.GetYieldBeginIndex());
					}
					if (other.HasYieldEndIndex())
					{
						SetYieldEndIndex(other.GetYieldEndIndex());
					}
					if (other.HasScore())
					{
						SetScore(other.GetScore());
					}
					if (other.HasSentiment())
					{
						SetSentiment(other.GetSentiment());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.ParseTree parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.ParseTree)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private IList<CoreNLPProtos.ParseTree> child_ = Java.Util.Collections.EmptyList();

				private void EnsureChildIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						child_ = new List<CoreNLPProtos.ParseTree>(child_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> childBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public IList<CoreNLPProtos.ParseTree> GetChildList()
				{
					if (childBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(child_);
					}
					else
					{
						return childBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public int GetChildCount()
				{
					if (childBuilder_ == null)
					{
						return child_.Count;
					}
					else
					{
						return childBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree GetChild(int index)
				{
					if (childBuilder_ == null)
					{
						return child_[index];
					}
					else
					{
						return childBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetChild(int index, CoreNLPProtos.ParseTree value)
				{
					if (childBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureChildIsMutable();
						child_.Set(index, value);
						OnChanged();
					}
					else
					{
						childBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetChild(int index, CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (childBuilder_ == null)
					{
						EnsureChildIsMutable();
						child_.Set(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						childBuilder_.SetMessage(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddChild(CoreNLPProtos.ParseTree value)
				{
					if (childBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureChildIsMutable();
						child_.Add(value);
						OnChanged();
					}
					else
					{
						childBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddChild(int index, CoreNLPProtos.ParseTree value)
				{
					if (childBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureChildIsMutable();
						child_.Add(index, value);
						OnChanged();
					}
					else
					{
						childBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddChild(CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (childBuilder_ == null)
					{
						EnsureChildIsMutable();
						child_.Add(((CoreNLPProtos.ParseTree)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						childBuilder_.AddMessage(((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddChild(int index, CoreNLPProtos.ParseTree.Builder builderForValue)
				{
					if (childBuilder_ == null)
					{
						EnsureChildIsMutable();
						child_.Add(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						childBuilder_.AddMessage(index, ((CoreNLPProtos.ParseTree)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddAllChild<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.ParseTree
				{
					if (childBuilder_ == null)
					{
						EnsureChildIsMutable();
						AbstractMessageLite.Builder.AddAll(values, child_);
						OnChanged();
					}
					else
					{
						childBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder ClearChild()
				{
					if (childBuilder_ == null)
					{
						child_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						OnChanged();
					}
					else
					{
						childBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder RemoveChild(int index)
				{
					if (childBuilder_ == null)
					{
						EnsureChildIsMutable();
						child_.Remove(index);
						OnChanged();
					}
					else
					{
						childBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder GetChildBuilder(int index)
				{
					return GetChildFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.IParseTreeOrBuilder GetChildOrBuilder(int index)
				{
					if (childBuilder_ == null)
					{
						return child_[index];
					}
					else
					{
						return childBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public IList<CoreNLPProtos.IParseTreeOrBuilder> GetChildOrBuilderList()
				{
					if (childBuilder_ != null)
					{
						return childBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(child_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddChildBuilder()
				{
					return GetChildFieldBuilder().AddBuilder(CoreNLPProtos.ParseTree.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public CoreNLPProtos.ParseTree.Builder AddChildBuilder(int index)
				{
					return GetChildFieldBuilder().AddBuilder(index, CoreNLPProtos.ParseTree.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;</code></summary>
				public IList<CoreNLPProtos.ParseTree.Builder> GetChildBuilderList()
				{
					return GetChildFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder> GetChildFieldBuilder()
				{
					if (childBuilder_ == null)
					{
						childBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.ParseTree, CoreNLPProtos.ParseTree.Builder, CoreNLPProtos.IParseTreeOrBuilder>(child_, ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))), GetParentForChildren
							(), IsClean());
						child_ = null;
					}
					return childBuilder_;
				}

				private object value_ = string.Empty;

				/// <summary><code>optional string value = 2;</code></summary>
				public bool HasValue()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional string value = 2;</code></summary>
				public string GetValue()
				{
					object @ref = value_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							value_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string value = 2;</code></summary>
				public ByteString GetValueBytes()
				{
					object @ref = value_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						value_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string value = 2;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetValue(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					value_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string value = 2;</code></summary>
				public CoreNLPProtos.ParseTree.Builder ClearValue()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					value_ = GetDefaultInstance().GetValue();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string value = 2;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetValueBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					value_ = value;
					OnChanged();
					return this;
				}

				private int yieldBeginIndex_;

				/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
				public bool HasYieldBeginIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
				public int GetYieldBeginIndex()
				{
					return yieldBeginIndex_;
				}

				/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetYieldBeginIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					yieldBeginIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 yieldBeginIndex = 3;</code></summary>
				public CoreNLPProtos.ParseTree.Builder ClearYieldBeginIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					yieldBeginIndex_ = 0;
					OnChanged();
					return this;
				}

				private int yieldEndIndex_;

				/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
				public bool HasYieldEndIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
				public int GetYieldEndIndex()
				{
					return yieldEndIndex_;
				}

				/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetYieldEndIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000008));
					yieldEndIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 yieldEndIndex = 4;</code></summary>
				public CoreNLPProtos.ParseTree.Builder ClearYieldEndIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					yieldEndIndex_ = 0;
					OnChanged();
					return this;
				}

				private double score_;

				/// <summary><code>optional double score = 5;</code></summary>
				public bool HasScore()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional double score = 5;</code></summary>
				public double GetScore()
				{
					return score_;
				}

				/// <summary><code>optional double score = 5;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetScore(double value)
				{
					bitField0_ |= unchecked((int)(0x00000010));
					score_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional double score = 5;</code></summary>
				public CoreNLPProtos.ParseTree.Builder ClearScore()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					score_ = 0D;
					OnChanged();
					return this;
				}

				private int sentiment_ = 0;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
				public bool HasSentiment()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
				public CoreNLPProtos.Sentiment GetSentiment()
				{
					CoreNLPProtos.Sentiment result = CoreNLPProtos.Sentiment.ValueOf(sentiment_);
					return result == null ? CoreNLPProtos.Sentiment.StrongNegative : result;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
				public CoreNLPProtos.ParseTree.Builder SetSentiment(CoreNLPProtos.Sentiment value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					sentiment_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;</code></summary>
				public CoreNLPProtos.ParseTree.Builder ClearSentiment()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					sentiment_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.ParseTree.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.ParseTree)
			}

			private static readonly CoreNLPProtos.ParseTree DefaultInstance;

			static ParseTree()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.ParseTree)
				DefaultInstance = new CoreNLPProtos.ParseTree();
			}

			public static CoreNLPProtos.ParseTree GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_30064 : AbstractParser<CoreNLPProtos.ParseTree>
			{
				public _AbstractParser_30064()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.ParseTree ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.ParseTree(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.ParseTree> Parser = new _AbstractParser_30064();

			public static IParser<CoreNLPProtos.ParseTree> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IDependencyGraphOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.DependencyGraph)
			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			IList<CoreNLPProtos.DependencyGraph.Node> GetNodeList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			CoreNLPProtos.DependencyGraph.Node GetNode(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			int GetNodeCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			IList<CoreNLPProtos.DependencyGraph.INodeOrBuilder> GetNodeOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			CoreNLPProtos.DependencyGraph.INodeOrBuilder GetNodeOrBuilder(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			IList<CoreNLPProtos.DependencyGraph.Edge> GetEdgeList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			CoreNLPProtos.DependencyGraph.Edge GetEdge(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			int GetEdgeCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			IList<CoreNLPProtos.DependencyGraph.IEdgeOrBuilder> GetEdgeOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			CoreNLPProtos.DependencyGraph.IEdgeOrBuilder GetEdgeOrBuilder(int index);

			/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
			IList<int> GetRootList();

			/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
			int GetRootCount();

			/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
			int GetRoot(int index);
		}

		/// <summary>
		/// <pre>
		/// A dependency graph representation.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A dependency graph representation.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.DependencyGraph</c>
		/// </remarks>
		[System.Serializable]
		public sealed class DependencyGraph : GeneratedMessageV3, CoreNLPProtos.IDependencyGraphOrBuilder
		{
			private DependencyGraph(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private DependencyGraph()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.DependencyGraph)
				// Use DependencyGraph.newBuilder() to construct.
				node_ = Java.Util.Collections.EmptyList();
				edge_ = Java.Util.Collections.EmptyList();
				root_ = Java.Util.Collections.EmptyList();
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private DependencyGraph(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									node_ = new List<CoreNLPProtos.DependencyGraph.Node>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								node_.Add(input.ReadMessage(CoreNLPProtos.DependencyGraph.Node.Parser, extensionRegistry));
								break;
							}

							case 18:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									edge_ = new List<CoreNLPProtos.DependencyGraph.Edge>();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								edge_.Add(input.ReadMessage(CoreNLPProtos.DependencyGraph.Edge.Parser, extensionRegistry));
								break;
							}

							case 24:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
								{
									root_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000004));
								}
								root_.Add(input.ReadUInt32());
								break;
							}

							case 26:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))) && input.GetBytesUntilLimit() > 0)
								{
									root_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000004));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									root_.Add(input.ReadUInt32());
								}
								input.PopLimit(limit);
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						node_ = Java.Util.Collections.UnmodifiableList(node_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						edge_ = Java.Util.Collections.UnmodifiableList(edge_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						root_ = Java.Util.Collections.UnmodifiableList(root_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.DependencyGraph), typeof(CoreNLPProtos.DependencyGraph.Builder));
			}

			public interface INodeOrBuilder : IMessageOrBuilder
			{
				// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.DependencyGraph.Node)
				/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
				bool HasSentenceIndex();

				/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
				int GetSentenceIndex();

				/// <summary><code>required uint32 index = 2;</code></summary>
				bool HasIndex();

				/// <summary><code>required uint32 index = 2;</code></summary>
				int GetIndex();

				/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
				bool HasCopyAnnotation();

				/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
				int GetCopyAnnotation();
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.DependencyGraph.Node</c>
			/// </summary>
			[System.Serializable]
			public sealed class Node : GeneratedMessageV3, CoreNLPProtos.DependencyGraph.INodeOrBuilder
			{
				private Node(GeneratedMessageV3.Builder<object> builder)
					: base(builder)
				{
				}

				private Node()
				{
					// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.DependencyGraph.Node)
					// Use Node.newBuilder() to construct.
					sentenceIndex_ = 0;
					index_ = 0;
					copyAnnotation_ = 0;
				}

				public sealed override UnknownFieldSet GetUnknownFields()
				{
					return this.unknownFields;
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				private Node(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					: this()
				{
					int mutable_bitField0_ = 0;
					UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
					try
					{
						bool done = false;
						while (!done)
						{
							int tag = input.ReadTag();
							switch (tag)
							{
								case 0:
								{
									done = true;
									break;
								}

								default:
								{
									if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
									{
										done = true;
									}
									break;
								}

								case 8:
								{
									bitField0_ |= unchecked((int)(0x00000001));
									sentenceIndex_ = input.ReadUInt32();
									break;
								}

								case 16:
								{
									bitField0_ |= unchecked((int)(0x00000002));
									index_ = input.ReadUInt32();
									break;
								}

								case 24:
								{
									bitField0_ |= unchecked((int)(0x00000004));
									copyAnnotation_ = input.ReadUInt32();
									break;
								}
							}
						}
					}
					catch (InvalidProtocolBufferException e)
					{
						throw e.SetUnfinishedMessage(this);
					}
					catch (IOException e)
					{
						throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
					}
					finally
					{
						this.unknownFields = unknownFields.Build();
						MakeExtensionsImmutable();
					}
				}

				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.DependencyGraph.Node), typeof(CoreNLPProtos.DependencyGraph.Node.Builder));
				}

				private int bitField0_;

				public const int SentenceindexFieldNumber = 1;

				private int sentenceIndex_;

				/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
				public bool HasSentenceIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
				public int GetSentenceIndex()
				{
					return sentenceIndex_;
				}

				public const int IndexFieldNumber = 2;

				private int index_;

				/// <summary><code>required uint32 index = 2;</code></summary>
				public bool HasIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required uint32 index = 2;</code></summary>
				public int GetIndex()
				{
					return index_;
				}

				public const int CopyannotationFieldNumber = 3;

				private int copyAnnotation_;

				/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
				public bool HasCopyAnnotation()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
				public int GetCopyAnnotation()
				{
					return copyAnnotation_;
				}

				private byte memoizedIsInitialized = unchecked((byte)(-1));

				public sealed override bool IsInitialized()
				{
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
					{
						return true;
					}
					if (isInitialized == 0)
					{
						return false;
					}
					if (!HasSentenceIndex())
					{
						memoizedIsInitialized = 0;
						return false;
					}
					if (!HasIndex())
					{
						memoizedIsInitialized = 0;
						return false;
					}
					memoizedIsInitialized = 1;
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override void WriteTo(CodedOutputStream output)
				{
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						output.WriteUInt32(1, sentenceIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						output.WriteUInt32(2, index_);
					}
					if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						output.WriteUInt32(3, copyAnnotation_);
					}
					unknownFields.WriteTo(output);
				}

				public override int GetSerializedSize()
				{
					int size = memoizedSize;
					if (size != -1)
					{
						return size;
					}
					size = 0;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						size += CodedOutputStream.ComputeUInt32Size(1, sentenceIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						size += CodedOutputStream.ComputeUInt32Size(2, index_);
					}
					if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						size += CodedOutputStream.ComputeUInt32Size(3, copyAnnotation_);
					}
					size += unknownFields.GetSerializedSize();
					memoizedSize = size;
					return size;
				}

				private const long serialVersionUID = 0L;

				public override bool Equals(object obj)
				{
					if (obj == this)
					{
						return true;
					}
					if (!(obj is CoreNLPProtos.DependencyGraph.Node))
					{
						return base.Equals(obj);
					}
					CoreNLPProtos.DependencyGraph.Node other = (CoreNLPProtos.DependencyGraph.Node)obj;
					bool result = true;
					result = result && (HasSentenceIndex() == other.HasSentenceIndex());
					if (HasSentenceIndex())
					{
						result = result && (GetSentenceIndex() == other.GetSentenceIndex());
					}
					result = result && (HasIndex() == other.HasIndex());
					if (HasIndex())
					{
						result = result && (GetIndex() == other.GetIndex());
					}
					result = result && (HasCopyAnnotation() == other.HasCopyAnnotation());
					if (HasCopyAnnotation())
					{
						result = result && (GetCopyAnnotation() == other.GetCopyAnnotation());
					}
					result = result && unknownFields.Equals(other.unknownFields);
					return result;
				}

				public override int GetHashCode()
				{
					if (memoizedHashCode != 0)
					{
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + GetDescriptor().GetHashCode();
					if (HasSentenceIndex())
					{
						hash = (37 * hash) + SentenceindexFieldNumber;
						hash = (53 * hash) + GetSentenceIndex();
					}
					if (HasIndex())
					{
						hash = (37 * hash) + IndexFieldNumber;
						hash = (53 * hash) + GetIndex();
					}
					if (HasCopyAnnotation())
					{
						hash = (37 * hash) + CopyannotationFieldNumber;
						hash = (53 * hash) + GetCopyAnnotation();
					}
					hash = (29 * hash) + unknownFields.GetHashCode();
					memoizedHashCode = hash;
					return hash;
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(ByteString data)
				{
					return Parser.ParseFrom(data);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
				{
					return Parser.ParseFrom(data, extensionRegistry);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(byte[] data)
				{
					return Parser.ParseFrom(data);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
				{
					return Parser.ParseFrom(data, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(InputStream input)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseDelimitedFrom(InputStream input)
				{
					return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(CodedInputStream input)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Node ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
				}

				public override MessageLite.IBuilder NewBuilderForType()
				{
					return NewBuilder();
				}

				public static CoreNLPProtos.DependencyGraph.Node.Builder NewBuilder()
				{
					return ((CoreNLPProtos.DependencyGraph.Node.Builder)DefaultInstance.ToBuilder());
				}

				public static CoreNLPProtos.DependencyGraph.Node.Builder NewBuilder(CoreNLPProtos.DependencyGraph.Node prototype)
				{
					return ((CoreNLPProtos.DependencyGraph.Node.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
				}

				public override MessageLite.IBuilder ToBuilder()
				{
					return this == DefaultInstance ? new CoreNLPProtos.DependencyGraph.Node.Builder() : new CoreNLPProtos.DependencyGraph.Node.Builder().MergeFrom(this);
				}

				protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
				{
					CoreNLPProtos.DependencyGraph.Node.Builder builder = new CoreNLPProtos.DependencyGraph.Node.Builder(parent);
					return builder;
				}

				/// <summary>
				/// Protobuf type
				/// <c>edu.stanford.nlp.pipeline.DependencyGraph.Node</c>
				/// </summary>
				public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.DependencyGraph.Node.Builder>, CoreNLPProtos.DependencyGraph.INodeOrBuilder
				{
					// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.DependencyGraph.Node)
					public static Descriptors.Descriptor GetDescriptor()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_descriptor;
					}

					protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.DependencyGraph.Node), typeof(CoreNLPProtos.DependencyGraph.Node.Builder));
					}

					private Builder()
					{
						// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.DependencyGraph.Node.newBuilder()
						MaybeForceBuilderInitialization();
					}

					private Builder(GeneratedMessageV3.IBuilderParent parent)
						: base(parent)
					{
						MaybeForceBuilderInitialization();
					}

					private void MaybeForceBuilderInitialization()
					{
						if (GeneratedMessageV3.alwaysUseFieldBuilders)
						{
						}
					}

					public override MessageLite.IBuilder Clear()
					{
						base.Clear();
						sentenceIndex_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						index_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						copyAnnotation_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						return this;
					}

					public override Descriptors.Descriptor GetDescriptorForType()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_descriptor;
					}

					public override IMessageLite GetDefaultInstanceForType()
					{
						return CoreNLPProtos.DependencyGraph.Node.GetDefaultInstance();
					}

					public override IMessageLite Build()
					{
						CoreNLPProtos.DependencyGraph.Node result = ((CoreNLPProtos.DependencyGraph.Node)BuildPartial());
						if (!result.IsInitialized())
						{
							throw NewUninitializedMessageException(result);
						}
						return result;
					}

					public override IMessageLite BuildPartial()
					{
						CoreNLPProtos.DependencyGraph.Node result = new CoreNLPProtos.DependencyGraph.Node(this);
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
						{
							to_bitField0_ |= unchecked((int)(0x00000001));
						}
						result.sentenceIndex_ = sentenceIndex_;
						if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							to_bitField0_ |= unchecked((int)(0x00000002));
						}
						result.index_ = index_;
						if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
						{
							to_bitField0_ |= unchecked((int)(0x00000004));
						}
						result.copyAnnotation_ = copyAnnotation_;
						result.bitField0_ = to_bitField0_;
						OnBuilt();
						return result;
					}

					public override AbstractMessageLite.Builder Clone()
					{
						return (CoreNLPProtos.DependencyGraph.Node.Builder)base.Clone();
					}

					public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
					{
						return (CoreNLPProtos.DependencyGraph.Node.Builder)base.SetField(field, value);
					}

					public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
					{
						return (CoreNLPProtos.DependencyGraph.Node.Builder)base.ClearField(field);
					}

					public override CoreNLPProtos.DependencyGraph.Node.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
					{
						return (CoreNLPProtos.DependencyGraph.Node.Builder)base.ClearOneof(oneof);
					}

					public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
					{
						return (CoreNLPProtos.DependencyGraph.Node.Builder)base.SetRepeatedField(field, index, value);
					}

					public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
					{
						return (CoreNLPProtos.DependencyGraph.Node.Builder)base.AddRepeatedField(field, value);
					}

					public override CoreNLPProtos.DependencyGraph.Node.Builder MergeFrom(IMessage other)
					{
						if (other is CoreNLPProtos.DependencyGraph.Node)
						{
							return MergeFrom((CoreNLPProtos.DependencyGraph.Node)other);
						}
						else
						{
							base.MergeFrom(other);
							return this;
						}
					}

					public CoreNLPProtos.DependencyGraph.Node.Builder MergeFrom(CoreNLPProtos.DependencyGraph.Node other)
					{
						if (other == CoreNLPProtos.DependencyGraph.Node.GetDefaultInstance())
						{
							return this;
						}
						if (other.HasSentenceIndex())
						{
							SetSentenceIndex(other.GetSentenceIndex());
						}
						if (other.HasIndex())
						{
							SetIndex(other.GetIndex());
						}
						if (other.HasCopyAnnotation())
						{
							SetCopyAnnotation(other.GetCopyAnnotation());
						}
						this.MergeUnknownFields(other.unknownFields);
						OnChanged();
						return this;
					}

					public sealed override bool IsInitialized()
					{
						if (!HasSentenceIndex())
						{
							return false;
						}
						if (!HasIndex())
						{
							return false;
						}
						return true;
					}

					/// <exception cref="System.IO.IOException"/>
					public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					{
						CoreNLPProtos.DependencyGraph.Node parsedMessage = null;
						try
						{
							parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
						}
						catch (InvalidProtocolBufferException e)
						{
							parsedMessage = (CoreNLPProtos.DependencyGraph.Node)e.GetUnfinishedMessage();
							throw e.UnwrapIOException();
						}
						finally
						{
							if (parsedMessage != null)
							{
								MergeFrom(parsedMessage);
							}
						}
						return this;
					}

					private int bitField0_;

					private int sentenceIndex_;

					/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
					public bool HasSentenceIndex()
					{
						return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
					}

					/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
					public int GetSentenceIndex()
					{
						return sentenceIndex_;
					}

					/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
					public CoreNLPProtos.DependencyGraph.Node.Builder SetSentenceIndex(int value)
					{
						bitField0_ |= unchecked((int)(0x00000001));
						sentenceIndex_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>required uint32 sentenceIndex = 1;</code></summary>
					public CoreNLPProtos.DependencyGraph.Node.Builder ClearSentenceIndex()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						sentenceIndex_ = 0;
						OnChanged();
						return this;
					}

					private int index_;

					/// <summary><code>required uint32 index = 2;</code></summary>
					public bool HasIndex()
					{
						return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
					}

					/// <summary><code>required uint32 index = 2;</code></summary>
					public int GetIndex()
					{
						return index_;
					}

					/// <summary><code>required uint32 index = 2;</code></summary>
					public CoreNLPProtos.DependencyGraph.Node.Builder SetIndex(int value)
					{
						bitField0_ |= unchecked((int)(0x00000002));
						index_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>required uint32 index = 2;</code></summary>
					public CoreNLPProtos.DependencyGraph.Node.Builder ClearIndex()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						index_ = 0;
						OnChanged();
						return this;
					}

					private int copyAnnotation_;

					/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
					public bool HasCopyAnnotation()
					{
						return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
					}

					/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
					public int GetCopyAnnotation()
					{
						return copyAnnotation_;
					}

					/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
					public CoreNLPProtos.DependencyGraph.Node.Builder SetCopyAnnotation(int value)
					{
						bitField0_ |= unchecked((int)(0x00000004));
						copyAnnotation_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional uint32 copyAnnotation = 3;</code></summary>
					public CoreNLPProtos.DependencyGraph.Node.Builder ClearCopyAnnotation()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						copyAnnotation_ = 0;
						OnChanged();
						return this;
					}

					public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
					{
						return base.SetUnknownFields(unknownFields);
					}

					public sealed override CoreNLPProtos.DependencyGraph.Node.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
					{
						return base.MergeUnknownFields(unknownFields);
					}
					// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.DependencyGraph.Node)
				}

				private static readonly CoreNLPProtos.DependencyGraph.Node DefaultInstance;

				static Node()
				{
					// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.DependencyGraph.Node)
					DefaultInstance = new CoreNLPProtos.DependencyGraph.Node();
				}

				public static CoreNLPProtos.DependencyGraph.Node GetDefaultInstance()
				{
					return DefaultInstance;
				}

				private sealed class _AbstractParser_30904 : AbstractParser<CoreNLPProtos.DependencyGraph.Node>
				{
					public _AbstractParser_30904()
					{
					}

					/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
					public override CoreNLPProtos.DependencyGraph.Node ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					{
						return new CoreNLPProtos.DependencyGraph.Node(input, extensionRegistry);
					}
				}

				[Obsolete]
				public static readonly IParser<CoreNLPProtos.DependencyGraph.Node> Parser = new _AbstractParser_30904();

				public static IParser<CoreNLPProtos.DependencyGraph.Node> Parser()
				{
					return Parser;
				}

				public override IParser<IMessageLite> GetParserForType()
				{
					return Parser;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return DefaultInstance;
				}
			}

			public interface IEdgeOrBuilder : IMessageOrBuilder
			{
				// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
				/// <summary><code>required uint32 source = 1;</code></summary>
				bool HasSource();

				/// <summary><code>required uint32 source = 1;</code></summary>
				int GetSource();

				/// <summary><code>required uint32 target = 2;</code></summary>
				bool HasTarget();

				/// <summary><code>required uint32 target = 2;</code></summary>
				int GetTarget();

				/// <summary><code>optional string dep = 3;</code></summary>
				bool HasDep();

				/// <summary><code>optional string dep = 3;</code></summary>
				string GetDep();

				/// <summary><code>optional string dep = 3;</code></summary>
				ByteString GetDepBytes();

				/// <summary><code>optional bool isExtra = 4;</code></summary>
				bool HasIsExtra();

				/// <summary><code>optional bool isExtra = 4;</code></summary>
				bool GetIsExtra();

				/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
				bool HasSourceCopy();

				/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
				int GetSourceCopy();

				/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
				bool HasTargetCopy();

				/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
				int GetTargetCopy();

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
				bool HasLanguage();

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
				CoreNLPProtos.Language GetLanguage();
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.DependencyGraph.Edge</c>
			/// </summary>
			[System.Serializable]
			public sealed class Edge : GeneratedMessageV3, CoreNLPProtos.DependencyGraph.IEdgeOrBuilder
			{
				private Edge(GeneratedMessageV3.Builder<object> builder)
					: base(builder)
				{
				}

				private Edge()
				{
					// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
					// Use Edge.newBuilder() to construct.
					source_ = 0;
					target_ = 0;
					dep_ = string.Empty;
					isExtra_ = false;
					sourceCopy_ = 0;
					targetCopy_ = 0;
					language_ = 0;
				}

				public sealed override UnknownFieldSet GetUnknownFields()
				{
					return this.unknownFields;
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				private Edge(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					: this()
				{
					int mutable_bitField0_ = 0;
					UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
					try
					{
						bool done = false;
						while (!done)
						{
							int tag = input.ReadTag();
							switch (tag)
							{
								case 0:
								{
									done = true;
									break;
								}

								default:
								{
									if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
									{
										done = true;
									}
									break;
								}

								case 8:
								{
									bitField0_ |= unchecked((int)(0x00000001));
									source_ = input.ReadUInt32();
									break;
								}

								case 16:
								{
									bitField0_ |= unchecked((int)(0x00000002));
									target_ = input.ReadUInt32();
									break;
								}

								case 26:
								{
									ByteString bs = input.ReadBytes();
									bitField0_ |= unchecked((int)(0x00000004));
									dep_ = bs;
									break;
								}

								case 32:
								{
									bitField0_ |= unchecked((int)(0x00000008));
									isExtra_ = input.ReadBool();
									break;
								}

								case 40:
								{
									bitField0_ |= unchecked((int)(0x00000010));
									sourceCopy_ = input.ReadUInt32();
									break;
								}

								case 48:
								{
									bitField0_ |= unchecked((int)(0x00000020));
									targetCopy_ = input.ReadUInt32();
									break;
								}

								case 56:
								{
									int rawValue = input.ReadEnum();
									CoreNLPProtos.Language value = CoreNLPProtos.Language.ValueOf(rawValue);
									if (value == null)
									{
										unknownFields.MergeVarintField(7, rawValue);
									}
									else
									{
										bitField0_ |= unchecked((int)(0x00000040));
										language_ = rawValue;
									}
									break;
								}
							}
						}
					}
					catch (InvalidProtocolBufferException e)
					{
						throw e.SetUnfinishedMessage(this);
					}
					catch (IOException e)
					{
						throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
					}
					finally
					{
						this.unknownFields = unknownFields.Build();
						MakeExtensionsImmutable();
					}
				}

				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.DependencyGraph.Edge), typeof(CoreNLPProtos.DependencyGraph.Edge.Builder));
				}

				private int bitField0_;

				public const int SourceFieldNumber = 1;

				private int source_;

				/// <summary><code>required uint32 source = 1;</code></summary>
				public bool HasSource()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required uint32 source = 1;</code></summary>
				public int GetSource()
				{
					return source_;
				}

				public const int TargetFieldNumber = 2;

				private int target_;

				/// <summary><code>required uint32 target = 2;</code></summary>
				public bool HasTarget()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required uint32 target = 2;</code></summary>
				public int GetTarget()
				{
					return target_;
				}

				public const int DepFieldNumber = 3;

				private volatile object dep_;

				/// <summary><code>optional string dep = 3;</code></summary>
				public bool HasDep()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional string dep = 3;</code></summary>
				public string GetDep()
				{
					object @ref = dep_;
					if (@ref is string)
					{
						return (string)@ref;
					}
					else
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							dep_ = s;
						}
						return s;
					}
				}

				/// <summary><code>optional string dep = 3;</code></summary>
				public ByteString GetDepBytes()
				{
					object @ref = dep_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						dep_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				public const int IsextraFieldNumber = 4;

				private bool isExtra_;

				/// <summary><code>optional bool isExtra = 4;</code></summary>
				public bool HasIsExtra()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional bool isExtra = 4;</code></summary>
				public bool GetIsExtra()
				{
					return isExtra_;
				}

				public const int SourcecopyFieldNumber = 5;

				private int sourceCopy_;

				/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
				public bool HasSourceCopy()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
				public int GetSourceCopy()
				{
					return sourceCopy_;
				}

				public const int TargetcopyFieldNumber = 6;

				private int targetCopy_;

				/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
				public bool HasTargetCopy()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
				public int GetTargetCopy()
				{
					return targetCopy_;
				}

				public const int LanguageFieldNumber = 7;

				private int language_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
				public bool HasLanguage()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
				public CoreNLPProtos.Language GetLanguage()
				{
					CoreNLPProtos.Language result = CoreNLPProtos.Language.ValueOf(language_);
					return result == null ? CoreNLPProtos.Language.Unknown : result;
				}

				private byte memoizedIsInitialized = unchecked((byte)(-1));

				public sealed override bool IsInitialized()
				{
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
					{
						return true;
					}
					if (isInitialized == 0)
					{
						return false;
					}
					if (!HasSource())
					{
						memoizedIsInitialized = 0;
						return false;
					}
					if (!HasTarget())
					{
						memoizedIsInitialized = 0;
						return false;
					}
					memoizedIsInitialized = 1;
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override void WriteTo(CodedOutputStream output)
				{
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						output.WriteUInt32(1, source_);
					}
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						output.WriteUInt32(2, target_);
					}
					if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						GeneratedMessageV3.WriteString(output, 3, dep_);
					}
					if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						output.WriteBool(4, isExtra_);
					}
					if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						output.WriteUInt32(5, sourceCopy_);
					}
					if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						output.WriteUInt32(6, targetCopy_);
					}
					if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						output.WriteEnum(7, language_);
					}
					unknownFields.WriteTo(output);
				}

				public override int GetSerializedSize()
				{
					int size = memoizedSize;
					if (size != -1)
					{
						return size;
					}
					size = 0;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						size += CodedOutputStream.ComputeUInt32Size(1, source_);
					}
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						size += CodedOutputStream.ComputeUInt32Size(2, target_);
					}
					if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						size += GeneratedMessageV3.ComputeStringSize(3, dep_);
					}
					if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						size += CodedOutputStream.ComputeBoolSize(4, isExtra_);
					}
					if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						size += CodedOutputStream.ComputeUInt32Size(5, sourceCopy_);
					}
					if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						size += CodedOutputStream.ComputeUInt32Size(6, targetCopy_);
					}
					if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						size += CodedOutputStream.ComputeEnumSize(7, language_);
					}
					size += unknownFields.GetSerializedSize();
					memoizedSize = size;
					return size;
				}

				private const long serialVersionUID = 0L;

				public override bool Equals(object obj)
				{
					if (obj == this)
					{
						return true;
					}
					if (!(obj is CoreNLPProtos.DependencyGraph.Edge))
					{
						return base.Equals(obj);
					}
					CoreNLPProtos.DependencyGraph.Edge other = (CoreNLPProtos.DependencyGraph.Edge)obj;
					bool result = true;
					result = result && (HasSource() == other.HasSource());
					if (HasSource())
					{
						result = result && (GetSource() == other.GetSource());
					}
					result = result && (HasTarget() == other.HasTarget());
					if (HasTarget())
					{
						result = result && (GetTarget() == other.GetTarget());
					}
					result = result && (HasDep() == other.HasDep());
					if (HasDep())
					{
						result = result && GetDep().Equals(other.GetDep());
					}
					result = result && (HasIsExtra() == other.HasIsExtra());
					if (HasIsExtra())
					{
						result = result && (GetIsExtra() == other.GetIsExtra());
					}
					result = result && (HasSourceCopy() == other.HasSourceCopy());
					if (HasSourceCopy())
					{
						result = result && (GetSourceCopy() == other.GetSourceCopy());
					}
					result = result && (HasTargetCopy() == other.HasTargetCopy());
					if (HasTargetCopy())
					{
						result = result && (GetTargetCopy() == other.GetTargetCopy());
					}
					result = result && (HasLanguage() == other.HasLanguage());
					if (HasLanguage())
					{
						result = result && language_ == other.language_;
					}
					result = result && unknownFields.Equals(other.unknownFields);
					return result;
				}

				public override int GetHashCode()
				{
					if (memoizedHashCode != 0)
					{
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + GetDescriptor().GetHashCode();
					if (HasSource())
					{
						hash = (37 * hash) + SourceFieldNumber;
						hash = (53 * hash) + GetSource();
					}
					if (HasTarget())
					{
						hash = (37 * hash) + TargetFieldNumber;
						hash = (53 * hash) + GetTarget();
					}
					if (HasDep())
					{
						hash = (37 * hash) + DepFieldNumber;
						hash = (53 * hash) + GetDep().GetHashCode();
					}
					if (HasIsExtra())
					{
						hash = (37 * hash) + IsextraFieldNumber;
						hash = (53 * hash) + Internal.HashBoolean(GetIsExtra());
					}
					if (HasSourceCopy())
					{
						hash = (37 * hash) + SourcecopyFieldNumber;
						hash = (53 * hash) + GetSourceCopy();
					}
					if (HasTargetCopy())
					{
						hash = (37 * hash) + TargetcopyFieldNumber;
						hash = (53 * hash) + GetTargetCopy();
					}
					if (HasLanguage())
					{
						hash = (37 * hash) + LanguageFieldNumber;
						hash = (53 * hash) + language_;
					}
					hash = (29 * hash) + unknownFields.GetHashCode();
					memoizedHashCode = hash;
					return hash;
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(ByteString data)
				{
					return Parser.ParseFrom(data);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
				{
					return Parser.ParseFrom(data, extensionRegistry);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(byte[] data)
				{
					return Parser.ParseFrom(data);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
				{
					return Parser.ParseFrom(data, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(InputStream input)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseDelimitedFrom(InputStream input)
				{
					return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(CodedInputStream input)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.DependencyGraph.Edge ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
				}

				public override MessageLite.IBuilder NewBuilderForType()
				{
					return NewBuilder();
				}

				public static CoreNLPProtos.DependencyGraph.Edge.Builder NewBuilder()
				{
					return ((CoreNLPProtos.DependencyGraph.Edge.Builder)DefaultInstance.ToBuilder());
				}

				public static CoreNLPProtos.DependencyGraph.Edge.Builder NewBuilder(CoreNLPProtos.DependencyGraph.Edge prototype)
				{
					return ((CoreNLPProtos.DependencyGraph.Edge.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
				}

				public override MessageLite.IBuilder ToBuilder()
				{
					return this == DefaultInstance ? new CoreNLPProtos.DependencyGraph.Edge.Builder() : new CoreNLPProtos.DependencyGraph.Edge.Builder().MergeFrom(this);
				}

				protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
				{
					CoreNLPProtos.DependencyGraph.Edge.Builder builder = new CoreNLPProtos.DependencyGraph.Edge.Builder(parent);
					return builder;
				}

				/// <summary>
				/// Protobuf type
				/// <c>edu.stanford.nlp.pipeline.DependencyGraph.Edge</c>
				/// </summary>
				public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.DependencyGraph.Edge.Builder>, CoreNLPProtos.DependencyGraph.IEdgeOrBuilder
				{
					// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
					public static Descriptors.Descriptor GetDescriptor()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_descriptor;
					}

					protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.DependencyGraph.Edge), typeof(CoreNLPProtos.DependencyGraph.Edge.Builder));
					}

					private Builder()
					{
						// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.DependencyGraph.Edge.newBuilder()
						MaybeForceBuilderInitialization();
					}

					private Builder(GeneratedMessageV3.IBuilderParent parent)
						: base(parent)
					{
						MaybeForceBuilderInitialization();
					}

					private void MaybeForceBuilderInitialization()
					{
						if (GeneratedMessageV3.alwaysUseFieldBuilders)
						{
						}
					}

					public override MessageLite.IBuilder Clear()
					{
						base.Clear();
						source_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						target_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						dep_ = string.Empty;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						isExtra_ = false;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
						sourceCopy_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
						targetCopy_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						language_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						return this;
					}

					public override Descriptors.Descriptor GetDescriptorForType()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_descriptor;
					}

					public override IMessageLite GetDefaultInstanceForType()
					{
						return CoreNLPProtos.DependencyGraph.Edge.GetDefaultInstance();
					}

					public override IMessageLite Build()
					{
						CoreNLPProtos.DependencyGraph.Edge result = ((CoreNLPProtos.DependencyGraph.Edge)BuildPartial());
						if (!result.IsInitialized())
						{
							throw NewUninitializedMessageException(result);
						}
						return result;
					}

					public override IMessageLite BuildPartial()
					{
						CoreNLPProtos.DependencyGraph.Edge result = new CoreNLPProtos.DependencyGraph.Edge(this);
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
						{
							to_bitField0_ |= unchecked((int)(0x00000001));
						}
						result.source_ = source_;
						if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							to_bitField0_ |= unchecked((int)(0x00000002));
						}
						result.target_ = target_;
						if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
						{
							to_bitField0_ |= unchecked((int)(0x00000004));
						}
						result.dep_ = dep_;
						if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
						{
							to_bitField0_ |= unchecked((int)(0x00000008));
						}
						result.isExtra_ = isExtra_;
						if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
						{
							to_bitField0_ |= unchecked((int)(0x00000010));
						}
						result.sourceCopy_ = sourceCopy_;
						if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
						{
							to_bitField0_ |= unchecked((int)(0x00000020));
						}
						result.targetCopy_ = targetCopy_;
						if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
						{
							to_bitField0_ |= unchecked((int)(0x00000040));
						}
						result.language_ = language_;
						result.bitField0_ = to_bitField0_;
						OnBuilt();
						return result;
					}

					public override AbstractMessageLite.Builder Clone()
					{
						return (CoreNLPProtos.DependencyGraph.Edge.Builder)base.Clone();
					}

					public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
					{
						return (CoreNLPProtos.DependencyGraph.Edge.Builder)base.SetField(field, value);
					}

					public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
					{
						return (CoreNLPProtos.DependencyGraph.Edge.Builder)base.ClearField(field);
					}

					public override CoreNLPProtos.DependencyGraph.Edge.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
					{
						return (CoreNLPProtos.DependencyGraph.Edge.Builder)base.ClearOneof(oneof);
					}

					public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
					{
						return (CoreNLPProtos.DependencyGraph.Edge.Builder)base.SetRepeatedField(field, index, value);
					}

					public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
					{
						return (CoreNLPProtos.DependencyGraph.Edge.Builder)base.AddRepeatedField(field, value);
					}

					public override CoreNLPProtos.DependencyGraph.Edge.Builder MergeFrom(IMessage other)
					{
						if (other is CoreNLPProtos.DependencyGraph.Edge)
						{
							return MergeFrom((CoreNLPProtos.DependencyGraph.Edge)other);
						}
						else
						{
							base.MergeFrom(other);
							return this;
						}
					}

					public CoreNLPProtos.DependencyGraph.Edge.Builder MergeFrom(CoreNLPProtos.DependencyGraph.Edge other)
					{
						if (other == CoreNLPProtos.DependencyGraph.Edge.GetDefaultInstance())
						{
							return this;
						}
						if (other.HasSource())
						{
							SetSource(other.GetSource());
						}
						if (other.HasTarget())
						{
							SetTarget(other.GetTarget());
						}
						if (other.HasDep())
						{
							bitField0_ |= unchecked((int)(0x00000004));
							dep_ = other.dep_;
							OnChanged();
						}
						if (other.HasIsExtra())
						{
							SetIsExtra(other.GetIsExtra());
						}
						if (other.HasSourceCopy())
						{
							SetSourceCopy(other.GetSourceCopy());
						}
						if (other.HasTargetCopy())
						{
							SetTargetCopy(other.GetTargetCopy());
						}
						if (other.HasLanguage())
						{
							SetLanguage(other.GetLanguage());
						}
						this.MergeUnknownFields(other.unknownFields);
						OnChanged();
						return this;
					}

					public sealed override bool IsInitialized()
					{
						if (!HasSource())
						{
							return false;
						}
						if (!HasTarget())
						{
							return false;
						}
						return true;
					}

					/// <exception cref="System.IO.IOException"/>
					public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					{
						CoreNLPProtos.DependencyGraph.Edge parsedMessage = null;
						try
						{
							parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
						}
						catch (InvalidProtocolBufferException e)
						{
							parsedMessage = (CoreNLPProtos.DependencyGraph.Edge)e.GetUnfinishedMessage();
							throw e.UnwrapIOException();
						}
						finally
						{
							if (parsedMessage != null)
							{
								MergeFrom(parsedMessage);
							}
						}
						return this;
					}

					private int bitField0_;

					private int source_;

					/// <summary><code>required uint32 source = 1;</code></summary>
					public bool HasSource()
					{
						return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
					}

					/// <summary><code>required uint32 source = 1;</code></summary>
					public int GetSource()
					{
						return source_;
					}

					/// <summary><code>required uint32 source = 1;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetSource(int value)
					{
						bitField0_ |= unchecked((int)(0x00000001));
						source_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>required uint32 source = 1;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder ClearSource()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						source_ = 0;
						OnChanged();
						return this;
					}

					private int target_;

					/// <summary><code>required uint32 target = 2;</code></summary>
					public bool HasTarget()
					{
						return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
					}

					/// <summary><code>required uint32 target = 2;</code></summary>
					public int GetTarget()
					{
						return target_;
					}

					/// <summary><code>required uint32 target = 2;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetTarget(int value)
					{
						bitField0_ |= unchecked((int)(0x00000002));
						target_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>required uint32 target = 2;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder ClearTarget()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						target_ = 0;
						OnChanged();
						return this;
					}

					private object dep_ = string.Empty;

					/// <summary><code>optional string dep = 3;</code></summary>
					public bool HasDep()
					{
						return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
					}

					/// <summary><code>optional string dep = 3;</code></summary>
					public string GetDep()
					{
						object @ref = dep_;
						if (!(@ref is string))
						{
							ByteString bs = (ByteString)@ref;
							string s = bs.ToStringUtf8();
							if (bs.IsValidUtf8())
							{
								dep_ = s;
							}
							return s;
						}
						else
						{
							return (string)@ref;
						}
					}

					/// <summary><code>optional string dep = 3;</code></summary>
					public ByteString GetDepBytes()
					{
						object @ref = dep_;
						if (@ref is string)
						{
							ByteString b = ByteString.CopyFromUtf8((string)@ref);
							dep_ = b;
							return b;
						}
						else
						{
							return (ByteString)@ref;
						}
					}

					/// <summary><code>optional string dep = 3;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetDep(string value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000004));
						dep_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional string dep = 3;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder ClearDep()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						dep_ = GetDefaultInstance().GetDep();
						OnChanged();
						return this;
					}

					/// <summary><code>optional string dep = 3;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetDepBytes(ByteString value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000004));
						dep_ = value;
						OnChanged();
						return this;
					}

					private bool isExtra_;

					/// <summary><code>optional bool isExtra = 4;</code></summary>
					public bool HasIsExtra()
					{
						return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
					}

					/// <summary><code>optional bool isExtra = 4;</code></summary>
					public bool GetIsExtra()
					{
						return isExtra_;
					}

					/// <summary><code>optional bool isExtra = 4;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetIsExtra(bool value)
					{
						bitField0_ |= unchecked((int)(0x00000008));
						isExtra_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional bool isExtra = 4;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder ClearIsExtra()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
						isExtra_ = false;
						OnChanged();
						return this;
					}

					private int sourceCopy_;

					/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
					public bool HasSourceCopy()
					{
						return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
					}

					/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
					public int GetSourceCopy()
					{
						return sourceCopy_;
					}

					/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetSourceCopy(int value)
					{
						bitField0_ |= unchecked((int)(0x00000010));
						sourceCopy_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional uint32 sourceCopy = 5;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder ClearSourceCopy()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
						sourceCopy_ = 0;
						OnChanged();
						return this;
					}

					private int targetCopy_;

					/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
					public bool HasTargetCopy()
					{
						return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
					}

					/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
					public int GetTargetCopy()
					{
						return targetCopy_;
					}

					/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetTargetCopy(int value)
					{
						bitField0_ |= unchecked((int)(0x00000020));
						targetCopy_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional uint32 targetCopy = 6;</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder ClearTargetCopy()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						targetCopy_ = 0;
						OnChanged();
						return this;
					}

					private int language_ = 0;

					/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
					public bool HasLanguage()
					{
						return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
					}

					/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
					public CoreNLPProtos.Language GetLanguage()
					{
						CoreNLPProtos.Language result = CoreNLPProtos.Language.ValueOf(language_);
						return result == null ? CoreNLPProtos.Language.Unknown : result;
					}

					/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder SetLanguage(CoreNLPProtos.Language value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000040));
						language_ = value.GetNumber();
						OnChanged();
						return this;
					}

					/// <summary><code>optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];</code></summary>
					public CoreNLPProtos.DependencyGraph.Edge.Builder ClearLanguage()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						language_ = 0;
						OnChanged();
						return this;
					}

					public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
					{
						return base.SetUnknownFields(unknownFields);
					}

					public sealed override CoreNLPProtos.DependencyGraph.Edge.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
					{
						return base.MergeUnknownFields(unknownFields);
					}
					// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
				}

				private static readonly CoreNLPProtos.DependencyGraph.Edge DefaultInstance;

				static Edge()
				{
					// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
					DefaultInstance = new CoreNLPProtos.DependencyGraph.Edge();
				}

				public static CoreNLPProtos.DependencyGraph.Edge GetDefaultInstance()
				{
					return DefaultInstance;
				}

				private sealed class _AbstractParser_31995 : AbstractParser<CoreNLPProtos.DependencyGraph.Edge>
				{
					public _AbstractParser_31995()
					{
					}

					/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
					public override CoreNLPProtos.DependencyGraph.Edge ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					{
						return new CoreNLPProtos.DependencyGraph.Edge(input, extensionRegistry);
					}
				}

				[Obsolete]
				public static readonly IParser<CoreNLPProtos.DependencyGraph.Edge> Parser = new _AbstractParser_31995();

				public static IParser<CoreNLPProtos.DependencyGraph.Edge> Parser()
				{
					return Parser;
				}

				public override IParser<IMessageLite> GetParserForType()
				{
					return Parser;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return DefaultInstance;
				}
			}

			public const int NodeFieldNumber = 1;

			private IList<CoreNLPProtos.DependencyGraph.Node> node_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			public IList<CoreNLPProtos.DependencyGraph.Node> GetNodeList()
			{
				return node_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			public IList<CoreNLPProtos.DependencyGraph.INodeOrBuilder> GetNodeOrBuilderList()
			{
				return node_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			public int GetNodeCount()
			{
				return node_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			public CoreNLPProtos.DependencyGraph.Node GetNode(int index)
			{
				return node_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
			public CoreNLPProtos.DependencyGraph.INodeOrBuilder GetNodeOrBuilder(int index)
			{
				return node_[index];
			}

			public const int EdgeFieldNumber = 2;

			private IList<CoreNLPProtos.DependencyGraph.Edge> edge_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			public IList<CoreNLPProtos.DependencyGraph.Edge> GetEdgeList()
			{
				return edge_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			public IList<CoreNLPProtos.DependencyGraph.IEdgeOrBuilder> GetEdgeOrBuilderList()
			{
				return edge_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			public int GetEdgeCount()
			{
				return edge_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			public CoreNLPProtos.DependencyGraph.Edge GetEdge(int index)
			{
				return edge_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
			public CoreNLPProtos.DependencyGraph.IEdgeOrBuilder GetEdgeOrBuilder(int index)
			{
				return edge_[index];
			}

			public const int RootFieldNumber = 3;

			private IList<int> root_;

			/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
			public IList<int> GetRootList()
			{
				return root_;
			}

			/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
			public int GetRootCount()
			{
				return root_.Count;
			}

			/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
			public int GetRoot(int index)
			{
				return root_[index];
			}

			private int rootMemoizedSerializedSize = -1;

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				for (int i = 0; i < GetNodeCount(); i++)
				{
					if (!GetNode(i).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				for (int i_1 = 0; i_1 < GetEdgeCount(); i_1++)
				{
					if (!GetEdge(i_1).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				GetSerializedSize();
				for (int i = 0; i < node_.Count; i++)
				{
					output.WriteMessage(1, node_[i]);
				}
				for (int i_1 = 0; i_1 < edge_.Count; i_1++)
				{
					output.WriteMessage(2, edge_[i_1]);
				}
				if (GetRootList().Count > 0)
				{
					output.WriteUInt32NoTag(26);
					output.WriteUInt32NoTag(rootMemoizedSerializedSize);
				}
				for (int i_2 = 0; i_2 < root_.Count; i_2++)
				{
					output.WriteUInt32NoTag(root_[i_2]);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				for (int i = 0; i < node_.Count; i++)
				{
					size += CodedOutputStream.ComputeMessageSize(1, node_[i]);
				}
				for (int i_1 = 0; i_1 < edge_.Count; i_1++)
				{
					size += CodedOutputStream.ComputeMessageSize(2, edge_[i_1]);
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < root_.Count; i_2++)
					{
						dataSize += CodedOutputStream.ComputeUInt32SizeNoTag(root_[i_2]);
					}
					size += dataSize;
					if (!GetRootList().IsEmpty())
					{
						size += 1;
						size += CodedOutputStream.ComputeInt32SizeNoTag(dataSize);
					}
					rootMemoizedSerializedSize = dataSize;
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.DependencyGraph))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.DependencyGraph other = (CoreNLPProtos.DependencyGraph)obj;
				bool result = true;
				result = result && GetNodeList().Equals(other.GetNodeList());
				result = result && GetEdgeList().Equals(other.GetEdgeList());
				result = result && GetRootList().Equals(other.GetRootList());
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (GetNodeCount() > 0)
				{
					hash = (37 * hash) + NodeFieldNumber;
					hash = (53 * hash) + GetNodeList().GetHashCode();
				}
				if (GetEdgeCount() > 0)
				{
					hash = (37 * hash) + EdgeFieldNumber;
					hash = (53 * hash) + GetEdgeList().GetHashCode();
				}
				if (GetRootCount() > 0)
				{
					hash = (37 * hash) + RootFieldNumber;
					hash = (53 * hash) + GetRootList().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.DependencyGraph ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.DependencyGraph ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.DependencyGraph ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.DependencyGraph.Builder NewBuilder()
			{
				return ((CoreNLPProtos.DependencyGraph.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.DependencyGraph.Builder NewBuilder(CoreNLPProtos.DependencyGraph prototype)
			{
				return ((CoreNLPProtos.DependencyGraph.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.DependencyGraph.Builder() : new CoreNLPProtos.DependencyGraph.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.DependencyGraph.Builder builder = new CoreNLPProtos.DependencyGraph.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A dependency graph representation.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A dependency graph representation.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.DependencyGraph</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.DependencyGraph.Builder>, CoreNLPProtos.IDependencyGraphOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.DependencyGraph)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.DependencyGraph), typeof(CoreNLPProtos.DependencyGraph.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.DependencyGraph.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetNodeFieldBuilder();
						GetEdgeFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					if (nodeBuilder_ == null)
					{
						node_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					else
					{
						nodeBuilder_.Clear();
					}
					if (edgeBuilder_ == null)
					{
						edge_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					else
					{
						edgeBuilder_.Clear();
					}
					root_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.DependencyGraph.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.DependencyGraph result = ((CoreNLPProtos.DependencyGraph)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.DependencyGraph result = new CoreNLPProtos.DependencyGraph(this);
					int from_bitField0_ = bitField0_;
					if (nodeBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
						{
							node_ = Java.Util.Collections.UnmodifiableList(node_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						result.node_ = node_;
					}
					else
					{
						result.node_ = nodeBuilder_.Build();
					}
					if (edgeBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							edge_ = Java.Util.Collections.UnmodifiableList(edge_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						result.edge_ = edge_;
					}
					else
					{
						result.edge_ = edgeBuilder_.Build();
					}
					if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						root_ = Java.Util.Collections.UnmodifiableList(root_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					}
					result.root_ = root_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.DependencyGraph.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.DependencyGraph.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.DependencyGraph.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.DependencyGraph.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.DependencyGraph.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.DependencyGraph.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.DependencyGraph.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.DependencyGraph.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.DependencyGraph)
					{
						return MergeFrom((CoreNLPProtos.DependencyGraph)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.DependencyGraph.Builder MergeFrom(CoreNLPProtos.DependencyGraph other)
				{
					if (other == CoreNLPProtos.DependencyGraph.GetDefaultInstance())
					{
						return this;
					}
					if (nodeBuilder_ == null)
					{
						if (!other.node_.IsEmpty())
						{
							if (node_.IsEmpty())
							{
								node_ = other.node_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
							}
							else
							{
								EnsureNodeIsMutable();
								Sharpen.Collections.AddAll(node_, other.node_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.node_.IsEmpty())
						{
							if (nodeBuilder_.IsEmpty())
							{
								nodeBuilder_.Dispose();
								nodeBuilder_ = null;
								node_ = other.node_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
								nodeBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetNodeFieldBuilder() : null;
							}
							else
							{
								nodeBuilder_.AddAllMessages(other.node_);
							}
						}
					}
					if (edgeBuilder_ == null)
					{
						if (!other.edge_.IsEmpty())
						{
							if (edge_.IsEmpty())
							{
								edge_ = other.edge_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
							}
							else
							{
								EnsureEdgeIsMutable();
								Sharpen.Collections.AddAll(edge_, other.edge_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.edge_.IsEmpty())
						{
							if (edgeBuilder_.IsEmpty())
							{
								edgeBuilder_.Dispose();
								edgeBuilder_ = null;
								edge_ = other.edge_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
								edgeBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetEdgeFieldBuilder() : null;
							}
							else
							{
								edgeBuilder_.AddAllMessages(other.edge_);
							}
						}
					}
					if (!other.root_.IsEmpty())
					{
						if (root_.IsEmpty())
						{
							root_ = other.root_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						}
						else
						{
							EnsureRootIsMutable();
							Sharpen.Collections.AddAll(root_, other.root_);
						}
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					for (int i = 0; i < GetNodeCount(); i++)
					{
						if (!GetNode(i).IsInitialized())
						{
							return false;
						}
					}
					for (int i_1 = 0; i_1 < GetEdgeCount(); i_1++)
					{
						if (!GetEdge(i_1).IsInitialized())
						{
							return false;
						}
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.DependencyGraph parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.DependencyGraph)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private IList<CoreNLPProtos.DependencyGraph.Node> node_ = Java.Util.Collections.EmptyList();

				private void EnsureNodeIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						node_ = new List<CoreNLPProtos.DependencyGraph.Node>(node_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.DependencyGraph.Node, CoreNLPProtos.DependencyGraph.Node.Builder, CoreNLPProtos.DependencyGraph.INodeOrBuilder> nodeBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public IList<CoreNLPProtos.DependencyGraph.Node> GetNodeList()
				{
					if (nodeBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(node_);
					}
					else
					{
						return nodeBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public int GetNodeCount()
				{
					if (nodeBuilder_ == null)
					{
						return node_.Count;
					}
					else
					{
						return nodeBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Node GetNode(int index)
				{
					if (nodeBuilder_ == null)
					{
						return node_[index];
					}
					else
					{
						return nodeBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder SetNode(int index, CoreNLPProtos.DependencyGraph.Node value)
				{
					if (nodeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureNodeIsMutable();
						node_.Set(index, value);
						OnChanged();
					}
					else
					{
						nodeBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder SetNode(int index, CoreNLPProtos.DependencyGraph.Node.Builder builderForValue)
				{
					if (nodeBuilder_ == null)
					{
						EnsureNodeIsMutable();
						node_.Set(index, ((CoreNLPProtos.DependencyGraph.Node)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						nodeBuilder_.SetMessage(index, ((CoreNLPProtos.DependencyGraph.Node)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddNode(CoreNLPProtos.DependencyGraph.Node value)
				{
					if (nodeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureNodeIsMutable();
						node_.Add(value);
						OnChanged();
					}
					else
					{
						nodeBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddNode(int index, CoreNLPProtos.DependencyGraph.Node value)
				{
					if (nodeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureNodeIsMutable();
						node_.Add(index, value);
						OnChanged();
					}
					else
					{
						nodeBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddNode(CoreNLPProtos.DependencyGraph.Node.Builder builderForValue)
				{
					if (nodeBuilder_ == null)
					{
						EnsureNodeIsMutable();
						node_.Add(((CoreNLPProtos.DependencyGraph.Node)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						nodeBuilder_.AddMessage(((CoreNLPProtos.DependencyGraph.Node)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddNode(int index, CoreNLPProtos.DependencyGraph.Node.Builder builderForValue)
				{
					if (nodeBuilder_ == null)
					{
						EnsureNodeIsMutable();
						node_.Add(index, ((CoreNLPProtos.DependencyGraph.Node)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						nodeBuilder_.AddMessage(index, ((CoreNLPProtos.DependencyGraph.Node)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddAllNode<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.DependencyGraph.Node
				{
					if (nodeBuilder_ == null)
					{
						EnsureNodeIsMutable();
						AbstractMessageLite.Builder.AddAll(values, node_);
						OnChanged();
					}
					else
					{
						nodeBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder ClearNode()
				{
					if (nodeBuilder_ == null)
					{
						node_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						OnChanged();
					}
					else
					{
						nodeBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder RemoveNode(int index)
				{
					if (nodeBuilder_ == null)
					{
						EnsureNodeIsMutable();
						node_.Remove(index);
						OnChanged();
					}
					else
					{
						nodeBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Node.Builder GetNodeBuilder(int index)
				{
					return GetNodeFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.INodeOrBuilder GetNodeOrBuilder(int index)
				{
					if (nodeBuilder_ == null)
					{
						return node_[index];
					}
					else
					{
						return nodeBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public IList<CoreNLPProtos.DependencyGraph.INodeOrBuilder> GetNodeOrBuilderList()
				{
					if (nodeBuilder_ != null)
					{
						return nodeBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(node_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Node.Builder AddNodeBuilder()
				{
					return GetNodeFieldBuilder().AddBuilder(CoreNLPProtos.DependencyGraph.Node.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public CoreNLPProtos.DependencyGraph.Node.Builder AddNodeBuilder(int index)
				{
					return GetNodeFieldBuilder().AddBuilder(index, CoreNLPProtos.DependencyGraph.Node.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;</code></summary>
				public IList<CoreNLPProtos.DependencyGraph.Node.Builder> GetNodeBuilderList()
				{
					return GetNodeFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.DependencyGraph.Node, CoreNLPProtos.DependencyGraph.Node.Builder, CoreNLPProtos.DependencyGraph.INodeOrBuilder> GetNodeFieldBuilder()
				{
					if (nodeBuilder_ == null)
					{
						nodeBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.DependencyGraph.Node, CoreNLPProtos.DependencyGraph.Node.Builder, CoreNLPProtos.DependencyGraph.INodeOrBuilder>(node_, ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001
							))), GetParentForChildren(), IsClean());
						node_ = null;
					}
					return nodeBuilder_;
				}

				private IList<CoreNLPProtos.DependencyGraph.Edge> edge_ = Java.Util.Collections.EmptyList();

				private void EnsureEdgeIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						edge_ = new List<CoreNLPProtos.DependencyGraph.Edge>(edge_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.DependencyGraph.Edge, CoreNLPProtos.DependencyGraph.Edge.Builder, CoreNLPProtos.DependencyGraph.IEdgeOrBuilder> edgeBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public IList<CoreNLPProtos.DependencyGraph.Edge> GetEdgeList()
				{
					if (edgeBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(edge_);
					}
					else
					{
						return edgeBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public int GetEdgeCount()
				{
					if (edgeBuilder_ == null)
					{
						return edge_.Count;
					}
					else
					{
						return edgeBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Edge GetEdge(int index)
				{
					if (edgeBuilder_ == null)
					{
						return edge_[index];
					}
					else
					{
						return edgeBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder SetEdge(int index, CoreNLPProtos.DependencyGraph.Edge value)
				{
					if (edgeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEdgeIsMutable();
						edge_.Set(index, value);
						OnChanged();
					}
					else
					{
						edgeBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder SetEdge(int index, CoreNLPProtos.DependencyGraph.Edge.Builder builderForValue)
				{
					if (edgeBuilder_ == null)
					{
						EnsureEdgeIsMutable();
						edge_.Set(index, ((CoreNLPProtos.DependencyGraph.Edge)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						edgeBuilder_.SetMessage(index, ((CoreNLPProtos.DependencyGraph.Edge)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddEdge(CoreNLPProtos.DependencyGraph.Edge value)
				{
					if (edgeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEdgeIsMutable();
						edge_.Add(value);
						OnChanged();
					}
					else
					{
						edgeBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddEdge(int index, CoreNLPProtos.DependencyGraph.Edge value)
				{
					if (edgeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureEdgeIsMutable();
						edge_.Add(index, value);
						OnChanged();
					}
					else
					{
						edgeBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddEdge(CoreNLPProtos.DependencyGraph.Edge.Builder builderForValue)
				{
					if (edgeBuilder_ == null)
					{
						EnsureEdgeIsMutable();
						edge_.Add(((CoreNLPProtos.DependencyGraph.Edge)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						edgeBuilder_.AddMessage(((CoreNLPProtos.DependencyGraph.Edge)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddEdge(int index, CoreNLPProtos.DependencyGraph.Edge.Builder builderForValue)
				{
					if (edgeBuilder_ == null)
					{
						EnsureEdgeIsMutable();
						edge_.Add(index, ((CoreNLPProtos.DependencyGraph.Edge)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						edgeBuilder_.AddMessage(index, ((CoreNLPProtos.DependencyGraph.Edge)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddAllEdge<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.DependencyGraph.Edge
				{
					if (edgeBuilder_ == null)
					{
						EnsureEdgeIsMutable();
						AbstractMessageLite.Builder.AddAll(values, edge_);
						OnChanged();
					}
					else
					{
						edgeBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder ClearEdge()
				{
					if (edgeBuilder_ == null)
					{
						edge_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						OnChanged();
					}
					else
					{
						edgeBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder RemoveEdge(int index)
				{
					if (edgeBuilder_ == null)
					{
						EnsureEdgeIsMutable();
						edge_.Remove(index);
						OnChanged();
					}
					else
					{
						edgeBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Edge.Builder GetEdgeBuilder(int index)
				{
					return GetEdgeFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.IEdgeOrBuilder GetEdgeOrBuilder(int index)
				{
					if (edgeBuilder_ == null)
					{
						return edge_[index];
					}
					else
					{
						return edgeBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public IList<CoreNLPProtos.DependencyGraph.IEdgeOrBuilder> GetEdgeOrBuilderList()
				{
					if (edgeBuilder_ != null)
					{
						return edgeBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(edge_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Edge.Builder AddEdgeBuilder()
				{
					return GetEdgeFieldBuilder().AddBuilder(CoreNLPProtos.DependencyGraph.Edge.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public CoreNLPProtos.DependencyGraph.Edge.Builder AddEdgeBuilder(int index)
				{
					return GetEdgeFieldBuilder().AddBuilder(index, CoreNLPProtos.DependencyGraph.Edge.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;</code></summary>
				public IList<CoreNLPProtos.DependencyGraph.Edge.Builder> GetEdgeBuilderList()
				{
					return GetEdgeFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.DependencyGraph.Edge, CoreNLPProtos.DependencyGraph.Edge.Builder, CoreNLPProtos.DependencyGraph.IEdgeOrBuilder> GetEdgeFieldBuilder()
				{
					if (edgeBuilder_ == null)
					{
						edgeBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.DependencyGraph.Edge, CoreNLPProtos.DependencyGraph.Edge.Builder, CoreNLPProtos.DependencyGraph.IEdgeOrBuilder>(edge_, ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002
							))), GetParentForChildren(), IsClean());
						edge_ = null;
					}
					return edgeBuilder_;
				}

				private IList<int> root_ = Java.Util.Collections.EmptyList();

				private void EnsureRootIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						root_ = new List<int>(root_);
						bitField0_ |= unchecked((int)(0x00000004));
					}
				}

				/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
				public IList<int> GetRootList()
				{
					return Java.Util.Collections.UnmodifiableList(root_);
				}

				/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
				public int GetRootCount()
				{
					return root_.Count;
				}

				/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
				public int GetRoot(int index)
				{
					return root_[index];
				}

				/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder SetRoot(int index, int value)
				{
					EnsureRootIsMutable();
					root_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddRoot(int value)
				{
					EnsureRootIsMutable();
					root_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder AddAllRoot<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureRootIsMutable();
					AbstractMessageLite.Builder.AddAll(values, root_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 root = 3 [packed = true];</code></summary>
				public CoreNLPProtos.DependencyGraph.Builder ClearRoot()
				{
					root_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.DependencyGraph.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.DependencyGraph)
			}

			private static readonly CoreNLPProtos.DependencyGraph DefaultInstance;

			static DependencyGraph()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.DependencyGraph)
				DefaultInstance = new CoreNLPProtos.DependencyGraph();
			}

			public static CoreNLPProtos.DependencyGraph GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_33121 : AbstractParser<CoreNLPProtos.DependencyGraph>
			{
				public _AbstractParser_33121()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.DependencyGraph ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.DependencyGraph(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.DependencyGraph> Parser = new _AbstractParser_33121();

			public static IParser<CoreNLPProtos.DependencyGraph> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ICorefChainOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.CorefChain)
			/// <summary><code>required int32 chainID = 1;</code></summary>
			bool HasChainID();

			/// <summary><code>required int32 chainID = 1;</code></summary>
			int GetChainID();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			IList<CoreNLPProtos.CorefChain.CorefMention> GetMentionList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			CoreNLPProtos.CorefChain.CorefMention GetMention(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			int GetMentionCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			IList<CoreNLPProtos.CorefChain.ICorefMentionOrBuilder> GetMentionOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			CoreNLPProtos.CorefChain.ICorefMentionOrBuilder GetMentionOrBuilder(int index);

			/// <summary><code>required uint32 representative = 3;</code></summary>
			bool HasRepresentative();

			/// <summary><code>required uint32 representative = 3;</code></summary>
			int GetRepresentative();
		}

		/// <summary>
		/// <pre>
		/// A coreference chain.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A coreference chain.
		/// These fields are not *really* optional. CoreNLP will crash without them.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.CorefChain</c>
		/// </remarks>
		[System.Serializable]
		public sealed class CorefChain : GeneratedMessageV3, CoreNLPProtos.ICorefChainOrBuilder
		{
			private CorefChain(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private CorefChain()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.CorefChain)
				// Use CorefChain.newBuilder() to construct.
				chainID_ = 0;
				mention_ = Java.Util.Collections.EmptyList();
				representative_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private CorefChain(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								chainID_ = input.ReadInt32();
								break;
							}

							case 18:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									mention_ = new List<CoreNLPProtos.CorefChain.CorefMention>();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								mention_.Add(input.ReadMessage(CoreNLPProtos.CorefChain.CorefMention.Parser, extensionRegistry));
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								representative_ = input.ReadUInt32();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						mention_ = Java.Util.Collections.UnmodifiableList(mention_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.CorefChain), typeof(CoreNLPProtos.CorefChain.Builder));
			}

			public interface ICorefMentionOrBuilder : IMessageOrBuilder
			{
				// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				bool HasMentionID();

				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				int GetMentionID();

				/// <summary><code>optional string mentionType = 2;</code></summary>
				bool HasMentionType();

				/// <summary><code>optional string mentionType = 2;</code></summary>
				string GetMentionType();

				/// <summary><code>optional string mentionType = 2;</code></summary>
				ByteString GetMentionTypeBytes();

				/// <summary><code>optional string number = 3;</code></summary>
				bool HasNumber();

				/// <summary><code>optional string number = 3;</code></summary>
				string GetNumber();

				/// <summary><code>optional string number = 3;</code></summary>
				ByteString GetNumberBytes();

				/// <summary><code>optional string gender = 4;</code></summary>
				bool HasGender();

				/// <summary><code>optional string gender = 4;</code></summary>
				string GetGender();

				/// <summary><code>optional string gender = 4;</code></summary>
				ByteString GetGenderBytes();

				/// <summary><code>optional string animacy = 5;</code></summary>
				bool HasAnimacy();

				/// <summary><code>optional string animacy = 5;</code></summary>
				string GetAnimacy();

				/// <summary><code>optional string animacy = 5;</code></summary>
				ByteString GetAnimacyBytes();

				/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
				bool HasBeginIndex();

				/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
				int GetBeginIndex();

				/// <summary><code>optional uint32 endIndex = 7;</code></summary>
				bool HasEndIndex();

				/// <summary><code>optional uint32 endIndex = 7;</code></summary>
				int GetEndIndex();

				/// <summary><code>optional uint32 headIndex = 9;</code></summary>
				bool HasHeadIndex();

				/// <summary><code>optional uint32 headIndex = 9;</code></summary>
				int GetHeadIndex();

				/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
				bool HasSentenceIndex();

				/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
				int GetSentenceIndex();

				/// <summary>
				/// <pre>
				/// the second element of position
				/// </pre>
				/// <code>optional uint32 position = 11;</code>
				/// </summary>
				bool HasPosition();

				/// <summary>
				/// <pre>
				/// the second element of position
				/// </pre>
				/// <code>optional uint32 position = 11;</code>
				/// </summary>
				int GetPosition();
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.CorefChain.CorefMention</c>
			/// </summary>
			[System.Serializable]
			public sealed class CorefMention : GeneratedMessageV3, CoreNLPProtos.CorefChain.ICorefMentionOrBuilder
			{
				private CorefMention(GeneratedMessageV3.Builder<object> builder)
					: base(builder)
				{
				}

				private CorefMention()
				{
					// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
					// Use CorefMention.newBuilder() to construct.
					mentionID_ = 0;
					mentionType_ = string.Empty;
					number_ = string.Empty;
					gender_ = string.Empty;
					animacy_ = string.Empty;
					beginIndex_ = 0;
					endIndex_ = 0;
					headIndex_ = 0;
					sentenceIndex_ = 0;
					position_ = 0;
				}

				public sealed override UnknownFieldSet GetUnknownFields()
				{
					return this.unknownFields;
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				private CorefMention(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					: this()
				{
					int mutable_bitField0_ = 0;
					UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
					try
					{
						bool done = false;
						while (!done)
						{
							int tag = input.ReadTag();
							switch (tag)
							{
								case 0:
								{
									done = true;
									break;
								}

								default:
								{
									if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
									{
										done = true;
									}
									break;
								}

								case 8:
								{
									bitField0_ |= unchecked((int)(0x00000001));
									mentionID_ = input.ReadInt32();
									break;
								}

								case 18:
								{
									ByteString bs = input.ReadBytes();
									bitField0_ |= unchecked((int)(0x00000002));
									mentionType_ = bs;
									break;
								}

								case 26:
								{
									ByteString bs = input.ReadBytes();
									bitField0_ |= unchecked((int)(0x00000004));
									number_ = bs;
									break;
								}

								case 34:
								{
									ByteString bs = input.ReadBytes();
									bitField0_ |= unchecked((int)(0x00000008));
									gender_ = bs;
									break;
								}

								case 42:
								{
									ByteString bs = input.ReadBytes();
									bitField0_ |= unchecked((int)(0x00000010));
									animacy_ = bs;
									break;
								}

								case 48:
								{
									bitField0_ |= unchecked((int)(0x00000020));
									beginIndex_ = input.ReadUInt32();
									break;
								}

								case 56:
								{
									bitField0_ |= unchecked((int)(0x00000040));
									endIndex_ = input.ReadUInt32();
									break;
								}

								case 72:
								{
									bitField0_ |= unchecked((int)(0x00000080));
									headIndex_ = input.ReadUInt32();
									break;
								}

								case 80:
								{
									bitField0_ |= unchecked((int)(0x00000100));
									sentenceIndex_ = input.ReadUInt32();
									break;
								}

								case 88:
								{
									bitField0_ |= unchecked((int)(0x00000200));
									position_ = input.ReadUInt32();
									break;
								}
							}
						}
					}
					catch (InvalidProtocolBufferException e)
					{
						throw e.SetUnfinishedMessage(this);
					}
					catch (IOException e)
					{
						throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
					}
					finally
					{
						this.unknownFields = unknownFields.Build();
						MakeExtensionsImmutable();
					}
				}

				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.CorefChain.CorefMention), typeof(CoreNLPProtos.CorefChain.CorefMention.Builder));
				}

				private int bitField0_;

				public const int MentionidFieldNumber = 1;

				private int mentionID_;

				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				public bool HasMentionID()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				public int GetMentionID()
				{
					return mentionID_;
				}

				public const int MentiontypeFieldNumber = 2;

				private volatile object mentionType_;

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public bool HasMentionType()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public string GetMentionType()
				{
					object @ref = mentionType_;
					if (@ref is string)
					{
						return (string)@ref;
					}
					else
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							mentionType_ = s;
						}
						return s;
					}
				}

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public ByteString GetMentionTypeBytes()
				{
					object @ref = mentionType_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						mentionType_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				public const int NumberFieldNumber = 3;

				private volatile object number_;

				/// <summary><code>optional string number = 3;</code></summary>
				public bool HasNumber()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional string number = 3;</code></summary>
				public string GetNumber()
				{
					object @ref = number_;
					if (@ref is string)
					{
						return (string)@ref;
					}
					else
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							number_ = s;
						}
						return s;
					}
				}

				/// <summary><code>optional string number = 3;</code></summary>
				public ByteString GetNumberBytes()
				{
					object @ref = number_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						number_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				public const int GenderFieldNumber = 4;

				private volatile object gender_;

				/// <summary><code>optional string gender = 4;</code></summary>
				public bool HasGender()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional string gender = 4;</code></summary>
				public string GetGender()
				{
					object @ref = gender_;
					if (@ref is string)
					{
						return (string)@ref;
					}
					else
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							gender_ = s;
						}
						return s;
					}
				}

				/// <summary><code>optional string gender = 4;</code></summary>
				public ByteString GetGenderBytes()
				{
					object @ref = gender_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						gender_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				public const int AnimacyFieldNumber = 5;

				private volatile object animacy_;

				/// <summary><code>optional string animacy = 5;</code></summary>
				public bool HasAnimacy()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional string animacy = 5;</code></summary>
				public string GetAnimacy()
				{
					object @ref = animacy_;
					if (@ref is string)
					{
						return (string)@ref;
					}
					else
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							animacy_ = s;
						}
						return s;
					}
				}

				/// <summary><code>optional string animacy = 5;</code></summary>
				public ByteString GetAnimacyBytes()
				{
					object @ref = animacy_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						animacy_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				public const int BeginindexFieldNumber = 6;

				private int beginIndex_;

				/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
				public bool HasBeginIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
				public int GetBeginIndex()
				{
					return beginIndex_;
				}

				public const int EndindexFieldNumber = 7;

				private int endIndex_;

				/// <summary><code>optional uint32 endIndex = 7;</code></summary>
				public bool HasEndIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional uint32 endIndex = 7;</code></summary>
				public int GetEndIndex()
				{
					return endIndex_;
				}

				public const int HeadindexFieldNumber = 9;

				private int headIndex_;

				/// <summary><code>optional uint32 headIndex = 9;</code></summary>
				public bool HasHeadIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary><code>optional uint32 headIndex = 9;</code></summary>
				public int GetHeadIndex()
				{
					return headIndex_;
				}

				public const int SentenceindexFieldNumber = 10;

				private int sentenceIndex_;

				/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
				public bool HasSentenceIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
				public int GetSentenceIndex()
				{
					return sentenceIndex_;
				}

				public const int PositionFieldNumber = 11;

				private int position_;

				/// <summary>
				/// <pre>
				/// the second element of position
				/// </pre>
				/// <code>optional uint32 position = 11;</code>
				/// </summary>
				public bool HasPosition()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary>
				/// <pre>
				/// the second element of position
				/// </pre>
				/// <code>optional uint32 position = 11;</code>
				/// </summary>
				public int GetPosition()
				{
					return position_;
				}

				private byte memoizedIsInitialized = unchecked((byte)(-1));

				public sealed override bool IsInitialized()
				{
					byte isInitialized = memoizedIsInitialized;
					if (isInitialized == 1)
					{
						return true;
					}
					if (isInitialized == 0)
					{
						return false;
					}
					memoizedIsInitialized = 1;
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override void WriteTo(CodedOutputStream output)
				{
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						output.WriteInt32(1, mentionID_);
					}
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						GeneratedMessageV3.WriteString(output, 2, mentionType_);
					}
					if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						GeneratedMessageV3.WriteString(output, 3, number_);
					}
					if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						GeneratedMessageV3.WriteString(output, 4, gender_);
					}
					if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						GeneratedMessageV3.WriteString(output, 5, animacy_);
					}
					if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						output.WriteUInt32(6, beginIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						output.WriteUInt32(7, endIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						output.WriteUInt32(9, headIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						output.WriteUInt32(10, sentenceIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						output.WriteUInt32(11, position_);
					}
					unknownFields.WriteTo(output);
				}

				public override int GetSerializedSize()
				{
					int size = memoizedSize;
					if (size != -1)
					{
						return size;
					}
					size = 0;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						size += CodedOutputStream.ComputeInt32Size(1, mentionID_);
					}
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						size += GeneratedMessageV3.ComputeStringSize(2, mentionType_);
					}
					if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						size += GeneratedMessageV3.ComputeStringSize(3, number_);
					}
					if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						size += GeneratedMessageV3.ComputeStringSize(4, gender_);
					}
					if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						size += GeneratedMessageV3.ComputeStringSize(5, animacy_);
					}
					if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						size += CodedOutputStream.ComputeUInt32Size(6, beginIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						size += CodedOutputStream.ComputeUInt32Size(7, endIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						size += CodedOutputStream.ComputeUInt32Size(9, headIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						size += CodedOutputStream.ComputeUInt32Size(10, sentenceIndex_);
					}
					if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						size += CodedOutputStream.ComputeUInt32Size(11, position_);
					}
					size += unknownFields.GetSerializedSize();
					memoizedSize = size;
					return size;
				}

				private const long serialVersionUID = 0L;

				public override bool Equals(object obj)
				{
					if (obj == this)
					{
						return true;
					}
					if (!(obj is CoreNLPProtos.CorefChain.CorefMention))
					{
						return base.Equals(obj);
					}
					CoreNLPProtos.CorefChain.CorefMention other = (CoreNLPProtos.CorefChain.CorefMention)obj;
					bool result = true;
					result = result && (HasMentionID() == other.HasMentionID());
					if (HasMentionID())
					{
						result = result && (GetMentionID() == other.GetMentionID());
					}
					result = result && (HasMentionType() == other.HasMentionType());
					if (HasMentionType())
					{
						result = result && GetMentionType().Equals(other.GetMentionType());
					}
					result = result && (HasNumber() == other.HasNumber());
					if (HasNumber())
					{
						result = result && GetNumber().Equals(other.GetNumber());
					}
					result = result && (HasGender() == other.HasGender());
					if (HasGender())
					{
						result = result && GetGender().Equals(other.GetGender());
					}
					result = result && (HasAnimacy() == other.HasAnimacy());
					if (HasAnimacy())
					{
						result = result && GetAnimacy().Equals(other.GetAnimacy());
					}
					result = result && (HasBeginIndex() == other.HasBeginIndex());
					if (HasBeginIndex())
					{
						result = result && (GetBeginIndex() == other.GetBeginIndex());
					}
					result = result && (HasEndIndex() == other.HasEndIndex());
					if (HasEndIndex())
					{
						result = result && (GetEndIndex() == other.GetEndIndex());
					}
					result = result && (HasHeadIndex() == other.HasHeadIndex());
					if (HasHeadIndex())
					{
						result = result && (GetHeadIndex() == other.GetHeadIndex());
					}
					result = result && (HasSentenceIndex() == other.HasSentenceIndex());
					if (HasSentenceIndex())
					{
						result = result && (GetSentenceIndex() == other.GetSentenceIndex());
					}
					result = result && (HasPosition() == other.HasPosition());
					if (HasPosition())
					{
						result = result && (GetPosition() == other.GetPosition());
					}
					result = result && unknownFields.Equals(other.unknownFields);
					return result;
				}

				public override int GetHashCode()
				{
					if (memoizedHashCode != 0)
					{
						return memoizedHashCode;
					}
					int hash = 41;
					hash = (19 * hash) + GetDescriptor().GetHashCode();
					if (HasMentionID())
					{
						hash = (37 * hash) + MentionidFieldNumber;
						hash = (53 * hash) + GetMentionID();
					}
					if (HasMentionType())
					{
						hash = (37 * hash) + MentiontypeFieldNumber;
						hash = (53 * hash) + GetMentionType().GetHashCode();
					}
					if (HasNumber())
					{
						hash = (37 * hash) + NumberFieldNumber;
						hash = (53 * hash) + GetNumber().GetHashCode();
					}
					if (HasGender())
					{
						hash = (37 * hash) + GenderFieldNumber;
						hash = (53 * hash) + GetGender().GetHashCode();
					}
					if (HasAnimacy())
					{
						hash = (37 * hash) + AnimacyFieldNumber;
						hash = (53 * hash) + GetAnimacy().GetHashCode();
					}
					if (HasBeginIndex())
					{
						hash = (37 * hash) + BeginindexFieldNumber;
						hash = (53 * hash) + GetBeginIndex();
					}
					if (HasEndIndex())
					{
						hash = (37 * hash) + EndindexFieldNumber;
						hash = (53 * hash) + GetEndIndex();
					}
					if (HasHeadIndex())
					{
						hash = (37 * hash) + HeadindexFieldNumber;
						hash = (53 * hash) + GetHeadIndex();
					}
					if (HasSentenceIndex())
					{
						hash = (37 * hash) + SentenceindexFieldNumber;
						hash = (53 * hash) + GetSentenceIndex();
					}
					if (HasPosition())
					{
						hash = (37 * hash) + PositionFieldNumber;
						hash = (53 * hash) + GetPosition();
					}
					hash = (29 * hash) + unknownFields.GetHashCode();
					memoizedHashCode = hash;
					return hash;
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(ByteString data)
				{
					return Parser.ParseFrom(data);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
				{
					return Parser.ParseFrom(data, extensionRegistry);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(byte[] data)
				{
					return Parser.ParseFrom(data);
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
				{
					return Parser.ParseFrom(data, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(InputStream input)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseDelimitedFrom(InputStream input)
				{
					return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(CodedInputStream input)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input);
				}

				/// <exception cref="System.IO.IOException"/>
				public static CoreNLPProtos.CorefChain.CorefMention ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
				}

				public override MessageLite.IBuilder NewBuilderForType()
				{
					return NewBuilder();
				}

				public static CoreNLPProtos.CorefChain.CorefMention.Builder NewBuilder()
				{
					return ((CoreNLPProtos.CorefChain.CorefMention.Builder)DefaultInstance.ToBuilder());
				}

				public static CoreNLPProtos.CorefChain.CorefMention.Builder NewBuilder(CoreNLPProtos.CorefChain.CorefMention prototype)
				{
					return ((CoreNLPProtos.CorefChain.CorefMention.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
				}

				public override MessageLite.IBuilder ToBuilder()
				{
					return this == DefaultInstance ? new CoreNLPProtos.CorefChain.CorefMention.Builder() : new CoreNLPProtos.CorefChain.CorefMention.Builder().MergeFrom(this);
				}

				protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
				{
					CoreNLPProtos.CorefChain.CorefMention.Builder builder = new CoreNLPProtos.CorefChain.CorefMention.Builder(parent);
					return builder;
				}

				/// <summary>
				/// Protobuf type
				/// <c>edu.stanford.nlp.pipeline.CorefChain.CorefMention</c>
				/// </summary>
				public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.CorefChain.CorefMention.Builder>, CoreNLPProtos.CorefChain.ICorefMentionOrBuilder
				{
					// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
					public static Descriptors.Descriptor GetDescriptor()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_descriptor;
					}

					protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.CorefChain.CorefMention), typeof(CoreNLPProtos.CorefChain.CorefMention.Builder));
					}

					private Builder()
					{
						// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.CorefChain.CorefMention.newBuilder()
						MaybeForceBuilderInitialization();
					}

					private Builder(GeneratedMessageV3.IBuilderParent parent)
						: base(parent)
					{
						MaybeForceBuilderInitialization();
					}

					private void MaybeForceBuilderInitialization()
					{
						if (GeneratedMessageV3.alwaysUseFieldBuilders)
						{
						}
					}

					public override MessageLite.IBuilder Clear()
					{
						base.Clear();
						mentionID_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						mentionType_ = string.Empty;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						number_ = string.Empty;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						gender_ = string.Empty;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
						animacy_ = string.Empty;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
						beginIndex_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						endIndex_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						headIndex_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
						sentenceIndex_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
						position_ = 0;
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
						return this;
					}

					public override Descriptors.Descriptor GetDescriptorForType()
					{
						return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_descriptor;
					}

					public override IMessageLite GetDefaultInstanceForType()
					{
						return CoreNLPProtos.CorefChain.CorefMention.GetDefaultInstance();
					}

					public override IMessageLite Build()
					{
						CoreNLPProtos.CorefChain.CorefMention result = ((CoreNLPProtos.CorefChain.CorefMention)BuildPartial());
						if (!result.IsInitialized())
						{
							throw NewUninitializedMessageException(result);
						}
						return result;
					}

					public override IMessageLite BuildPartial()
					{
						CoreNLPProtos.CorefChain.CorefMention result = new CoreNLPProtos.CorefChain.CorefMention(this);
						int from_bitField0_ = bitField0_;
						int to_bitField0_ = 0;
						if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
						{
							to_bitField0_ |= unchecked((int)(0x00000001));
						}
						result.mentionID_ = mentionID_;
						if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							to_bitField0_ |= unchecked((int)(0x00000002));
						}
						result.mentionType_ = mentionType_;
						if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
						{
							to_bitField0_ |= unchecked((int)(0x00000004));
						}
						result.number_ = number_;
						if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
						{
							to_bitField0_ |= unchecked((int)(0x00000008));
						}
						result.gender_ = gender_;
						if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
						{
							to_bitField0_ |= unchecked((int)(0x00000010));
						}
						result.animacy_ = animacy_;
						if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
						{
							to_bitField0_ |= unchecked((int)(0x00000020));
						}
						result.beginIndex_ = beginIndex_;
						if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
						{
							to_bitField0_ |= unchecked((int)(0x00000040));
						}
						result.endIndex_ = endIndex_;
						if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
						{
							to_bitField0_ |= unchecked((int)(0x00000080));
						}
						result.headIndex_ = headIndex_;
						if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
						{
							to_bitField0_ |= unchecked((int)(0x00000100));
						}
						result.sentenceIndex_ = sentenceIndex_;
						if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
						{
							to_bitField0_ |= unchecked((int)(0x00000200));
						}
						result.position_ = position_;
						result.bitField0_ = to_bitField0_;
						OnBuilt();
						return result;
					}

					public override AbstractMessageLite.Builder Clone()
					{
						return (CoreNLPProtos.CorefChain.CorefMention.Builder)base.Clone();
					}

					public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
					{
						return (CoreNLPProtos.CorefChain.CorefMention.Builder)base.SetField(field, value);
					}

					public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
					{
						return (CoreNLPProtos.CorefChain.CorefMention.Builder)base.ClearField(field);
					}

					public override CoreNLPProtos.CorefChain.CorefMention.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
					{
						return (CoreNLPProtos.CorefChain.CorefMention.Builder)base.ClearOneof(oneof);
					}

					public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
					{
						return (CoreNLPProtos.CorefChain.CorefMention.Builder)base.SetRepeatedField(field, index, value);
					}

					public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
					{
						return (CoreNLPProtos.CorefChain.CorefMention.Builder)base.AddRepeatedField(field, value);
					}

					public override CoreNLPProtos.CorefChain.CorefMention.Builder MergeFrom(IMessage other)
					{
						if (other is CoreNLPProtos.CorefChain.CorefMention)
						{
							return MergeFrom((CoreNLPProtos.CorefChain.CorefMention)other);
						}
						else
						{
							base.MergeFrom(other);
							return this;
						}
					}

					public CoreNLPProtos.CorefChain.CorefMention.Builder MergeFrom(CoreNLPProtos.CorefChain.CorefMention other)
					{
						if (other == CoreNLPProtos.CorefChain.CorefMention.GetDefaultInstance())
						{
							return this;
						}
						if (other.HasMentionID())
						{
							SetMentionID(other.GetMentionID());
						}
						if (other.HasMentionType())
						{
							bitField0_ |= unchecked((int)(0x00000002));
							mentionType_ = other.mentionType_;
							OnChanged();
						}
						if (other.HasNumber())
						{
							bitField0_ |= unchecked((int)(0x00000004));
							number_ = other.number_;
							OnChanged();
						}
						if (other.HasGender())
						{
							bitField0_ |= unchecked((int)(0x00000008));
							gender_ = other.gender_;
							OnChanged();
						}
						if (other.HasAnimacy())
						{
							bitField0_ |= unchecked((int)(0x00000010));
							animacy_ = other.animacy_;
							OnChanged();
						}
						if (other.HasBeginIndex())
						{
							SetBeginIndex(other.GetBeginIndex());
						}
						if (other.HasEndIndex())
						{
							SetEndIndex(other.GetEndIndex());
						}
						if (other.HasHeadIndex())
						{
							SetHeadIndex(other.GetHeadIndex());
						}
						if (other.HasSentenceIndex())
						{
							SetSentenceIndex(other.GetSentenceIndex());
						}
						if (other.HasPosition())
						{
							SetPosition(other.GetPosition());
						}
						this.MergeUnknownFields(other.unknownFields);
						OnChanged();
						return this;
					}

					public sealed override bool IsInitialized()
					{
						return true;
					}

					/// <exception cref="System.IO.IOException"/>
					public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					{
						CoreNLPProtos.CorefChain.CorefMention parsedMessage = null;
						try
						{
							parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
						}
						catch (InvalidProtocolBufferException e)
						{
							parsedMessage = (CoreNLPProtos.CorefChain.CorefMention)e.GetUnfinishedMessage();
							throw e.UnwrapIOException();
						}
						finally
						{
							if (parsedMessage != null)
							{
								MergeFrom(parsedMessage);
							}
						}
						return this;
					}

					private int bitField0_;

					private int mentionID_;

					/// <summary><code>optional int32 mentionID = 1;</code></summary>
					public bool HasMentionID()
					{
						return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
					}

					/// <summary><code>optional int32 mentionID = 1;</code></summary>
					public int GetMentionID()
					{
						return mentionID_;
					}

					/// <summary><code>optional int32 mentionID = 1;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetMentionID(int value)
					{
						bitField0_ |= unchecked((int)(0x00000001));
						mentionID_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional int32 mentionID = 1;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearMentionID()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						mentionID_ = 0;
						OnChanged();
						return this;
					}

					private object mentionType_ = string.Empty;

					/// <summary><code>optional string mentionType = 2;</code></summary>
					public bool HasMentionType()
					{
						return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
					}

					/// <summary><code>optional string mentionType = 2;</code></summary>
					public string GetMentionType()
					{
						object @ref = mentionType_;
						if (!(@ref is string))
						{
							ByteString bs = (ByteString)@ref;
							string s = bs.ToStringUtf8();
							if (bs.IsValidUtf8())
							{
								mentionType_ = s;
							}
							return s;
						}
						else
						{
							return (string)@ref;
						}
					}

					/// <summary><code>optional string mentionType = 2;</code></summary>
					public ByteString GetMentionTypeBytes()
					{
						object @ref = mentionType_;
						if (@ref is string)
						{
							ByteString b = ByteString.CopyFromUtf8((string)@ref);
							mentionType_ = b;
							return b;
						}
						else
						{
							return (ByteString)@ref;
						}
					}

					/// <summary><code>optional string mentionType = 2;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetMentionType(string value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000002));
						mentionType_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional string mentionType = 2;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearMentionType()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						mentionType_ = GetDefaultInstance().GetMentionType();
						OnChanged();
						return this;
					}

					/// <summary><code>optional string mentionType = 2;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetMentionTypeBytes(ByteString value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000002));
						mentionType_ = value;
						OnChanged();
						return this;
					}

					private object number_ = string.Empty;

					/// <summary><code>optional string number = 3;</code></summary>
					public bool HasNumber()
					{
						return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
					}

					/// <summary><code>optional string number = 3;</code></summary>
					public string GetNumber()
					{
						object @ref = number_;
						if (!(@ref is string))
						{
							ByteString bs = (ByteString)@ref;
							string s = bs.ToStringUtf8();
							if (bs.IsValidUtf8())
							{
								number_ = s;
							}
							return s;
						}
						else
						{
							return (string)@ref;
						}
					}

					/// <summary><code>optional string number = 3;</code></summary>
					public ByteString GetNumberBytes()
					{
						object @ref = number_;
						if (@ref is string)
						{
							ByteString b = ByteString.CopyFromUtf8((string)@ref);
							number_ = b;
							return b;
						}
						else
						{
							return (ByteString)@ref;
						}
					}

					/// <summary><code>optional string number = 3;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetNumber(string value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000004));
						number_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional string number = 3;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearNumber()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
						number_ = GetDefaultInstance().GetNumber();
						OnChanged();
						return this;
					}

					/// <summary><code>optional string number = 3;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetNumberBytes(ByteString value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000004));
						number_ = value;
						OnChanged();
						return this;
					}

					private object gender_ = string.Empty;

					/// <summary><code>optional string gender = 4;</code></summary>
					public bool HasGender()
					{
						return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
					}

					/// <summary><code>optional string gender = 4;</code></summary>
					public string GetGender()
					{
						object @ref = gender_;
						if (!(@ref is string))
						{
							ByteString bs = (ByteString)@ref;
							string s = bs.ToStringUtf8();
							if (bs.IsValidUtf8())
							{
								gender_ = s;
							}
							return s;
						}
						else
						{
							return (string)@ref;
						}
					}

					/// <summary><code>optional string gender = 4;</code></summary>
					public ByteString GetGenderBytes()
					{
						object @ref = gender_;
						if (@ref is string)
						{
							ByteString b = ByteString.CopyFromUtf8((string)@ref);
							gender_ = b;
							return b;
						}
						else
						{
							return (ByteString)@ref;
						}
					}

					/// <summary><code>optional string gender = 4;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetGender(string value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000008));
						gender_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional string gender = 4;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearGender()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
						gender_ = GetDefaultInstance().GetGender();
						OnChanged();
						return this;
					}

					/// <summary><code>optional string gender = 4;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetGenderBytes(ByteString value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000008));
						gender_ = value;
						OnChanged();
						return this;
					}

					private object animacy_ = string.Empty;

					/// <summary><code>optional string animacy = 5;</code></summary>
					public bool HasAnimacy()
					{
						return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
					}

					/// <summary><code>optional string animacy = 5;</code></summary>
					public string GetAnimacy()
					{
						object @ref = animacy_;
						if (!(@ref is string))
						{
							ByteString bs = (ByteString)@ref;
							string s = bs.ToStringUtf8();
							if (bs.IsValidUtf8())
							{
								animacy_ = s;
							}
							return s;
						}
						else
						{
							return (string)@ref;
						}
					}

					/// <summary><code>optional string animacy = 5;</code></summary>
					public ByteString GetAnimacyBytes()
					{
						object @ref = animacy_;
						if (@ref is string)
						{
							ByteString b = ByteString.CopyFromUtf8((string)@ref);
							animacy_ = b;
							return b;
						}
						else
						{
							return (ByteString)@ref;
						}
					}

					/// <summary><code>optional string animacy = 5;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetAnimacy(string value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000010));
						animacy_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional string animacy = 5;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearAnimacy()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
						animacy_ = GetDefaultInstance().GetAnimacy();
						OnChanged();
						return this;
					}

					/// <summary><code>optional string animacy = 5;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetAnimacyBytes(ByteString value)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						bitField0_ |= unchecked((int)(0x00000010));
						animacy_ = value;
						OnChanged();
						return this;
					}

					private int beginIndex_;

					/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
					public bool HasBeginIndex()
					{
						return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
					}

					/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
					public int GetBeginIndex()
					{
						return beginIndex_;
					}

					/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetBeginIndex(int value)
					{
						bitField0_ |= unchecked((int)(0x00000020));
						beginIndex_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional uint32 beginIndex = 6;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearBeginIndex()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						beginIndex_ = 0;
						OnChanged();
						return this;
					}

					private int endIndex_;

					/// <summary><code>optional uint32 endIndex = 7;</code></summary>
					public bool HasEndIndex()
					{
						return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
					}

					/// <summary><code>optional uint32 endIndex = 7;</code></summary>
					public int GetEndIndex()
					{
						return endIndex_;
					}

					/// <summary><code>optional uint32 endIndex = 7;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetEndIndex(int value)
					{
						bitField0_ |= unchecked((int)(0x00000040));
						endIndex_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional uint32 endIndex = 7;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearEndIndex()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						endIndex_ = 0;
						OnChanged();
						return this;
					}

					private int headIndex_;

					/// <summary><code>optional uint32 headIndex = 9;</code></summary>
					public bool HasHeadIndex()
					{
						return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
					}

					/// <summary><code>optional uint32 headIndex = 9;</code></summary>
					public int GetHeadIndex()
					{
						return headIndex_;
					}

					/// <summary><code>optional uint32 headIndex = 9;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetHeadIndex(int value)
					{
						bitField0_ |= unchecked((int)(0x00000080));
						headIndex_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional uint32 headIndex = 9;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearHeadIndex()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
						headIndex_ = 0;
						OnChanged();
						return this;
					}

					private int sentenceIndex_;

					/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
					public bool HasSentenceIndex()
					{
						return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
					}

					/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
					public int GetSentenceIndex()
					{
						return sentenceIndex_;
					}

					/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetSentenceIndex(int value)
					{
						bitField0_ |= unchecked((int)(0x00000100));
						sentenceIndex_ = value;
						OnChanged();
						return this;
					}

					/// <summary><code>optional uint32 sentenceIndex = 10;</code></summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearSentenceIndex()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
						sentenceIndex_ = 0;
						OnChanged();
						return this;
					}

					private int position_;

					/// <summary>
					/// <pre>
					/// the second element of position
					/// </pre>
					/// <code>optional uint32 position = 11;</code>
					/// </summary>
					public bool HasPosition()
					{
						return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
					}

					/// <summary>
					/// <pre>
					/// the second element of position
					/// </pre>
					/// <code>optional uint32 position = 11;</code>
					/// </summary>
					public int GetPosition()
					{
						return position_;
					}

					/// <summary>
					/// <pre>
					/// the second element of position
					/// </pre>
					/// <code>optional uint32 position = 11;</code>
					/// </summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder SetPosition(int value)
					{
						bitField0_ |= unchecked((int)(0x00000200));
						position_ = value;
						OnChanged();
						return this;
					}

					/// <summary>
					/// <pre>
					/// the second element of position
					/// </pre>
					/// <code>optional uint32 position = 11;</code>
					/// </summary>
					public CoreNLPProtos.CorefChain.CorefMention.Builder ClearPosition()
					{
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
						position_ = 0;
						OnChanged();
						return this;
					}

					public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
					{
						return base.SetUnknownFields(unknownFields);
					}

					public sealed override CoreNLPProtos.CorefChain.CorefMention.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
					{
						return base.MergeUnknownFields(unknownFields);
					}
					// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
				}

				private static readonly CoreNLPProtos.CorefChain.CorefMention DefaultInstance;

				static CorefMention()
				{
					// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
					DefaultInstance = new CoreNLPProtos.CorefChain.CorefMention();
				}

				public static CoreNLPProtos.CorefChain.CorefMention GetDefaultInstance()
				{
					return DefaultInstance;
				}

				private sealed class _AbstractParser_34856 : AbstractParser<CoreNLPProtos.CorefChain.CorefMention>
				{
					public _AbstractParser_34856()
					{
					}

					/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
					public override CoreNLPProtos.CorefChain.CorefMention ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
					{
						return new CoreNLPProtos.CorefChain.CorefMention(input, extensionRegistry);
					}
				}

				[Obsolete]
				public static readonly IParser<CoreNLPProtos.CorefChain.CorefMention> Parser = new _AbstractParser_34856();

				public static IParser<CoreNLPProtos.CorefChain.CorefMention> Parser()
				{
					return Parser;
				}

				public override IParser<IMessageLite> GetParserForType()
				{
					return Parser;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return DefaultInstance;
				}
			}

			private int bitField0_;

			public const int ChainidFieldNumber = 1;

			private int chainID_;

			/// <summary><code>required int32 chainID = 1;</code></summary>
			public bool HasChainID()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>required int32 chainID = 1;</code></summary>
			public int GetChainID()
			{
				return chainID_;
			}

			public const int MentionFieldNumber = 2;

			private IList<CoreNLPProtos.CorefChain.CorefMention> mention_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			public IList<CoreNLPProtos.CorefChain.CorefMention> GetMentionList()
			{
				return mention_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			public IList<CoreNLPProtos.CorefChain.ICorefMentionOrBuilder> GetMentionOrBuilderList()
			{
				return mention_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			public int GetMentionCount()
			{
				return mention_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			public CoreNLPProtos.CorefChain.CorefMention GetMention(int index)
			{
				return mention_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
			public CoreNLPProtos.CorefChain.ICorefMentionOrBuilder GetMentionOrBuilder(int index)
			{
				return mention_[index];
			}

			public const int RepresentativeFieldNumber = 3;

			private int representative_;

			/// <summary><code>required uint32 representative = 3;</code></summary>
			public bool HasRepresentative()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>required uint32 representative = 3;</code></summary>
			public int GetRepresentative()
			{
				return representative_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasChainID())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasRepresentative())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteInt32(1, chainID_);
				}
				for (int i = 0; i < mention_.Count; i++)
				{
					output.WriteMessage(2, mention_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(3, representative_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeInt32Size(1, chainID_);
				}
				for (int i = 0; i < mention_.Count; i++)
				{
					size += CodedOutputStream.ComputeMessageSize(2, mention_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, representative_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.CorefChain))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.CorefChain other = (CoreNLPProtos.CorefChain)obj;
				bool result = true;
				result = result && (HasChainID() == other.HasChainID());
				if (HasChainID())
				{
					result = result && (GetChainID() == other.GetChainID());
				}
				result = result && GetMentionList().Equals(other.GetMentionList());
				result = result && (HasRepresentative() == other.HasRepresentative());
				if (HasRepresentative())
				{
					result = result && (GetRepresentative() == other.GetRepresentative());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasChainID())
				{
					hash = (37 * hash) + ChainidFieldNumber;
					hash = (53 * hash) + GetChainID();
				}
				if (GetMentionCount() > 0)
				{
					hash = (37 * hash) + MentionFieldNumber;
					hash = (53 * hash) + GetMentionList().GetHashCode();
				}
				if (HasRepresentative())
				{
					hash = (37 * hash) + RepresentativeFieldNumber;
					hash = (53 * hash) + GetRepresentative();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.CorefChain ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.CorefChain ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.CorefChain ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.CorefChain.Builder NewBuilder()
			{
				return ((CoreNLPProtos.CorefChain.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.CorefChain.Builder NewBuilder(CoreNLPProtos.CorefChain prototype)
			{
				return ((CoreNLPProtos.CorefChain.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.CorefChain.Builder() : new CoreNLPProtos.CorefChain.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.CorefChain.Builder builder = new CoreNLPProtos.CorefChain.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A coreference chain.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A coreference chain.
			/// These fields are not *really* optional. CoreNLP will crash without them.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.CorefChain</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.CorefChain.Builder>, CoreNLPProtos.ICorefChainOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.CorefChain)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.CorefChain), typeof(CoreNLPProtos.CorefChain.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.CorefChain.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetMentionFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					chainID_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					if (mentionBuilder_ == null)
					{
						mention_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					else
					{
						mentionBuilder_.Clear();
					}
					representative_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_CorefChain_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.CorefChain.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.CorefChain result = ((CoreNLPProtos.CorefChain)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.CorefChain result = new CoreNLPProtos.CorefChain(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.chainID_ = chainID_;
					if (mentionBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							mention_ = Java.Util.Collections.UnmodifiableList(mention_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						result.mention_ = mention_;
					}
					else
					{
						result.mention_ = mentionBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.representative_ = representative_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.CorefChain.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.CorefChain.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.CorefChain.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.CorefChain.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.CorefChain.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.CorefChain.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.CorefChain.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.CorefChain.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.CorefChain)
					{
						return MergeFrom((CoreNLPProtos.CorefChain)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.CorefChain.Builder MergeFrom(CoreNLPProtos.CorefChain other)
				{
					if (other == CoreNLPProtos.CorefChain.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasChainID())
					{
						SetChainID(other.GetChainID());
					}
					if (mentionBuilder_ == null)
					{
						if (!other.mention_.IsEmpty())
						{
							if (mention_.IsEmpty())
							{
								mention_ = other.mention_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
							}
							else
							{
								EnsureMentionIsMutable();
								Sharpen.Collections.AddAll(mention_, other.mention_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.mention_.IsEmpty())
						{
							if (mentionBuilder_.IsEmpty())
							{
								mentionBuilder_.Dispose();
								mentionBuilder_ = null;
								mention_ = other.mention_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
								mentionBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetMentionFieldBuilder() : null;
							}
							else
							{
								mentionBuilder_.AddAllMessages(other.mention_);
							}
						}
					}
					if (other.HasRepresentative())
					{
						SetRepresentative(other.GetRepresentative());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasChainID())
					{
						return false;
					}
					if (!HasRepresentative())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.CorefChain parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.CorefChain)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int chainID_;

				/// <summary><code>required int32 chainID = 1;</code></summary>
				public bool HasChainID()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required int32 chainID = 1;</code></summary>
				public int GetChainID()
				{
					return chainID_;
				}

				/// <summary><code>required int32 chainID = 1;</code></summary>
				public CoreNLPProtos.CorefChain.Builder SetChainID(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					chainID_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required int32 chainID = 1;</code></summary>
				public CoreNLPProtos.CorefChain.Builder ClearChainID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					chainID_ = 0;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.CorefChain.CorefMention> mention_ = Java.Util.Collections.EmptyList();

				private void EnsureMentionIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						mention_ = new List<CoreNLPProtos.CorefChain.CorefMention>(mention_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.CorefChain.CorefMention, CoreNLPProtos.CorefChain.CorefMention.Builder, CoreNLPProtos.CorefChain.ICorefMentionOrBuilder> mentionBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public IList<CoreNLPProtos.CorefChain.CorefMention> GetMentionList()
				{
					if (mentionBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(mention_);
					}
					else
					{
						return mentionBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public int GetMentionCount()
				{
					if (mentionBuilder_ == null)
					{
						return mention_.Count;
					}
					else
					{
						return mentionBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.CorefMention GetMention(int index)
				{
					if (mentionBuilder_ == null)
					{
						return mention_[index];
					}
					else
					{
						return mentionBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder SetMention(int index, CoreNLPProtos.CorefChain.CorefMention value)
				{
					if (mentionBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionIsMutable();
						mention_.Set(index, value);
						OnChanged();
					}
					else
					{
						mentionBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder SetMention(int index, CoreNLPProtos.CorefChain.CorefMention.Builder builderForValue)
				{
					if (mentionBuilder_ == null)
					{
						EnsureMentionIsMutable();
						mention_.Set(index, ((CoreNLPProtos.CorefChain.CorefMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionBuilder_.SetMessage(index, ((CoreNLPProtos.CorefChain.CorefMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder AddMention(CoreNLPProtos.CorefChain.CorefMention value)
				{
					if (mentionBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionIsMutable();
						mention_.Add(value);
						OnChanged();
					}
					else
					{
						mentionBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder AddMention(int index, CoreNLPProtos.CorefChain.CorefMention value)
				{
					if (mentionBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureMentionIsMutable();
						mention_.Add(index, value);
						OnChanged();
					}
					else
					{
						mentionBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder AddMention(CoreNLPProtos.CorefChain.CorefMention.Builder builderForValue)
				{
					if (mentionBuilder_ == null)
					{
						EnsureMentionIsMutable();
						mention_.Add(((CoreNLPProtos.CorefChain.CorefMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionBuilder_.AddMessage(((CoreNLPProtos.CorefChain.CorefMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder AddMention(int index, CoreNLPProtos.CorefChain.CorefMention.Builder builderForValue)
				{
					if (mentionBuilder_ == null)
					{
						EnsureMentionIsMutable();
						mention_.Add(index, ((CoreNLPProtos.CorefChain.CorefMention)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						mentionBuilder_.AddMessage(index, ((CoreNLPProtos.CorefChain.CorefMention)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder AddAllMention<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.CorefChain.CorefMention
				{
					if (mentionBuilder_ == null)
					{
						EnsureMentionIsMutable();
						AbstractMessageLite.Builder.AddAll(values, mention_);
						OnChanged();
					}
					else
					{
						mentionBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder ClearMention()
				{
					if (mentionBuilder_ == null)
					{
						mention_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						OnChanged();
					}
					else
					{
						mentionBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.Builder RemoveMention(int index)
				{
					if (mentionBuilder_ == null)
					{
						EnsureMentionIsMutable();
						mention_.Remove(index);
						OnChanged();
					}
					else
					{
						mentionBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.CorefMention.Builder GetMentionBuilder(int index)
				{
					return GetMentionFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.ICorefMentionOrBuilder GetMentionOrBuilder(int index)
				{
					if (mentionBuilder_ == null)
					{
						return mention_[index];
					}
					else
					{
						return mentionBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public IList<CoreNLPProtos.CorefChain.ICorefMentionOrBuilder> GetMentionOrBuilderList()
				{
					if (mentionBuilder_ != null)
					{
						return mentionBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(mention_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.CorefMention.Builder AddMentionBuilder()
				{
					return GetMentionFieldBuilder().AddBuilder(CoreNLPProtos.CorefChain.CorefMention.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public CoreNLPProtos.CorefChain.CorefMention.Builder AddMentionBuilder(int index)
				{
					return GetMentionFieldBuilder().AddBuilder(index, CoreNLPProtos.CorefChain.CorefMention.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;</code></summary>
				public IList<CoreNLPProtos.CorefChain.CorefMention.Builder> GetMentionBuilderList()
				{
					return GetMentionFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.CorefChain.CorefMention, CoreNLPProtos.CorefChain.CorefMention.Builder, CoreNLPProtos.CorefChain.ICorefMentionOrBuilder> GetMentionFieldBuilder()
				{
					if (mentionBuilder_ == null)
					{
						mentionBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.CorefChain.CorefMention, CoreNLPProtos.CorefChain.CorefMention.Builder, CoreNLPProtos.CorefChain.ICorefMentionOrBuilder>(mention_, ((bitField0_ & unchecked((int)(0x00000002))) == unchecked(
							(int)(0x00000002))), GetParentForChildren(), IsClean());
						mention_ = null;
					}
					return mentionBuilder_;
				}

				private int representative_;

				/// <summary><code>required uint32 representative = 3;</code></summary>
				public bool HasRepresentative()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>required uint32 representative = 3;</code></summary>
				public int GetRepresentative()
				{
					return representative_;
				}

				/// <summary><code>required uint32 representative = 3;</code></summary>
				public CoreNLPProtos.CorefChain.Builder SetRepresentative(int value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					representative_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 representative = 3;</code></summary>
				public CoreNLPProtos.CorefChain.Builder ClearRepresentative()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					representative_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.CorefChain.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.CorefChain)
			}

			private static readonly CoreNLPProtos.CorefChain DefaultInstance;

			static CorefChain()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.CorefChain)
				DefaultInstance = new CoreNLPProtos.CorefChain();
			}

			public static CoreNLPProtos.CorefChain GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_35658 : AbstractParser<CoreNLPProtos.CorefChain>
			{
				public _AbstractParser_35658()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.CorefChain ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.CorefChain(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.CorefChain> Parser = new _AbstractParser_35658();

			public static IParser<CoreNLPProtos.CorefChain> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IMentionOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Mention)
			/// <summary><code>optional int32 mentionID = 1;</code></summary>
			bool HasMentionID();

			/// <summary><code>optional int32 mentionID = 1;</code></summary>
			int GetMentionID();

			/// <summary><code>optional string mentionType = 2;</code></summary>
			bool HasMentionType();

			/// <summary><code>optional string mentionType = 2;</code></summary>
			string GetMentionType();

			/// <summary><code>optional string mentionType = 2;</code></summary>
			ByteString GetMentionTypeBytes();

			/// <summary><code>optional string number = 3;</code></summary>
			bool HasNumber();

			/// <summary><code>optional string number = 3;</code></summary>
			string GetNumber();

			/// <summary><code>optional string number = 3;</code></summary>
			ByteString GetNumberBytes();

			/// <summary><code>optional string gender = 4;</code></summary>
			bool HasGender();

			/// <summary><code>optional string gender = 4;</code></summary>
			string GetGender();

			/// <summary><code>optional string gender = 4;</code></summary>
			ByteString GetGenderBytes();

			/// <summary><code>optional string animacy = 5;</code></summary>
			bool HasAnimacy();

			/// <summary><code>optional string animacy = 5;</code></summary>
			string GetAnimacy();

			/// <summary><code>optional string animacy = 5;</code></summary>
			ByteString GetAnimacyBytes();

			/// <summary><code>optional string person = 6;</code></summary>
			bool HasPerson();

			/// <summary><code>optional string person = 6;</code></summary>
			string GetPerson();

			/// <summary><code>optional string person = 6;</code></summary>
			ByteString GetPersonBytes();

			/// <summary><code>optional uint32 startIndex = 7;</code></summary>
			bool HasStartIndex();

			/// <summary><code>optional uint32 startIndex = 7;</code></summary>
			int GetStartIndex();

			/// <summary><code>optional uint32 endIndex = 9;</code></summary>
			bool HasEndIndex();

			/// <summary><code>optional uint32 endIndex = 9;</code></summary>
			int GetEndIndex();

			/// <summary><code>optional uint32 headIndex = 10;</code></summary>
			bool HasHeadIndex();

			/// <summary><code>optional uint32 headIndex = 10;</code></summary>
			int GetHeadIndex();

			/// <summary><code>optional string headString = 11;</code></summary>
			bool HasHeadString();

			/// <summary><code>optional string headString = 11;</code></summary>
			string GetHeadString();

			/// <summary><code>optional string headString = 11;</code></summary>
			ByteString GetHeadStringBytes();

			/// <summary><code>optional string nerString = 12;</code></summary>
			bool HasNerString();

			/// <summary><code>optional string nerString = 12;</code></summary>
			string GetNerString();

			/// <summary><code>optional string nerString = 12;</code></summary>
			ByteString GetNerStringBytes();

			/// <summary><code>optional uint32 originalRef = 13;</code></summary>
			bool HasOriginalRef();

			/// <summary><code>optional uint32 originalRef = 13;</code></summary>
			int GetOriginalRef();

			/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
			bool HasGoldCorefClusterID();

			/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
			int GetGoldCorefClusterID();

			/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
			bool HasCorefClusterID();

			/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
			int GetCorefClusterID();

			/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
			bool HasMentionNum();

			/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
			int GetMentionNum();

			/// <summary><code>optional uint32 sentNum = 17;</code></summary>
			bool HasSentNum();

			/// <summary><code>optional uint32 sentNum = 17;</code></summary>
			int GetSentNum();

			/// <summary><code>optional uint32 utter = 18;</code></summary>
			bool HasUtter();

			/// <summary><code>optional uint32 utter = 18;</code></summary>
			int GetUtter();

			/// <summary><code>optional uint32 paragraph = 19;</code></summary>
			bool HasParagraph();

			/// <summary><code>optional uint32 paragraph = 19;</code></summary>
			int GetParagraph();

			/// <summary><code>optional bool isSubject = 20;</code></summary>
			bool HasIsSubject();

			/// <summary><code>optional bool isSubject = 20;</code></summary>
			bool GetIsSubject();

			/// <summary><code>optional bool isDirectObject = 21;</code></summary>
			bool HasIsDirectObject();

			/// <summary><code>optional bool isDirectObject = 21;</code></summary>
			bool GetIsDirectObject();

			/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
			bool HasIsIndirectObject();

			/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
			bool GetIsIndirectObject();

			/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
			bool HasIsPrepositionObject();

			/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
			bool GetIsPrepositionObject();

			/// <summary><code>optional bool hasTwin = 24;</code></summary>
			bool HasHasTwin();

			/// <summary><code>optional bool hasTwin = 24;</code></summary>
			bool GetHasTwin();

			/// <summary><code>optional bool generic = 25;</code></summary>
			bool HasGeneric();

			/// <summary><code>optional bool generic = 25;</code></summary>
			bool GetGeneric();

			/// <summary><code>optional bool isSingleton = 26;</code></summary>
			bool HasIsSingleton();

			/// <summary><code>optional bool isSingleton = 26;</code></summary>
			bool GetIsSingleton();

			/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
			bool HasHasBasicDependency();

			/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
			bool GetHasBasicDependency();

			/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
			bool HasHasEnhancedDepenedncy();

			/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
			bool GetHasEnhancedDepenedncy();

			/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
			bool HasHasContextParseTree();

			/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
			bool GetHasContextParseTree();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
			bool HasHeadIndexedWord();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
			CoreNLPProtos.IndexedWord GetHeadIndexedWord();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
			CoreNLPProtos.IIndexedWordOrBuilder GetHeadIndexedWordOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
			bool HasDependingVerb();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
			CoreNLPProtos.IndexedWord GetDependingVerb();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
			CoreNLPProtos.IIndexedWordOrBuilder GetDependingVerbOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
			bool HasHeadWord();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
			CoreNLPProtos.IndexedWord GetHeadWord();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
			CoreNLPProtos.IIndexedWordOrBuilder GetHeadWordOrBuilder();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
			bool HasSpeakerInfo();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
			CoreNLPProtos.SpeakerInfo GetSpeakerInfo();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
			CoreNLPProtos.ISpeakerInfoOrBuilder GetSpeakerInfoOrBuilder();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			IList<CoreNLPProtos.IndexedWord> GetSentenceWordsList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			CoreNLPProtos.IndexedWord GetSentenceWords(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			int GetSentenceWordsCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			IList<CoreNLPProtos.IIndexedWordOrBuilder> GetSentenceWordsOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			CoreNLPProtos.IIndexedWordOrBuilder GetSentenceWordsOrBuilder(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			IList<CoreNLPProtos.IndexedWord> GetOriginalSpanList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			CoreNLPProtos.IndexedWord GetOriginalSpan(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			int GetOriginalSpanCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			IList<CoreNLPProtos.IIndexedWordOrBuilder> GetOriginalSpanOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			CoreNLPProtos.IIndexedWordOrBuilder GetOriginalSpanOrBuilder(int index);

			/// <summary><code>repeated string dependents = 52;</code></summary>
			IList<string> GetDependentsList();

			/// <summary><code>repeated string dependents = 52;</code></summary>
			int GetDependentsCount();

			/// <summary><code>repeated string dependents = 52;</code></summary>
			string GetDependents(int index);

			/// <summary><code>repeated string dependents = 52;</code></summary>
			ByteString GetDependentsBytes(int index);

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			IList<string> GetPreprocessedTermsList();

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			int GetPreprocessedTermsCount();

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			string GetPreprocessedTerms(int index);

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			ByteString GetPreprocessedTermsBytes(int index);

			/// <summary><code>repeated int32 appositions = 54;</code></summary>
			IList<int> GetAppositionsList();

			/// <summary><code>repeated int32 appositions = 54;</code></summary>
			int GetAppositionsCount();

			/// <summary><code>repeated int32 appositions = 54;</code></summary>
			int GetAppositions(int index);

			/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
			IList<int> GetPredicateNominativesList();

			/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
			int GetPredicateNominativesCount();

			/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
			int GetPredicateNominatives(int index);

			/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
			IList<int> GetRelativePronounsList();

			/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
			int GetRelativePronounsCount();

			/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
			int GetRelativePronouns(int index);

			/// <summary><code>repeated int32 listMembers = 57;</code></summary>
			IList<int> GetListMembersList();

			/// <summary><code>repeated int32 listMembers = 57;</code></summary>
			int GetListMembersCount();

			/// <summary><code>repeated int32 listMembers = 57;</code></summary>
			int GetListMembers(int index);

			/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
			IList<int> GetBelongToListsList();

			/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
			int GetBelongToListsCount();

			/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
			int GetBelongToLists(int index);
		}

		/// <summary>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Mention</c>
		/// </summary>
		[System.Serializable]
		public sealed class Mention : GeneratedMessageV3, CoreNLPProtos.IMentionOrBuilder
		{
			private Mention(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Mention()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Mention)
				// Use Mention.newBuilder() to construct.
				mentionID_ = 0;
				mentionType_ = string.Empty;
				number_ = string.Empty;
				gender_ = string.Empty;
				animacy_ = string.Empty;
				person_ = string.Empty;
				startIndex_ = 0;
				endIndex_ = 0;
				headIndex_ = 0;
				headString_ = string.Empty;
				nerString_ = string.Empty;
				originalRef_ = 0;
				goldCorefClusterID_ = 0;
				corefClusterID_ = 0;
				mentionNum_ = 0;
				sentNum_ = 0;
				utter_ = 0;
				paragraph_ = 0;
				isSubject_ = false;
				isDirectObject_ = false;
				isIndirectObject_ = false;
				isPrepositionObject_ = false;
				hasTwin_ = false;
				generic_ = false;
				isSingleton_ = false;
				hasBasicDependency_ = false;
				hasEnhancedDepenedncy_ = false;
				hasContextParseTree_ = false;
				sentenceWords_ = Java.Util.Collections.EmptyList();
				originalSpan_ = Java.Util.Collections.EmptyList();
				dependents_ = LazyStringArrayList.Empty;
				preprocessedTerms_ = LazyStringArrayList.Empty;
				appositions_ = Java.Util.Collections.EmptyList();
				predicateNominatives_ = Java.Util.Collections.EmptyList();
				relativePronouns_ = Java.Util.Collections.EmptyList();
				listMembers_ = Java.Util.Collections.EmptyList();
				belongToLists_ = Java.Util.Collections.EmptyList();
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Mention(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				int mutable_bitField1_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								mentionID_ = input.ReadInt32();
								break;
							}

							case 18:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000002));
								mentionType_ = bs;
								break;
							}

							case 26:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000004));
								number_ = bs;
								break;
							}

							case 34:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000008));
								gender_ = bs;
								break;
							}

							case 42:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000010));
								animacy_ = bs;
								break;
							}

							case 50:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000020));
								person_ = bs;
								break;
							}

							case 56:
							{
								bitField0_ |= unchecked((int)(0x00000040));
								startIndex_ = input.ReadUInt32();
								break;
							}

							case 72:
							{
								bitField0_ |= unchecked((int)(0x00000080));
								endIndex_ = input.ReadUInt32();
								break;
							}

							case 80:
							{
								bitField0_ |= unchecked((int)(0x00000100));
								headIndex_ = input.ReadUInt32();
								break;
							}

							case 90:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000200));
								headString_ = bs;
								break;
							}

							case 98:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000400));
								nerString_ = bs;
								break;
							}

							case 104:
							{
								bitField0_ |= unchecked((int)(0x00000800));
								originalRef_ = input.ReadUInt32();
								break;
							}

							case 112:
							{
								bitField0_ |= unchecked((int)(0x00001000));
								goldCorefClusterID_ = input.ReadInt32();
								break;
							}

							case 120:
							{
								bitField0_ |= unchecked((int)(0x00002000));
								corefClusterID_ = input.ReadInt32();
								break;
							}

							case 128:
							{
								bitField0_ |= unchecked((int)(0x00004000));
								mentionNum_ = input.ReadUInt32();
								break;
							}

							case 136:
							{
								bitField0_ |= unchecked((int)(0x00008000));
								sentNum_ = input.ReadUInt32();
								break;
							}

							case 144:
							{
								bitField0_ |= unchecked((int)(0x00010000));
								utter_ = input.ReadUInt32();
								break;
							}

							case 152:
							{
								bitField0_ |= unchecked((int)(0x00020000));
								paragraph_ = input.ReadUInt32();
								break;
							}

							case 160:
							{
								bitField0_ |= unchecked((int)(0x00040000));
								isSubject_ = input.ReadBool();
								break;
							}

							case 168:
							{
								bitField0_ |= unchecked((int)(0x00080000));
								isDirectObject_ = input.ReadBool();
								break;
							}

							case 176:
							{
								bitField0_ |= unchecked((int)(0x00100000));
								isIndirectObject_ = input.ReadBool();
								break;
							}

							case 184:
							{
								bitField0_ |= unchecked((int)(0x00200000));
								isPrepositionObject_ = input.ReadBool();
								break;
							}

							case 192:
							{
								bitField0_ |= unchecked((int)(0x00400000));
								hasTwin_ = input.ReadBool();
								break;
							}

							case 200:
							{
								bitField0_ |= unchecked((int)(0x00800000));
								generic_ = input.ReadBool();
								break;
							}

							case 208:
							{
								bitField0_ |= unchecked((int)(0x01000000));
								isSingleton_ = input.ReadBool();
								break;
							}

							case 216:
							{
								bitField0_ |= unchecked((int)(0x02000000));
								hasBasicDependency_ = input.ReadBool();
								break;
							}

							case 224:
							{
								bitField0_ |= unchecked((int)(0x04000000));
								hasEnhancedDepenedncy_ = input.ReadBool();
								break;
							}

							case 232:
							{
								bitField0_ |= unchecked((int)(0x08000000));
								hasContextParseTree_ = input.ReadBool();
								break;
							}

							case 242:
							{
								CoreNLPProtos.IndexedWord.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
								{
									subBuilder = ((CoreNLPProtos.IndexedWord.Builder)headIndexedWord_.ToBuilder());
								}
								headIndexedWord_ = input.ReadMessage(CoreNLPProtos.IndexedWord.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(headIndexedWord_);
									headIndexedWord_ = ((CoreNLPProtos.IndexedWord)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x10000000));
								break;
							}

							case 250:
							{
								CoreNLPProtos.IndexedWord.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
								{
									subBuilder = ((CoreNLPProtos.IndexedWord.Builder)dependingVerb_.ToBuilder());
								}
								dependingVerb_ = input.ReadMessage(CoreNLPProtos.IndexedWord.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(dependingVerb_);
									dependingVerb_ = ((CoreNLPProtos.IndexedWord)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x20000000));
								break;
							}

							case 258:
							{
								CoreNLPProtos.IndexedWord.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
								{
									subBuilder = ((CoreNLPProtos.IndexedWord.Builder)headWord_.ToBuilder());
								}
								headWord_ = input.ReadMessage(CoreNLPProtos.IndexedWord.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(headWord_);
									headWord_ = ((CoreNLPProtos.IndexedWord)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x40000000));
								break;
							}

							case 266:
							{
								CoreNLPProtos.SpeakerInfo.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
								{
									subBuilder = ((CoreNLPProtos.SpeakerInfo.Builder)speakerInfo_.ToBuilder());
								}
								speakerInfo_ = input.ReadMessage(CoreNLPProtos.SpeakerInfo.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(speakerInfo_);
									speakerInfo_ = ((CoreNLPProtos.SpeakerInfo)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x80000000));
								break;
							}

							case 402:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									sentenceWords_ = new List<CoreNLPProtos.IndexedWord>();
									mutable_bitField1_ |= unchecked((int)(0x00000001));
								}
								sentenceWords_.Add(input.ReadMessage(CoreNLPProtos.IndexedWord.Parser, extensionRegistry));
								break;
							}

							case 410:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									originalSpan_ = new List<CoreNLPProtos.IndexedWord>();
									mutable_bitField1_ |= unchecked((int)(0x00000002));
								}
								originalSpan_.Add(input.ReadMessage(CoreNLPProtos.IndexedWord.Parser, extensionRegistry));
								break;
							}

							case 418:
							{
								ByteString bs = input.ReadBytes();
								if (!((mutable_bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
								{
									dependents_ = new LazyStringArrayList();
									mutable_bitField1_ |= unchecked((int)(0x00000004));
								}
								dependents_.Add(bs);
								break;
							}

							case 426:
							{
								ByteString bs = input.ReadBytes();
								if (!((mutable_bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
								{
									preprocessedTerms_ = new LazyStringArrayList();
									mutable_bitField1_ |= unchecked((int)(0x00000008));
								}
								preprocessedTerms_.Add(bs);
								break;
							}

							case 432:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
								{
									appositions_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000010));
								}
								appositions_.Add(input.ReadInt32());
								break;
							}

							case 434:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))) && input.GetBytesUntilLimit() > 0)
								{
									appositions_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000010));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									appositions_.Add(input.ReadInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 440:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
								{
									predicateNominatives_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000020));
								}
								predicateNominatives_.Add(input.ReadInt32());
								break;
							}

							case 442:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))) && input.GetBytesUntilLimit() > 0)
								{
									predicateNominatives_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000020));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									predicateNominatives_.Add(input.ReadInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 448:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
								{
									relativePronouns_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000040));
								}
								relativePronouns_.Add(input.ReadInt32());
								break;
							}

							case 450:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))) && input.GetBytesUntilLimit() > 0)
								{
									relativePronouns_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000040));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									relativePronouns_.Add(input.ReadInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 456:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
								{
									listMembers_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000080));
								}
								listMembers_.Add(input.ReadInt32());
								break;
							}

							case 458:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))) && input.GetBytesUntilLimit() > 0)
								{
									listMembers_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000080));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									listMembers_.Add(input.ReadInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 464:
							{
								if (!((mutable_bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
								{
									belongToLists_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000100));
								}
								belongToLists_.Add(input.ReadInt32());
								break;
							}

							case 466:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))) && input.GetBytesUntilLimit() > 0)
								{
									belongToLists_ = new List<int>();
									mutable_bitField1_ |= unchecked((int)(0x00000100));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									belongToLists_.Add(input.ReadInt32());
								}
								input.PopLimit(limit);
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						sentenceWords_ = Java.Util.Collections.UnmodifiableList(sentenceWords_);
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						originalSpan_ = Java.Util.Collections.UnmodifiableList(originalSpan_);
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						dependents_ = dependents_.GetUnmodifiableView();
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						preprocessedTerms_ = preprocessedTerms_.GetUnmodifiableView();
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						appositions_ = Java.Util.Collections.UnmodifiableList(appositions_);
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						predicateNominatives_ = Java.Util.Collections.UnmodifiableList(predicateNominatives_);
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						relativePronouns_ = Java.Util.Collections.UnmodifiableList(relativePronouns_);
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						listMembers_ = Java.Util.Collections.UnmodifiableList(listMembers_);
					}
					if (((mutable_bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						belongToLists_ = Java.Util.Collections.UnmodifiableList(belongToLists_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Mention_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Mention_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Mention), typeof(CoreNLPProtos.Mention.Builder));
			}

			private int bitField0_;

			public const int MentionidFieldNumber = 1;

			private int mentionID_;

			/// <summary><code>optional int32 mentionID = 1;</code></summary>
			public bool HasMentionID()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional int32 mentionID = 1;</code></summary>
			public int GetMentionID()
			{
				return mentionID_;
			}

			public const int MentiontypeFieldNumber = 2;

			private volatile object mentionType_;

			/// <summary><code>optional string mentionType = 2;</code></summary>
			public bool HasMentionType()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional string mentionType = 2;</code></summary>
			public string GetMentionType()
			{
				object @ref = mentionType_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						mentionType_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string mentionType = 2;</code></summary>
			public ByteString GetMentionTypeBytes()
			{
				object @ref = mentionType_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					mentionType_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int NumberFieldNumber = 3;

			private volatile object number_;

			/// <summary><code>optional string number = 3;</code></summary>
			public bool HasNumber()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional string number = 3;</code></summary>
			public string GetNumber()
			{
				object @ref = number_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						number_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string number = 3;</code></summary>
			public ByteString GetNumberBytes()
			{
				object @ref = number_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					number_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int GenderFieldNumber = 4;

			private volatile object gender_;

			/// <summary><code>optional string gender = 4;</code></summary>
			public bool HasGender()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional string gender = 4;</code></summary>
			public string GetGender()
			{
				object @ref = gender_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						gender_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string gender = 4;</code></summary>
			public ByteString GetGenderBytes()
			{
				object @ref = gender_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					gender_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int AnimacyFieldNumber = 5;

			private volatile object animacy_;

			/// <summary><code>optional string animacy = 5;</code></summary>
			public bool HasAnimacy()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional string animacy = 5;</code></summary>
			public string GetAnimacy()
			{
				object @ref = animacy_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						animacy_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string animacy = 5;</code></summary>
			public ByteString GetAnimacyBytes()
			{
				object @ref = animacy_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					animacy_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int PersonFieldNumber = 6;

			private volatile object person_;

			/// <summary><code>optional string person = 6;</code></summary>
			public bool HasPerson()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional string person = 6;</code></summary>
			public string GetPerson()
			{
				object @ref = person_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						person_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string person = 6;</code></summary>
			public ByteString GetPersonBytes()
			{
				object @ref = person_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					person_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int StartindexFieldNumber = 7;

			private int startIndex_;

			/// <summary><code>optional uint32 startIndex = 7;</code></summary>
			public bool HasStartIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>optional uint32 startIndex = 7;</code></summary>
			public int GetStartIndex()
			{
				return startIndex_;
			}

			public const int EndindexFieldNumber = 9;

			private int endIndex_;

			/// <summary><code>optional uint32 endIndex = 9;</code></summary>
			public bool HasEndIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary><code>optional uint32 endIndex = 9;</code></summary>
			public int GetEndIndex()
			{
				return endIndex_;
			}

			public const int HeadindexFieldNumber = 10;

			private int headIndex_;

			/// <summary><code>optional uint32 headIndex = 10;</code></summary>
			public bool HasHeadIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary><code>optional uint32 headIndex = 10;</code></summary>
			public int GetHeadIndex()
			{
				return headIndex_;
			}

			public const int HeadstringFieldNumber = 11;

			private volatile object headString_;

			/// <summary><code>optional string headString = 11;</code></summary>
			public bool HasHeadString()
			{
				return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
			}

			/// <summary><code>optional string headString = 11;</code></summary>
			public string GetHeadString()
			{
				object @ref = headString_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						headString_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string headString = 11;</code></summary>
			public ByteString GetHeadStringBytes()
			{
				object @ref = headString_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					headString_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int NerstringFieldNumber = 12;

			private volatile object nerString_;

			/// <summary><code>optional string nerString = 12;</code></summary>
			public bool HasNerString()
			{
				return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
			}

			/// <summary><code>optional string nerString = 12;</code></summary>
			public string GetNerString()
			{
				object @ref = nerString_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						nerString_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string nerString = 12;</code></summary>
			public ByteString GetNerStringBytes()
			{
				object @ref = nerString_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					nerString_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int OriginalrefFieldNumber = 13;

			private int originalRef_;

			/// <summary><code>optional uint32 originalRef = 13;</code></summary>
			public bool HasOriginalRef()
			{
				return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
			}

			/// <summary><code>optional uint32 originalRef = 13;</code></summary>
			public int GetOriginalRef()
			{
				return originalRef_;
			}

			public const int GoldcorefclusteridFieldNumber = 14;

			private int goldCorefClusterID_;

			/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
			public bool HasGoldCorefClusterID()
			{
				return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
			}

			/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
			public int GetGoldCorefClusterID()
			{
				return goldCorefClusterID_;
			}

			public const int CorefclusteridFieldNumber = 15;

			private int corefClusterID_;

			/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
			public bool HasCorefClusterID()
			{
				return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
			}

			/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
			public int GetCorefClusterID()
			{
				return corefClusterID_;
			}

			public const int MentionnumFieldNumber = 16;

			private int mentionNum_;

			/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
			public bool HasMentionNum()
			{
				return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
			}

			/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
			public int GetMentionNum()
			{
				return mentionNum_;
			}

			public const int SentnumFieldNumber = 17;

			private int sentNum_;

			/// <summary><code>optional uint32 sentNum = 17;</code></summary>
			public bool HasSentNum()
			{
				return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
			}

			/// <summary><code>optional uint32 sentNum = 17;</code></summary>
			public int GetSentNum()
			{
				return sentNum_;
			}

			public const int UtterFieldNumber = 18;

			private int utter_;

			/// <summary><code>optional uint32 utter = 18;</code></summary>
			public bool HasUtter()
			{
				return ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
			}

			/// <summary><code>optional uint32 utter = 18;</code></summary>
			public int GetUtter()
			{
				return utter_;
			}

			public const int ParagraphFieldNumber = 19;

			private int paragraph_;

			/// <summary><code>optional uint32 paragraph = 19;</code></summary>
			public bool HasParagraph()
			{
				return ((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
			}

			/// <summary><code>optional uint32 paragraph = 19;</code></summary>
			public int GetParagraph()
			{
				return paragraph_;
			}

			public const int IssubjectFieldNumber = 20;

			private bool isSubject_;

			/// <summary><code>optional bool isSubject = 20;</code></summary>
			public bool HasIsSubject()
			{
				return ((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000)));
			}

			/// <summary><code>optional bool isSubject = 20;</code></summary>
			public bool GetIsSubject()
			{
				return isSubject_;
			}

			public const int IsdirectobjectFieldNumber = 21;

			private bool isDirectObject_;

			/// <summary><code>optional bool isDirectObject = 21;</code></summary>
			public bool HasIsDirectObject()
			{
				return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
			}

			/// <summary><code>optional bool isDirectObject = 21;</code></summary>
			public bool GetIsDirectObject()
			{
				return isDirectObject_;
			}

			public const int IsindirectobjectFieldNumber = 22;

			private bool isIndirectObject_;

			/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
			public bool HasIsIndirectObject()
			{
				return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
			}

			/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
			public bool GetIsIndirectObject()
			{
				return isIndirectObject_;
			}

			public const int IsprepositionobjectFieldNumber = 23;

			private bool isPrepositionObject_;

			/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
			public bool HasIsPrepositionObject()
			{
				return ((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000)));
			}

			/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
			public bool GetIsPrepositionObject()
			{
				return isPrepositionObject_;
			}

			public const int HastwinFieldNumber = 24;

			private bool hasTwin_;

			/// <summary><code>optional bool hasTwin = 24;</code></summary>
			public bool HasHasTwin()
			{
				return ((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000)));
			}

			/// <summary><code>optional bool hasTwin = 24;</code></summary>
			public bool GetHasTwin()
			{
				return hasTwin_;
			}

			public const int GenericFieldNumber = 25;

			private bool generic_;

			/// <summary><code>optional bool generic = 25;</code></summary>
			public bool HasGeneric()
			{
				return ((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000)));
			}

			/// <summary><code>optional bool generic = 25;</code></summary>
			public bool GetGeneric()
			{
				return generic_;
			}

			public const int IssingletonFieldNumber = 26;

			private bool isSingleton_;

			/// <summary><code>optional bool isSingleton = 26;</code></summary>
			public bool HasIsSingleton()
			{
				return ((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000)));
			}

			/// <summary><code>optional bool isSingleton = 26;</code></summary>
			public bool GetIsSingleton()
			{
				return isSingleton_;
			}

			public const int HasbasicdependencyFieldNumber = 27;

			private bool hasBasicDependency_;

			/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
			public bool HasHasBasicDependency()
			{
				return ((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000)));
			}

			/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
			public bool GetHasBasicDependency()
			{
				return hasBasicDependency_;
			}

			public const int HasenhanceddepenedncyFieldNumber = 28;

			private bool hasEnhancedDepenedncy_;

			/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
			public bool HasHasEnhancedDepenedncy()
			{
				return ((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000)));
			}

			/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
			public bool GetHasEnhancedDepenedncy()
			{
				return hasEnhancedDepenedncy_;
			}

			public const int HascontextparsetreeFieldNumber = 29;

			private bool hasContextParseTree_;

			/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
			public bool HasHasContextParseTree()
			{
				return ((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000)));
			}

			/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
			public bool GetHasContextParseTree()
			{
				return hasContextParseTree_;
			}

			public const int HeadindexedwordFieldNumber = 30;

			private CoreNLPProtos.IndexedWord headIndexedWord_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
			public bool HasHeadIndexedWord()
			{
				return ((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
			public CoreNLPProtos.IndexedWord GetHeadIndexedWord()
			{
				return headIndexedWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headIndexedWord_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
			public CoreNLPProtos.IIndexedWordOrBuilder GetHeadIndexedWordOrBuilder()
			{
				return headIndexedWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headIndexedWord_;
			}

			public const int DependingverbFieldNumber = 31;

			private CoreNLPProtos.IndexedWord dependingVerb_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
			public bool HasDependingVerb()
			{
				return ((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
			public CoreNLPProtos.IndexedWord GetDependingVerb()
			{
				return dependingVerb_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : dependingVerb_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
			public CoreNLPProtos.IIndexedWordOrBuilder GetDependingVerbOrBuilder()
			{
				return dependingVerb_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : dependingVerb_;
			}

			public const int HeadwordFieldNumber = 32;

			private CoreNLPProtos.IndexedWord headWord_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
			public bool HasHeadWord()
			{
				return ((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
			public CoreNLPProtos.IndexedWord GetHeadWord()
			{
				return headWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headWord_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
			public CoreNLPProtos.IIndexedWordOrBuilder GetHeadWordOrBuilder()
			{
				return headWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headWord_;
			}

			public const int SpeakerinfoFieldNumber = 33;

			private CoreNLPProtos.SpeakerInfo speakerInfo_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
			public bool HasSpeakerInfo()
			{
				return ((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
			public CoreNLPProtos.SpeakerInfo GetSpeakerInfo()
			{
				return speakerInfo_ == null ? CoreNLPProtos.SpeakerInfo.GetDefaultInstance() : speakerInfo_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
			public CoreNLPProtos.ISpeakerInfoOrBuilder GetSpeakerInfoOrBuilder()
			{
				return speakerInfo_ == null ? CoreNLPProtos.SpeakerInfo.GetDefaultInstance() : speakerInfo_;
			}

			public const int SentencewordsFieldNumber = 50;

			private IList<CoreNLPProtos.IndexedWord> sentenceWords_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			public IList<CoreNLPProtos.IndexedWord> GetSentenceWordsList()
			{
				return sentenceWords_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			public IList<CoreNLPProtos.IIndexedWordOrBuilder> GetSentenceWordsOrBuilderList()
			{
				return sentenceWords_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			public int GetSentenceWordsCount()
			{
				return sentenceWords_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			public CoreNLPProtos.IndexedWord GetSentenceWords(int index)
			{
				return sentenceWords_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
			public CoreNLPProtos.IIndexedWordOrBuilder GetSentenceWordsOrBuilder(int index)
			{
				return sentenceWords_[index];
			}

			public const int OriginalspanFieldNumber = 51;

			private IList<CoreNLPProtos.IndexedWord> originalSpan_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			public IList<CoreNLPProtos.IndexedWord> GetOriginalSpanList()
			{
				return originalSpan_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			public IList<CoreNLPProtos.IIndexedWordOrBuilder> GetOriginalSpanOrBuilderList()
			{
				return originalSpan_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			public int GetOriginalSpanCount()
			{
				return originalSpan_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			public CoreNLPProtos.IndexedWord GetOriginalSpan(int index)
			{
				return originalSpan_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
			public CoreNLPProtos.IIndexedWordOrBuilder GetOriginalSpanOrBuilder(int index)
			{
				return originalSpan_[index];
			}

			public const int DependentsFieldNumber = 52;

			private ILazyStringList dependents_;

			/// <summary><code>repeated string dependents = 52;</code></summary>
			public IProtocolStringList GetDependentsList()
			{
				return dependents_;
			}

			/// <summary><code>repeated string dependents = 52;</code></summary>
			public int GetDependentsCount()
			{
				return dependents_.Count;
			}

			/// <summary><code>repeated string dependents = 52;</code></summary>
			public string GetDependents(int index)
			{
				return dependents_[index];
			}

			/// <summary><code>repeated string dependents = 52;</code></summary>
			public ByteString GetDependentsBytes(int index)
			{
				return dependents_.GetByteString(index);
			}

			public const int PreprocessedtermsFieldNumber = 53;

			private ILazyStringList preprocessedTerms_;

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			public IProtocolStringList GetPreprocessedTermsList()
			{
				return preprocessedTerms_;
			}

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			public int GetPreprocessedTermsCount()
			{
				return preprocessedTerms_.Count;
			}

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			public string GetPreprocessedTerms(int index)
			{
				return preprocessedTerms_[index];
			}

			/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
			public ByteString GetPreprocessedTermsBytes(int index)
			{
				return preprocessedTerms_.GetByteString(index);
			}

			public const int AppositionsFieldNumber = 54;

			private IList<int> appositions_;

			/// <summary><code>repeated int32 appositions = 54;</code></summary>
			public IList<int> GetAppositionsList()
			{
				return appositions_;
			}

			/// <summary><code>repeated int32 appositions = 54;</code></summary>
			public int GetAppositionsCount()
			{
				return appositions_.Count;
			}

			/// <summary><code>repeated int32 appositions = 54;</code></summary>
			public int GetAppositions(int index)
			{
				return appositions_[index];
			}

			public const int PredicatenominativesFieldNumber = 55;

			private IList<int> predicateNominatives_;

			/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
			public IList<int> GetPredicateNominativesList()
			{
				return predicateNominatives_;
			}

			/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
			public int GetPredicateNominativesCount()
			{
				return predicateNominatives_.Count;
			}

			/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
			public int GetPredicateNominatives(int index)
			{
				return predicateNominatives_[index];
			}

			public const int RelativepronounsFieldNumber = 56;

			private IList<int> relativePronouns_;

			/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
			public IList<int> GetRelativePronounsList()
			{
				return relativePronouns_;
			}

			/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
			public int GetRelativePronounsCount()
			{
				return relativePronouns_.Count;
			}

			/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
			public int GetRelativePronouns(int index)
			{
				return relativePronouns_[index];
			}

			public const int ListmembersFieldNumber = 57;

			private IList<int> listMembers_;

			/// <summary><code>repeated int32 listMembers = 57;</code></summary>
			public IList<int> GetListMembersList()
			{
				return listMembers_;
			}

			/// <summary><code>repeated int32 listMembers = 57;</code></summary>
			public int GetListMembersCount()
			{
				return listMembers_.Count;
			}

			/// <summary><code>repeated int32 listMembers = 57;</code></summary>
			public int GetListMembers(int index)
			{
				return listMembers_[index];
			}

			public const int BelongtolistsFieldNumber = 58;

			private IList<int> belongToLists_;

			/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
			public IList<int> GetBelongToListsList()
			{
				return belongToLists_;
			}

			/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
			public int GetBelongToListsCount()
			{
				return belongToLists_.Count;
			}

			/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
			public int GetBelongToLists(int index)
			{
				return belongToLists_[index];
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteInt32(1, mentionID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					GeneratedMessageV3.WriteString(output, 2, mentionType_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 3, number_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					GeneratedMessageV3.WriteString(output, 4, gender_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					GeneratedMessageV3.WriteString(output, 5, animacy_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					GeneratedMessageV3.WriteString(output, 6, person_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteUInt32(7, startIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					output.WriteUInt32(9, endIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					output.WriteUInt32(10, headIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					GeneratedMessageV3.WriteString(output, 11, headString_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					GeneratedMessageV3.WriteString(output, 12, nerString_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					output.WriteUInt32(13, originalRef_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					output.WriteInt32(14, goldCorefClusterID_);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					output.WriteInt32(15, corefClusterID_);
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					output.WriteUInt32(16, mentionNum_);
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					output.WriteUInt32(17, sentNum_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					output.WriteUInt32(18, utter_);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					output.WriteUInt32(19, paragraph_);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					output.WriteBool(20, isSubject_);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					output.WriteBool(21, isDirectObject_);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					output.WriteBool(22, isIndirectObject_);
				}
				if (((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
				{
					output.WriteBool(23, isPrepositionObject_);
				}
				if (((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
				{
					output.WriteBool(24, hasTwin_);
				}
				if (((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
				{
					output.WriteBool(25, generic_);
				}
				if (((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
				{
					output.WriteBool(26, isSingleton_);
				}
				if (((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
				{
					output.WriteBool(27, hasBasicDependency_);
				}
				if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
				{
					output.WriteBool(28, hasEnhancedDepenedncy_);
				}
				if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
				{
					output.WriteBool(29, hasContextParseTree_);
				}
				if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
				{
					output.WriteMessage(30, GetHeadIndexedWord());
				}
				if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
				{
					output.WriteMessage(31, GetDependingVerb());
				}
				if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
				{
					output.WriteMessage(32, GetHeadWord());
				}
				if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
				{
					output.WriteMessage(33, GetSpeakerInfo());
				}
				for (int i = 0; i < sentenceWords_.Count; i++)
				{
					output.WriteMessage(50, sentenceWords_[i]);
				}
				for (int i_1 = 0; i_1 < originalSpan_.Count; i_1++)
				{
					output.WriteMessage(51, originalSpan_[i_1]);
				}
				for (int i_2 = 0; i_2 < dependents_.Count; i_2++)
				{
					GeneratedMessageV3.WriteString(output, 52, dependents_.GetRaw(i_2));
				}
				for (int i_3 = 0; i_3 < preprocessedTerms_.Count; i_3++)
				{
					GeneratedMessageV3.WriteString(output, 53, preprocessedTerms_.GetRaw(i_3));
				}
				for (int i_4 = 0; i_4 < appositions_.Count; i_4++)
				{
					output.WriteInt32(54, appositions_[i_4]);
				}
				for (int i_5 = 0; i_5 < predicateNominatives_.Count; i_5++)
				{
					output.WriteInt32(55, predicateNominatives_[i_5]);
				}
				for (int i_6 = 0; i_6 < relativePronouns_.Count; i_6++)
				{
					output.WriteInt32(56, relativePronouns_[i_6]);
				}
				for (int i_7 = 0; i_7 < listMembers_.Count; i_7++)
				{
					output.WriteInt32(57, listMembers_[i_7]);
				}
				for (int i_8 = 0; i_8 < belongToLists_.Count; i_8++)
				{
					output.WriteInt32(58, belongToLists_[i_8]);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeInt32Size(1, mentionID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += GeneratedMessageV3.ComputeStringSize(2, mentionType_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(3, number_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += GeneratedMessageV3.ComputeStringSize(4, gender_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += GeneratedMessageV3.ComputeStringSize(5, animacy_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += GeneratedMessageV3.ComputeStringSize(6, person_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeUInt32Size(7, startIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += CodedOutputStream.ComputeUInt32Size(9, endIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += CodedOutputStream.ComputeUInt32Size(10, headIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					size += GeneratedMessageV3.ComputeStringSize(11, headString_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					size += GeneratedMessageV3.ComputeStringSize(12, nerString_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					size += CodedOutputStream.ComputeUInt32Size(13, originalRef_);
				}
				if (((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
				{
					size += CodedOutputStream.ComputeInt32Size(14, goldCorefClusterID_);
				}
				if (((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
				{
					size += CodedOutputStream.ComputeInt32Size(15, corefClusterID_);
				}
				if (((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(16, mentionNum_);
				}
				if (((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(17, sentNum_);
				}
				if (((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(18, utter_);
				}
				if (((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
				{
					size += CodedOutputStream.ComputeUInt32Size(19, paragraph_);
				}
				if (((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
				{
					size += CodedOutputStream.ComputeBoolSize(20, isSubject_);
				}
				if (((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
				{
					size += CodedOutputStream.ComputeBoolSize(21, isDirectObject_);
				}
				if (((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
				{
					size += CodedOutputStream.ComputeBoolSize(22, isIndirectObject_);
				}
				if (((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
				{
					size += CodedOutputStream.ComputeBoolSize(23, isPrepositionObject_);
				}
				if (((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
				{
					size += CodedOutputStream.ComputeBoolSize(24, hasTwin_);
				}
				if (((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
				{
					size += CodedOutputStream.ComputeBoolSize(25, generic_);
				}
				if (((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(26, isSingleton_);
				}
				if (((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(27, hasBasicDependency_);
				}
				if (((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(28, hasEnhancedDepenedncy_);
				}
				if (((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
				{
					size += CodedOutputStream.ComputeBoolSize(29, hasContextParseTree_);
				}
				if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(30, GetHeadIndexedWord());
				}
				if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(31, GetDependingVerb());
				}
				if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(32, GetHeadWord());
				}
				if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
				{
					size += CodedOutputStream.ComputeMessageSize(33, GetSpeakerInfo());
				}
				for (int i = 0; i < sentenceWords_.Count; i++)
				{
					size += CodedOutputStream.ComputeMessageSize(50, sentenceWords_[i]);
				}
				for (int i_1 = 0; i_1 < originalSpan_.Count; i_1++)
				{
					size += CodedOutputStream.ComputeMessageSize(51, originalSpan_[i_1]);
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < dependents_.Count; i_2++)
					{
						dataSize += ComputeStringSizeNoTag(dependents_.GetRaw(i_2));
					}
					size += dataSize;
					size += 2 * GetDependentsList().Count;
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < preprocessedTerms_.Count; i_2++)
					{
						dataSize += ComputeStringSizeNoTag(preprocessedTerms_.GetRaw(i_2));
					}
					size += dataSize;
					size += 2 * GetPreprocessedTermsList().Count;
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < appositions_.Count; i_2++)
					{
						dataSize += CodedOutputStream.ComputeInt32SizeNoTag(appositions_[i_2]);
					}
					size += dataSize;
					size += 2 * GetAppositionsList().Count;
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < predicateNominatives_.Count; i_2++)
					{
						dataSize += CodedOutputStream.ComputeInt32SizeNoTag(predicateNominatives_[i_2]);
					}
					size += dataSize;
					size += 2 * GetPredicateNominativesList().Count;
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < relativePronouns_.Count; i_2++)
					{
						dataSize += CodedOutputStream.ComputeInt32SizeNoTag(relativePronouns_[i_2]);
					}
					size += dataSize;
					size += 2 * GetRelativePronounsList().Count;
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < listMembers_.Count; i_2++)
					{
						dataSize += CodedOutputStream.ComputeInt32SizeNoTag(listMembers_[i_2]);
					}
					size += dataSize;
					size += 2 * GetListMembersList().Count;
				}
				{
					int dataSize = 0;
					for (int i_2 = 0; i_2 < belongToLists_.Count; i_2++)
					{
						dataSize += CodedOutputStream.ComputeInt32SizeNoTag(belongToLists_[i_2]);
					}
					size += dataSize;
					size += 2 * GetBelongToListsList().Count;
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Mention))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Mention other = (CoreNLPProtos.Mention)obj;
				bool result = true;
				result = result && (HasMentionID() == other.HasMentionID());
				if (HasMentionID())
				{
					result = result && (GetMentionID() == other.GetMentionID());
				}
				result = result && (HasMentionType() == other.HasMentionType());
				if (HasMentionType())
				{
					result = result && GetMentionType().Equals(other.GetMentionType());
				}
				result = result && (HasNumber() == other.HasNumber());
				if (HasNumber())
				{
					result = result && GetNumber().Equals(other.GetNumber());
				}
				result = result && (HasGender() == other.HasGender());
				if (HasGender())
				{
					result = result && GetGender().Equals(other.GetGender());
				}
				result = result && (HasAnimacy() == other.HasAnimacy());
				if (HasAnimacy())
				{
					result = result && GetAnimacy().Equals(other.GetAnimacy());
				}
				result = result && (HasPerson() == other.HasPerson());
				if (HasPerson())
				{
					result = result && GetPerson().Equals(other.GetPerson());
				}
				result = result && (HasStartIndex() == other.HasStartIndex());
				if (HasStartIndex())
				{
					result = result && (GetStartIndex() == other.GetStartIndex());
				}
				result = result && (HasEndIndex() == other.HasEndIndex());
				if (HasEndIndex())
				{
					result = result && (GetEndIndex() == other.GetEndIndex());
				}
				result = result && (HasHeadIndex() == other.HasHeadIndex());
				if (HasHeadIndex())
				{
					result = result && (GetHeadIndex() == other.GetHeadIndex());
				}
				result = result && (HasHeadString() == other.HasHeadString());
				if (HasHeadString())
				{
					result = result && GetHeadString().Equals(other.GetHeadString());
				}
				result = result && (HasNerString() == other.HasNerString());
				if (HasNerString())
				{
					result = result && GetNerString().Equals(other.GetNerString());
				}
				result = result && (HasOriginalRef() == other.HasOriginalRef());
				if (HasOriginalRef())
				{
					result = result && (GetOriginalRef() == other.GetOriginalRef());
				}
				result = result && (HasGoldCorefClusterID() == other.HasGoldCorefClusterID());
				if (HasGoldCorefClusterID())
				{
					result = result && (GetGoldCorefClusterID() == other.GetGoldCorefClusterID());
				}
				result = result && (HasCorefClusterID() == other.HasCorefClusterID());
				if (HasCorefClusterID())
				{
					result = result && (GetCorefClusterID() == other.GetCorefClusterID());
				}
				result = result && (HasMentionNum() == other.HasMentionNum());
				if (HasMentionNum())
				{
					result = result && (GetMentionNum() == other.GetMentionNum());
				}
				result = result && (HasSentNum() == other.HasSentNum());
				if (HasSentNum())
				{
					result = result && (GetSentNum() == other.GetSentNum());
				}
				result = result && (HasUtter() == other.HasUtter());
				if (HasUtter())
				{
					result = result && (GetUtter() == other.GetUtter());
				}
				result = result && (HasParagraph() == other.HasParagraph());
				if (HasParagraph())
				{
					result = result && (GetParagraph() == other.GetParagraph());
				}
				result = result && (HasIsSubject() == other.HasIsSubject());
				if (HasIsSubject())
				{
					result = result && (GetIsSubject() == other.GetIsSubject());
				}
				result = result && (HasIsDirectObject() == other.HasIsDirectObject());
				if (HasIsDirectObject())
				{
					result = result && (GetIsDirectObject() == other.GetIsDirectObject());
				}
				result = result && (HasIsIndirectObject() == other.HasIsIndirectObject());
				if (HasIsIndirectObject())
				{
					result = result && (GetIsIndirectObject() == other.GetIsIndirectObject());
				}
				result = result && (HasIsPrepositionObject() == other.HasIsPrepositionObject());
				if (HasIsPrepositionObject())
				{
					result = result && (GetIsPrepositionObject() == other.GetIsPrepositionObject());
				}
				result = result && (HasHasTwin() == other.HasHasTwin());
				if (HasHasTwin())
				{
					result = result && (GetHasTwin() == other.GetHasTwin());
				}
				result = result && (HasGeneric() == other.HasGeneric());
				if (HasGeneric())
				{
					result = result && (GetGeneric() == other.GetGeneric());
				}
				result = result && (HasIsSingleton() == other.HasIsSingleton());
				if (HasIsSingleton())
				{
					result = result && (GetIsSingleton() == other.GetIsSingleton());
				}
				result = result && (HasHasBasicDependency() == other.HasHasBasicDependency());
				if (HasHasBasicDependency())
				{
					result = result && (GetHasBasicDependency() == other.GetHasBasicDependency());
				}
				result = result && (HasHasEnhancedDepenedncy() == other.HasHasEnhancedDepenedncy());
				if (HasHasEnhancedDepenedncy())
				{
					result = result && (GetHasEnhancedDepenedncy() == other.GetHasEnhancedDepenedncy());
				}
				result = result && (HasHasContextParseTree() == other.HasHasContextParseTree());
				if (HasHasContextParseTree())
				{
					result = result && (GetHasContextParseTree() == other.GetHasContextParseTree());
				}
				result = result && (HasHeadIndexedWord() == other.HasHeadIndexedWord());
				if (HasHeadIndexedWord())
				{
					result = result && GetHeadIndexedWord().Equals(other.GetHeadIndexedWord());
				}
				result = result && (HasDependingVerb() == other.HasDependingVerb());
				if (HasDependingVerb())
				{
					result = result && GetDependingVerb().Equals(other.GetDependingVerb());
				}
				result = result && (HasHeadWord() == other.HasHeadWord());
				if (HasHeadWord())
				{
					result = result && GetHeadWord().Equals(other.GetHeadWord());
				}
				result = result && (HasSpeakerInfo() == other.HasSpeakerInfo());
				if (HasSpeakerInfo())
				{
					result = result && GetSpeakerInfo().Equals(other.GetSpeakerInfo());
				}
				result = result && GetSentenceWordsList().Equals(other.GetSentenceWordsList());
				result = result && GetOriginalSpanList().Equals(other.GetOriginalSpanList());
				result = result && GetDependentsList().Equals(other.GetDependentsList());
				result = result && GetPreprocessedTermsList().Equals(other.GetPreprocessedTermsList());
				result = result && GetAppositionsList().Equals(other.GetAppositionsList());
				result = result && GetPredicateNominativesList().Equals(other.GetPredicateNominativesList());
				result = result && GetRelativePronounsList().Equals(other.GetRelativePronounsList());
				result = result && GetListMembersList().Equals(other.GetListMembersList());
				result = result && GetBelongToListsList().Equals(other.GetBelongToListsList());
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasMentionID())
				{
					hash = (37 * hash) + MentionidFieldNumber;
					hash = (53 * hash) + GetMentionID();
				}
				if (HasMentionType())
				{
					hash = (37 * hash) + MentiontypeFieldNumber;
					hash = (53 * hash) + GetMentionType().GetHashCode();
				}
				if (HasNumber())
				{
					hash = (37 * hash) + NumberFieldNumber;
					hash = (53 * hash) + GetNumber().GetHashCode();
				}
				if (HasGender())
				{
					hash = (37 * hash) + GenderFieldNumber;
					hash = (53 * hash) + GetGender().GetHashCode();
				}
				if (HasAnimacy())
				{
					hash = (37 * hash) + AnimacyFieldNumber;
					hash = (53 * hash) + GetAnimacy().GetHashCode();
				}
				if (HasPerson())
				{
					hash = (37 * hash) + PersonFieldNumber;
					hash = (53 * hash) + GetPerson().GetHashCode();
				}
				if (HasStartIndex())
				{
					hash = (37 * hash) + StartindexFieldNumber;
					hash = (53 * hash) + GetStartIndex();
				}
				if (HasEndIndex())
				{
					hash = (37 * hash) + EndindexFieldNumber;
					hash = (53 * hash) + GetEndIndex();
				}
				if (HasHeadIndex())
				{
					hash = (37 * hash) + HeadindexFieldNumber;
					hash = (53 * hash) + GetHeadIndex();
				}
				if (HasHeadString())
				{
					hash = (37 * hash) + HeadstringFieldNumber;
					hash = (53 * hash) + GetHeadString().GetHashCode();
				}
				if (HasNerString())
				{
					hash = (37 * hash) + NerstringFieldNumber;
					hash = (53 * hash) + GetNerString().GetHashCode();
				}
				if (HasOriginalRef())
				{
					hash = (37 * hash) + OriginalrefFieldNumber;
					hash = (53 * hash) + GetOriginalRef();
				}
				if (HasGoldCorefClusterID())
				{
					hash = (37 * hash) + GoldcorefclusteridFieldNumber;
					hash = (53 * hash) + GetGoldCorefClusterID();
				}
				if (HasCorefClusterID())
				{
					hash = (37 * hash) + CorefclusteridFieldNumber;
					hash = (53 * hash) + GetCorefClusterID();
				}
				if (HasMentionNum())
				{
					hash = (37 * hash) + MentionnumFieldNumber;
					hash = (53 * hash) + GetMentionNum();
				}
				if (HasSentNum())
				{
					hash = (37 * hash) + SentnumFieldNumber;
					hash = (53 * hash) + GetSentNum();
				}
				if (HasUtter())
				{
					hash = (37 * hash) + UtterFieldNumber;
					hash = (53 * hash) + GetUtter();
				}
				if (HasParagraph())
				{
					hash = (37 * hash) + ParagraphFieldNumber;
					hash = (53 * hash) + GetParagraph();
				}
				if (HasIsSubject())
				{
					hash = (37 * hash) + IssubjectFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetIsSubject());
				}
				if (HasIsDirectObject())
				{
					hash = (37 * hash) + IsdirectobjectFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetIsDirectObject());
				}
				if (HasIsIndirectObject())
				{
					hash = (37 * hash) + IsindirectobjectFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetIsIndirectObject());
				}
				if (HasIsPrepositionObject())
				{
					hash = (37 * hash) + IsprepositionobjectFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetIsPrepositionObject());
				}
				if (HasHasTwin())
				{
					hash = (37 * hash) + HastwinFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasTwin());
				}
				if (HasGeneric())
				{
					hash = (37 * hash) + GenericFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetGeneric());
				}
				if (HasIsSingleton())
				{
					hash = (37 * hash) + IssingletonFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetIsSingleton());
				}
				if (HasHasBasicDependency())
				{
					hash = (37 * hash) + HasbasicdependencyFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasBasicDependency());
				}
				if (HasHasEnhancedDepenedncy())
				{
					hash = (37 * hash) + HasenhanceddepenedncyFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasEnhancedDepenedncy());
				}
				if (HasHasContextParseTree())
				{
					hash = (37 * hash) + HascontextparsetreeFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetHasContextParseTree());
				}
				if (HasHeadIndexedWord())
				{
					hash = (37 * hash) + HeadindexedwordFieldNumber;
					hash = (53 * hash) + GetHeadIndexedWord().GetHashCode();
				}
				if (HasDependingVerb())
				{
					hash = (37 * hash) + DependingverbFieldNumber;
					hash = (53 * hash) + GetDependingVerb().GetHashCode();
				}
				if (HasHeadWord())
				{
					hash = (37 * hash) + HeadwordFieldNumber;
					hash = (53 * hash) + GetHeadWord().GetHashCode();
				}
				if (HasSpeakerInfo())
				{
					hash = (37 * hash) + SpeakerinfoFieldNumber;
					hash = (53 * hash) + GetSpeakerInfo().GetHashCode();
				}
				if (GetSentenceWordsCount() > 0)
				{
					hash = (37 * hash) + SentencewordsFieldNumber;
					hash = (53 * hash) + GetSentenceWordsList().GetHashCode();
				}
				if (GetOriginalSpanCount() > 0)
				{
					hash = (37 * hash) + OriginalspanFieldNumber;
					hash = (53 * hash) + GetOriginalSpanList().GetHashCode();
				}
				if (GetDependentsCount() > 0)
				{
					hash = (37 * hash) + DependentsFieldNumber;
					hash = (53 * hash) + GetDependentsList().GetHashCode();
				}
				if (GetPreprocessedTermsCount() > 0)
				{
					hash = (37 * hash) + PreprocessedtermsFieldNumber;
					hash = (53 * hash) + GetPreprocessedTermsList().GetHashCode();
				}
				if (GetAppositionsCount() > 0)
				{
					hash = (37 * hash) + AppositionsFieldNumber;
					hash = (53 * hash) + GetAppositionsList().GetHashCode();
				}
				if (GetPredicateNominativesCount() > 0)
				{
					hash = (37 * hash) + PredicatenominativesFieldNumber;
					hash = (53 * hash) + GetPredicateNominativesList().GetHashCode();
				}
				if (GetRelativePronounsCount() > 0)
				{
					hash = (37 * hash) + RelativepronounsFieldNumber;
					hash = (53 * hash) + GetRelativePronounsList().GetHashCode();
				}
				if (GetListMembersCount() > 0)
				{
					hash = (37 * hash) + ListmembersFieldNumber;
					hash = (53 * hash) + GetListMembersList().GetHashCode();
				}
				if (GetBelongToListsCount() > 0)
				{
					hash = (37 * hash) + BelongtolistsFieldNumber;
					hash = (53 * hash) + GetBelongToListsList().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Mention ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Mention ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Mention ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Mention ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Mention ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Mention ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Mention ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Mention ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Mention ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Mention ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Mention.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Mention.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Mention.Builder NewBuilder(CoreNLPProtos.Mention prototype)
			{
				return ((CoreNLPProtos.Mention.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Mention.Builder() : new CoreNLPProtos.Mention.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Mention.Builder builder = new CoreNLPProtos.Mention.Builder(parent);
				return builder;
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Mention</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Mention.Builder>, CoreNLPProtos.IMentionOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Mention)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Mention_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Mention_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Mention), typeof(CoreNLPProtos.Mention.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Mention.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetHeadIndexedWordFieldBuilder();
						GetDependingVerbFieldBuilder();
						GetHeadWordFieldBuilder();
						GetSpeakerInfoFieldBuilder();
						GetSentenceWordsFieldBuilder();
						GetOriginalSpanFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					mentionID_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					mentionType_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					number_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					gender_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					animacy_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					person_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					startIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					endIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					headIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					headString_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					nerString_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					originalRef_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					goldCorefClusterID_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					corefClusterID_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					mentionNum_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					sentNum_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					utter_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					paragraph_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					isSubject_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
					isDirectObject_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					isIndirectObject_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					isPrepositionObject_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
					hasTwin_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
					generic_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00800000)));
					isSingleton_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x01000000)));
					hasBasicDependency_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x02000000)));
					hasEnhancedDepenedncy_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
					hasContextParseTree_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
					if (headIndexedWordBuilder_ == null)
					{
						headIndexedWord_ = null;
					}
					else
					{
						headIndexedWordBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x10000000)));
					if (dependingVerbBuilder_ == null)
					{
						dependingVerb_ = null;
					}
					else
					{
						dependingVerbBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
					if (headWordBuilder_ == null)
					{
						headWord_ = null;
					}
					else
					{
						headWordBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
					if (speakerInfoBuilder_ == null)
					{
						speakerInfo_ = null;
					}
					else
					{
						speakerInfoBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x80000000)));
					if (sentenceWordsBuilder_ == null)
					{
						sentenceWords_ = Java.Util.Collections.EmptyList();
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
					}
					else
					{
						sentenceWordsBuilder_.Clear();
					}
					if (originalSpanBuilder_ == null)
					{
						originalSpan_ = Java.Util.Collections.EmptyList();
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
					}
					else
					{
						originalSpanBuilder_.Clear();
					}
					dependents_ = LazyStringArrayList.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
					preprocessedTerms_ = LazyStringArrayList.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
					appositions_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
					predicateNominatives_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
					relativePronouns_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
					listMembers_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
					belongToLists_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Mention_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Mention.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Mention result = ((CoreNLPProtos.Mention)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Mention result = new CoreNLPProtos.Mention(this);
					int from_bitField0_ = bitField0_;
					int from_bitField1_ = bitField1_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.mentionID_ = mentionID_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.mentionType_ = mentionType_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.number_ = number_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.gender_ = gender_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.animacy_ = animacy_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.person_ = person_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.startIndex_ = startIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					result.endIndex_ = endIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000100));
					}
					result.headIndex_ = headIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x00000200));
					}
					result.headString_ = headString_;
					if (((from_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x00000400));
					}
					result.nerString_ = nerString_;
					if (((from_bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField0_ |= unchecked((int)(0x00000800));
					}
					result.originalRef_ = originalRef_;
					if (((from_bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000))))
					{
						to_bitField0_ |= unchecked((int)(0x00001000));
					}
					result.goldCorefClusterID_ = goldCorefClusterID_;
					if (((from_bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000))))
					{
						to_bitField0_ |= unchecked((int)(0x00002000));
					}
					result.corefClusterID_ = corefClusterID_;
					if (((from_bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000))))
					{
						to_bitField0_ |= unchecked((int)(0x00004000));
					}
					result.mentionNum_ = mentionNum_;
					if (((from_bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000))))
					{
						to_bitField0_ |= unchecked((int)(0x00008000));
					}
					result.sentNum_ = sentNum_;
					if (((from_bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000))))
					{
						to_bitField0_ |= unchecked((int)(0x00010000));
					}
					result.utter_ = utter_;
					if (((from_bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000))))
					{
						to_bitField0_ |= unchecked((int)(0x00020000));
					}
					result.paragraph_ = paragraph_;
					if (((from_bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000))))
					{
						to_bitField0_ |= unchecked((int)(0x00040000));
					}
					result.isSubject_ = isSubject_;
					if (((from_bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000))))
					{
						to_bitField0_ |= unchecked((int)(0x00080000));
					}
					result.isDirectObject_ = isDirectObject_;
					if (((from_bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000))))
					{
						to_bitField0_ |= unchecked((int)(0x00100000));
					}
					result.isIndirectObject_ = isIndirectObject_;
					if (((from_bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000))))
					{
						to_bitField0_ |= unchecked((int)(0x00200000));
					}
					result.isPrepositionObject_ = isPrepositionObject_;
					if (((from_bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000))))
					{
						to_bitField0_ |= unchecked((int)(0x00400000));
					}
					result.hasTwin_ = hasTwin_;
					if (((from_bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000))))
					{
						to_bitField0_ |= unchecked((int)(0x00800000));
					}
					result.generic_ = generic_;
					if (((from_bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000))))
					{
						to_bitField0_ |= unchecked((int)(0x01000000));
					}
					result.isSingleton_ = isSingleton_;
					if (((from_bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000))))
					{
						to_bitField0_ |= unchecked((int)(0x02000000));
					}
					result.hasBasicDependency_ = hasBasicDependency_;
					if (((from_bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000))))
					{
						to_bitField0_ |= unchecked((int)(0x04000000));
					}
					result.hasEnhancedDepenedncy_ = hasEnhancedDepenedncy_;
					if (((from_bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000))))
					{
						to_bitField0_ |= unchecked((int)(0x08000000));
					}
					result.hasContextParseTree_ = hasContextParseTree_;
					if (((from_bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))))
					{
						to_bitField0_ |= unchecked((int)(0x10000000));
					}
					if (headIndexedWordBuilder_ == null)
					{
						result.headIndexedWord_ = headIndexedWord_;
					}
					else
					{
						result.headIndexedWord_ = headIndexedWordBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))))
					{
						to_bitField0_ |= unchecked((int)(0x20000000));
					}
					if (dependingVerbBuilder_ == null)
					{
						result.dependingVerb_ = dependingVerb_;
					}
					else
					{
						result.dependingVerb_ = dependingVerbBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))))
					{
						to_bitField0_ |= unchecked((int)(0x40000000));
					}
					if (headWordBuilder_ == null)
					{
						result.headWord_ = headWord_;
					}
					else
					{
						result.headWord_ = headWordBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))))
					{
						to_bitField0_ |= unchecked((int)(0x80000000));
					}
					if (speakerInfoBuilder_ == null)
					{
						result.speakerInfo_ = speakerInfo_;
					}
					else
					{
						result.speakerInfo_ = speakerInfoBuilder_.Build();
					}
					if (sentenceWordsBuilder_ == null)
					{
						if (((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
						{
							sentenceWords_ = Java.Util.Collections.UnmodifiableList(sentenceWords_);
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
						}
						result.sentenceWords_ = sentenceWords_;
					}
					else
					{
						result.sentenceWords_ = sentenceWordsBuilder_.Build();
					}
					if (originalSpanBuilder_ == null)
					{
						if (((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							originalSpan_ = Java.Util.Collections.UnmodifiableList(originalSpan_);
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
						}
						result.originalSpan_ = originalSpan_;
					}
					else
					{
						result.originalSpan_ = originalSpanBuilder_.Build();
					}
					if (((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						dependents_ = dependents_.GetUnmodifiableView();
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
					}
					result.dependents_ = dependents_;
					if (((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						preprocessedTerms_ = preprocessedTerms_.GetUnmodifiableView();
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
					}
					result.preprocessedTerms_ = preprocessedTerms_;
					if (((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						appositions_ = Java.Util.Collections.UnmodifiableList(appositions_);
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
					}
					result.appositions_ = appositions_;
					if (((bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						predicateNominatives_ = Java.Util.Collections.UnmodifiableList(predicateNominatives_);
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
					}
					result.predicateNominatives_ = predicateNominatives_;
					if (((bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						relativePronouns_ = Java.Util.Collections.UnmodifiableList(relativePronouns_);
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
					}
					result.relativePronouns_ = relativePronouns_;
					if (((bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						listMembers_ = Java.Util.Collections.UnmodifiableList(listMembers_);
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
					}
					result.listMembers_ = listMembers_;
					if (((bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						belongToLists_ = Java.Util.Collections.UnmodifiableList(belongToLists_);
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
					}
					result.belongToLists_ = belongToLists_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Mention.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Mention.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Mention.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Mention.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Mention.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Mention.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Mention.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Mention.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Mention)
					{
						return MergeFrom((CoreNLPProtos.Mention)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Mention.Builder MergeFrom(CoreNLPProtos.Mention other)
				{
					if (other == CoreNLPProtos.Mention.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasMentionID())
					{
						SetMentionID(other.GetMentionID());
					}
					if (other.HasMentionType())
					{
						bitField0_ |= unchecked((int)(0x00000002));
						mentionType_ = other.mentionType_;
						OnChanged();
					}
					if (other.HasNumber())
					{
						bitField0_ |= unchecked((int)(0x00000004));
						number_ = other.number_;
						OnChanged();
					}
					if (other.HasGender())
					{
						bitField0_ |= unchecked((int)(0x00000008));
						gender_ = other.gender_;
						OnChanged();
					}
					if (other.HasAnimacy())
					{
						bitField0_ |= unchecked((int)(0x00000010));
						animacy_ = other.animacy_;
						OnChanged();
					}
					if (other.HasPerson())
					{
						bitField0_ |= unchecked((int)(0x00000020));
						person_ = other.person_;
						OnChanged();
					}
					if (other.HasStartIndex())
					{
						SetStartIndex(other.GetStartIndex());
					}
					if (other.HasEndIndex())
					{
						SetEndIndex(other.GetEndIndex());
					}
					if (other.HasHeadIndex())
					{
						SetHeadIndex(other.GetHeadIndex());
					}
					if (other.HasHeadString())
					{
						bitField0_ |= unchecked((int)(0x00000200));
						headString_ = other.headString_;
						OnChanged();
					}
					if (other.HasNerString())
					{
						bitField0_ |= unchecked((int)(0x00000400));
						nerString_ = other.nerString_;
						OnChanged();
					}
					if (other.HasOriginalRef())
					{
						SetOriginalRef(other.GetOriginalRef());
					}
					if (other.HasGoldCorefClusterID())
					{
						SetGoldCorefClusterID(other.GetGoldCorefClusterID());
					}
					if (other.HasCorefClusterID())
					{
						SetCorefClusterID(other.GetCorefClusterID());
					}
					if (other.HasMentionNum())
					{
						SetMentionNum(other.GetMentionNum());
					}
					if (other.HasSentNum())
					{
						SetSentNum(other.GetSentNum());
					}
					if (other.HasUtter())
					{
						SetUtter(other.GetUtter());
					}
					if (other.HasParagraph())
					{
						SetParagraph(other.GetParagraph());
					}
					if (other.HasIsSubject())
					{
						SetIsSubject(other.GetIsSubject());
					}
					if (other.HasIsDirectObject())
					{
						SetIsDirectObject(other.GetIsDirectObject());
					}
					if (other.HasIsIndirectObject())
					{
						SetIsIndirectObject(other.GetIsIndirectObject());
					}
					if (other.HasIsPrepositionObject())
					{
						SetIsPrepositionObject(other.GetIsPrepositionObject());
					}
					if (other.HasHasTwin())
					{
						SetHasTwin(other.GetHasTwin());
					}
					if (other.HasGeneric())
					{
						SetGeneric(other.GetGeneric());
					}
					if (other.HasIsSingleton())
					{
						SetIsSingleton(other.GetIsSingleton());
					}
					if (other.HasHasBasicDependency())
					{
						SetHasBasicDependency(other.GetHasBasicDependency());
					}
					if (other.HasHasEnhancedDepenedncy())
					{
						SetHasEnhancedDepenedncy(other.GetHasEnhancedDepenedncy());
					}
					if (other.HasHasContextParseTree())
					{
						SetHasContextParseTree(other.GetHasContextParseTree());
					}
					if (other.HasHeadIndexedWord())
					{
						MergeHeadIndexedWord(other.GetHeadIndexedWord());
					}
					if (other.HasDependingVerb())
					{
						MergeDependingVerb(other.GetDependingVerb());
					}
					if (other.HasHeadWord())
					{
						MergeHeadWord(other.GetHeadWord());
					}
					if (other.HasSpeakerInfo())
					{
						MergeSpeakerInfo(other.GetSpeakerInfo());
					}
					if (sentenceWordsBuilder_ == null)
					{
						if (!other.sentenceWords_.IsEmpty())
						{
							if (sentenceWords_.IsEmpty())
							{
								sentenceWords_ = other.sentenceWords_;
								bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
							}
							else
							{
								EnsureSentenceWordsIsMutable();
								Sharpen.Collections.AddAll(sentenceWords_, other.sentenceWords_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.sentenceWords_.IsEmpty())
						{
							if (sentenceWordsBuilder_.IsEmpty())
							{
								sentenceWordsBuilder_.Dispose();
								sentenceWordsBuilder_ = null;
								sentenceWords_ = other.sentenceWords_;
								bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
								sentenceWordsBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetSentenceWordsFieldBuilder() : null;
							}
							else
							{
								sentenceWordsBuilder_.AddAllMessages(other.sentenceWords_);
							}
						}
					}
					if (originalSpanBuilder_ == null)
					{
						if (!other.originalSpan_.IsEmpty())
						{
							if (originalSpan_.IsEmpty())
							{
								originalSpan_ = other.originalSpan_;
								bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
							}
							else
							{
								EnsureOriginalSpanIsMutable();
								Sharpen.Collections.AddAll(originalSpan_, other.originalSpan_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.originalSpan_.IsEmpty())
						{
							if (originalSpanBuilder_.IsEmpty())
							{
								originalSpanBuilder_.Dispose();
								originalSpanBuilder_ = null;
								originalSpan_ = other.originalSpan_;
								bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
								originalSpanBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetOriginalSpanFieldBuilder() : null;
							}
							else
							{
								originalSpanBuilder_.AddAllMessages(other.originalSpan_);
							}
						}
					}
					if (!other.dependents_.IsEmpty())
					{
						if (dependents_.IsEmpty())
						{
							dependents_ = other.dependents_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
						}
						else
						{
							EnsureDependentsIsMutable();
							Sharpen.Collections.AddAll(dependents_, other.dependents_);
						}
						OnChanged();
					}
					if (!other.preprocessedTerms_.IsEmpty())
					{
						if (preprocessedTerms_.IsEmpty())
						{
							preprocessedTerms_ = other.preprocessedTerms_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
						}
						else
						{
							EnsurePreprocessedTermsIsMutable();
							Sharpen.Collections.AddAll(preprocessedTerms_, other.preprocessedTerms_);
						}
						OnChanged();
					}
					if (!other.appositions_.IsEmpty())
					{
						if (appositions_.IsEmpty())
						{
							appositions_ = other.appositions_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
						}
						else
						{
							EnsureAppositionsIsMutable();
							Sharpen.Collections.AddAll(appositions_, other.appositions_);
						}
						OnChanged();
					}
					if (!other.predicateNominatives_.IsEmpty())
					{
						if (predicateNominatives_.IsEmpty())
						{
							predicateNominatives_ = other.predicateNominatives_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
						}
						else
						{
							EnsurePredicateNominativesIsMutable();
							Sharpen.Collections.AddAll(predicateNominatives_, other.predicateNominatives_);
						}
						OnChanged();
					}
					if (!other.relativePronouns_.IsEmpty())
					{
						if (relativePronouns_.IsEmpty())
						{
							relativePronouns_ = other.relativePronouns_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
						}
						else
						{
							EnsureRelativePronounsIsMutable();
							Sharpen.Collections.AddAll(relativePronouns_, other.relativePronouns_);
						}
						OnChanged();
					}
					if (!other.listMembers_.IsEmpty())
					{
						if (listMembers_.IsEmpty())
						{
							listMembers_ = other.listMembers_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
						}
						else
						{
							EnsureListMembersIsMutable();
							Sharpen.Collections.AddAll(listMembers_, other.listMembers_);
						}
						OnChanged();
					}
					if (!other.belongToLists_.IsEmpty())
					{
						if (belongToLists_.IsEmpty())
						{
							belongToLists_ = other.belongToLists_;
							bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
						}
						else
						{
							EnsureBelongToListsIsMutable();
							Sharpen.Collections.AddAll(belongToLists_, other.belongToLists_);
						}
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Mention parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Mention)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int bitField1_;

				private int mentionID_;

				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				public bool HasMentionID()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				public int GetMentionID()
				{
					return mentionID_;
				}

				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				public CoreNLPProtos.Mention.Builder SetMentionID(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					mentionID_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional int32 mentionID = 1;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearMentionID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					mentionID_ = 0;
					OnChanged();
					return this;
				}

				private object mentionType_ = string.Empty;

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public bool HasMentionType()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public string GetMentionType()
				{
					object @ref = mentionType_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							mentionType_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public ByteString GetMentionTypeBytes()
				{
					object @ref = mentionType_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						mentionType_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public CoreNLPProtos.Mention.Builder SetMentionType(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					mentionType_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearMentionType()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					mentionType_ = GetDefaultInstance().GetMentionType();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionType = 2;</code></summary>
				public CoreNLPProtos.Mention.Builder SetMentionTypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					mentionType_ = value;
					OnChanged();
					return this;
				}

				private object number_ = string.Empty;

				/// <summary><code>optional string number = 3;</code></summary>
				public bool HasNumber()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional string number = 3;</code></summary>
				public string GetNumber()
				{
					object @ref = number_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							number_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string number = 3;</code></summary>
				public ByteString GetNumberBytes()
				{
					object @ref = number_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						number_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string number = 3;</code></summary>
				public CoreNLPProtos.Mention.Builder SetNumber(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					number_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string number = 3;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearNumber()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					number_ = GetDefaultInstance().GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string number = 3;</code></summary>
				public CoreNLPProtos.Mention.Builder SetNumberBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					number_ = value;
					OnChanged();
					return this;
				}

				private object gender_ = string.Empty;

				/// <summary><code>optional string gender = 4;</code></summary>
				public bool HasGender()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional string gender = 4;</code></summary>
				public string GetGender()
				{
					object @ref = gender_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							gender_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string gender = 4;</code></summary>
				public ByteString GetGenderBytes()
				{
					object @ref = gender_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						gender_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string gender = 4;</code></summary>
				public CoreNLPProtos.Mention.Builder SetGender(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					gender_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string gender = 4;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearGender()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					gender_ = GetDefaultInstance().GetGender();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string gender = 4;</code></summary>
				public CoreNLPProtos.Mention.Builder SetGenderBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					gender_ = value;
					OnChanged();
					return this;
				}

				private object animacy_ = string.Empty;

				/// <summary><code>optional string animacy = 5;</code></summary>
				public bool HasAnimacy()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional string animacy = 5;</code></summary>
				public string GetAnimacy()
				{
					object @ref = animacy_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							animacy_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string animacy = 5;</code></summary>
				public ByteString GetAnimacyBytes()
				{
					object @ref = animacy_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						animacy_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string animacy = 5;</code></summary>
				public CoreNLPProtos.Mention.Builder SetAnimacy(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					animacy_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string animacy = 5;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearAnimacy()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					animacy_ = GetDefaultInstance().GetAnimacy();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string animacy = 5;</code></summary>
				public CoreNLPProtos.Mention.Builder SetAnimacyBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					animacy_ = value;
					OnChanged();
					return this;
				}

				private object person_ = string.Empty;

				/// <summary><code>optional string person = 6;</code></summary>
				public bool HasPerson()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional string person = 6;</code></summary>
				public string GetPerson()
				{
					object @ref = person_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							person_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string person = 6;</code></summary>
				public ByteString GetPersonBytes()
				{
					object @ref = person_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						person_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string person = 6;</code></summary>
				public CoreNLPProtos.Mention.Builder SetPerson(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					person_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string person = 6;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearPerson()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					person_ = GetDefaultInstance().GetPerson();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string person = 6;</code></summary>
				public CoreNLPProtos.Mention.Builder SetPersonBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					person_ = value;
					OnChanged();
					return this;
				}

				private int startIndex_;

				/// <summary><code>optional uint32 startIndex = 7;</code></summary>
				public bool HasStartIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional uint32 startIndex = 7;</code></summary>
				public int GetStartIndex()
				{
					return startIndex_;
				}

				/// <summary><code>optional uint32 startIndex = 7;</code></summary>
				public CoreNLPProtos.Mention.Builder SetStartIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000040));
					startIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 startIndex = 7;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearStartIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					startIndex_ = 0;
					OnChanged();
					return this;
				}

				private int endIndex_;

				/// <summary><code>optional uint32 endIndex = 9;</code></summary>
				public bool HasEndIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary><code>optional uint32 endIndex = 9;</code></summary>
				public int GetEndIndex()
				{
					return endIndex_;
				}

				/// <summary><code>optional uint32 endIndex = 9;</code></summary>
				public CoreNLPProtos.Mention.Builder SetEndIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000080));
					endIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 endIndex = 9;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearEndIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					endIndex_ = 0;
					OnChanged();
					return this;
				}

				private int headIndex_;

				/// <summary><code>optional uint32 headIndex = 10;</code></summary>
				public bool HasHeadIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary><code>optional uint32 headIndex = 10;</code></summary>
				public int GetHeadIndex()
				{
					return headIndex_;
				}

				/// <summary><code>optional uint32 headIndex = 10;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHeadIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000100));
					headIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 headIndex = 10;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHeadIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					headIndex_ = 0;
					OnChanged();
					return this;
				}

				private object headString_ = string.Empty;

				/// <summary><code>optional string headString = 11;</code></summary>
				public bool HasHeadString()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary><code>optional string headString = 11;</code></summary>
				public string GetHeadString()
				{
					object @ref = headString_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							headString_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string headString = 11;</code></summary>
				public ByteString GetHeadStringBytes()
				{
					object @ref = headString_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						headString_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string headString = 11;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHeadString(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					headString_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string headString = 11;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHeadString()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					headString_ = GetDefaultInstance().GetHeadString();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string headString = 11;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHeadStringBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					headString_ = value;
					OnChanged();
					return this;
				}

				private object nerString_ = string.Empty;

				/// <summary><code>optional string nerString = 12;</code></summary>
				public bool HasNerString()
				{
					return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary><code>optional string nerString = 12;</code></summary>
				public string GetNerString()
				{
					object @ref = nerString_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							nerString_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string nerString = 12;</code></summary>
				public ByteString GetNerStringBytes()
				{
					object @ref = nerString_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						nerString_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string nerString = 12;</code></summary>
				public CoreNLPProtos.Mention.Builder SetNerString(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					nerString_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string nerString = 12;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearNerString()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					nerString_ = GetDefaultInstance().GetNerString();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string nerString = 12;</code></summary>
				public CoreNLPProtos.Mention.Builder SetNerStringBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					nerString_ = value;
					OnChanged();
					return this;
				}

				private int originalRef_;

				/// <summary><code>optional uint32 originalRef = 13;</code></summary>
				public bool HasOriginalRef()
				{
					return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary><code>optional uint32 originalRef = 13;</code></summary>
				public int GetOriginalRef()
				{
					return originalRef_;
				}

				/// <summary><code>optional uint32 originalRef = 13;</code></summary>
				public CoreNLPProtos.Mention.Builder SetOriginalRef(int value)
				{
					bitField0_ |= unchecked((int)(0x00000800));
					originalRef_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 originalRef = 13;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearOriginalRef()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					originalRef_ = 0;
					OnChanged();
					return this;
				}

				private int goldCorefClusterID_;

				/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
				public bool HasGoldCorefClusterID()
				{
					return ((bitField0_ & unchecked((int)(0x00001000))) == unchecked((int)(0x00001000)));
				}

				/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
				public int GetGoldCorefClusterID()
				{
					return goldCorefClusterID_;
				}

				/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
				public CoreNLPProtos.Mention.Builder SetGoldCorefClusterID(int value)
				{
					bitField0_ |= unchecked((int)(0x00001000));
					goldCorefClusterID_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional int32 goldCorefClusterID = 14;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearGoldCorefClusterID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00001000)));
					goldCorefClusterID_ = 0;
					OnChanged();
					return this;
				}

				private int corefClusterID_;

				/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
				public bool HasCorefClusterID()
				{
					return ((bitField0_ & unchecked((int)(0x00002000))) == unchecked((int)(0x00002000)));
				}

				/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
				public int GetCorefClusterID()
				{
					return corefClusterID_;
				}

				/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
				public CoreNLPProtos.Mention.Builder SetCorefClusterID(int value)
				{
					bitField0_ |= unchecked((int)(0x00002000));
					corefClusterID_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional int32 corefClusterID = 15;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearCorefClusterID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00002000)));
					corefClusterID_ = 0;
					OnChanged();
					return this;
				}

				private int mentionNum_;

				/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
				public bool HasMentionNum()
				{
					return ((bitField0_ & unchecked((int)(0x00004000))) == unchecked((int)(0x00004000)));
				}

				/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
				public int GetMentionNum()
				{
					return mentionNum_;
				}

				/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
				public CoreNLPProtos.Mention.Builder SetMentionNum(int value)
				{
					bitField0_ |= unchecked((int)(0x00004000));
					mentionNum_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 mentionNum = 16;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearMentionNum()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00004000)));
					mentionNum_ = 0;
					OnChanged();
					return this;
				}

				private int sentNum_;

				/// <summary><code>optional uint32 sentNum = 17;</code></summary>
				public bool HasSentNum()
				{
					return ((bitField0_ & unchecked((int)(0x00008000))) == unchecked((int)(0x00008000)));
				}

				/// <summary><code>optional uint32 sentNum = 17;</code></summary>
				public int GetSentNum()
				{
					return sentNum_;
				}

				/// <summary><code>optional uint32 sentNum = 17;</code></summary>
				public CoreNLPProtos.Mention.Builder SetSentNum(int value)
				{
					bitField0_ |= unchecked((int)(0x00008000));
					sentNum_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 sentNum = 17;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearSentNum()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00008000)));
					sentNum_ = 0;
					OnChanged();
					return this;
				}

				private int utter_;

				/// <summary><code>optional uint32 utter = 18;</code></summary>
				public bool HasUtter()
				{
					return ((bitField0_ & unchecked((int)(0x00010000))) == unchecked((int)(0x00010000)));
				}

				/// <summary><code>optional uint32 utter = 18;</code></summary>
				public int GetUtter()
				{
					return utter_;
				}

				/// <summary><code>optional uint32 utter = 18;</code></summary>
				public CoreNLPProtos.Mention.Builder SetUtter(int value)
				{
					bitField0_ |= unchecked((int)(0x00010000));
					utter_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 utter = 18;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearUtter()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00010000)));
					utter_ = 0;
					OnChanged();
					return this;
				}

				private int paragraph_;

				/// <summary><code>optional uint32 paragraph = 19;</code></summary>
				public bool HasParagraph()
				{
					return ((bitField0_ & unchecked((int)(0x00020000))) == unchecked((int)(0x00020000)));
				}

				/// <summary><code>optional uint32 paragraph = 19;</code></summary>
				public int GetParagraph()
				{
					return paragraph_;
				}

				/// <summary><code>optional uint32 paragraph = 19;</code></summary>
				public CoreNLPProtos.Mention.Builder SetParagraph(int value)
				{
					bitField0_ |= unchecked((int)(0x00020000));
					paragraph_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 paragraph = 19;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearParagraph()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00020000)));
					paragraph_ = 0;
					OnChanged();
					return this;
				}

				private bool isSubject_;

				/// <summary><code>optional bool isSubject = 20;</code></summary>
				public bool HasIsSubject()
				{
					return ((bitField0_ & unchecked((int)(0x00040000))) == unchecked((int)(0x00040000)));
				}

				/// <summary><code>optional bool isSubject = 20;</code></summary>
				public bool GetIsSubject()
				{
					return isSubject_;
				}

				/// <summary><code>optional bool isSubject = 20;</code></summary>
				public CoreNLPProtos.Mention.Builder SetIsSubject(bool value)
				{
					bitField0_ |= unchecked((int)(0x00040000));
					isSubject_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool isSubject = 20;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearIsSubject()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00040000)));
					isSubject_ = false;
					OnChanged();
					return this;
				}

				private bool isDirectObject_;

				/// <summary><code>optional bool isDirectObject = 21;</code></summary>
				public bool HasIsDirectObject()
				{
					return ((bitField0_ & unchecked((int)(0x00080000))) == unchecked((int)(0x00080000)));
				}

				/// <summary><code>optional bool isDirectObject = 21;</code></summary>
				public bool GetIsDirectObject()
				{
					return isDirectObject_;
				}

				/// <summary><code>optional bool isDirectObject = 21;</code></summary>
				public CoreNLPProtos.Mention.Builder SetIsDirectObject(bool value)
				{
					bitField0_ |= unchecked((int)(0x00080000));
					isDirectObject_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool isDirectObject = 21;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearIsDirectObject()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00080000)));
					isDirectObject_ = false;
					OnChanged();
					return this;
				}

				private bool isIndirectObject_;

				/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
				public bool HasIsIndirectObject()
				{
					return ((bitField0_ & unchecked((int)(0x00100000))) == unchecked((int)(0x00100000)));
				}

				/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
				public bool GetIsIndirectObject()
				{
					return isIndirectObject_;
				}

				/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
				public CoreNLPProtos.Mention.Builder SetIsIndirectObject(bool value)
				{
					bitField0_ |= unchecked((int)(0x00100000));
					isIndirectObject_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool isIndirectObject = 22;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearIsIndirectObject()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00100000)));
					isIndirectObject_ = false;
					OnChanged();
					return this;
				}

				private bool isPrepositionObject_;

				/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
				public bool HasIsPrepositionObject()
				{
					return ((bitField0_ & unchecked((int)(0x00200000))) == unchecked((int)(0x00200000)));
				}

				/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
				public bool GetIsPrepositionObject()
				{
					return isPrepositionObject_;
				}

				/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
				public CoreNLPProtos.Mention.Builder SetIsPrepositionObject(bool value)
				{
					bitField0_ |= unchecked((int)(0x00200000));
					isPrepositionObject_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool isPrepositionObject = 23;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearIsPrepositionObject()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00200000)));
					isPrepositionObject_ = false;
					OnChanged();
					return this;
				}

				private bool hasTwin_;

				/// <summary><code>optional bool hasTwin = 24;</code></summary>
				public bool HasHasTwin()
				{
					return ((bitField0_ & unchecked((int)(0x00400000))) == unchecked((int)(0x00400000)));
				}

				/// <summary><code>optional bool hasTwin = 24;</code></summary>
				public bool GetHasTwin()
				{
					return hasTwin_;
				}

				/// <summary><code>optional bool hasTwin = 24;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHasTwin(bool value)
				{
					bitField0_ |= unchecked((int)(0x00400000));
					hasTwin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasTwin = 24;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHasTwin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00400000)));
					hasTwin_ = false;
					OnChanged();
					return this;
				}

				private bool generic_;

				/// <summary><code>optional bool generic = 25;</code></summary>
				public bool HasGeneric()
				{
					return ((bitField0_ & unchecked((int)(0x00800000))) == unchecked((int)(0x00800000)));
				}

				/// <summary><code>optional bool generic = 25;</code></summary>
				public bool GetGeneric()
				{
					return generic_;
				}

				/// <summary><code>optional bool generic = 25;</code></summary>
				public CoreNLPProtos.Mention.Builder SetGeneric(bool value)
				{
					bitField0_ |= unchecked((int)(0x00800000));
					generic_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool generic = 25;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearGeneric()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00800000)));
					generic_ = false;
					OnChanged();
					return this;
				}

				private bool isSingleton_;

				/// <summary><code>optional bool isSingleton = 26;</code></summary>
				public bool HasIsSingleton()
				{
					return ((bitField0_ & unchecked((int)(0x01000000))) == unchecked((int)(0x01000000)));
				}

				/// <summary><code>optional bool isSingleton = 26;</code></summary>
				public bool GetIsSingleton()
				{
					return isSingleton_;
				}

				/// <summary><code>optional bool isSingleton = 26;</code></summary>
				public CoreNLPProtos.Mention.Builder SetIsSingleton(bool value)
				{
					bitField0_ |= unchecked((int)(0x01000000));
					isSingleton_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool isSingleton = 26;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearIsSingleton()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x01000000)));
					isSingleton_ = false;
					OnChanged();
					return this;
				}

				private bool hasBasicDependency_;

				/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
				public bool HasHasBasicDependency()
				{
					return ((bitField0_ & unchecked((int)(0x02000000))) == unchecked((int)(0x02000000)));
				}

				/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
				public bool GetHasBasicDependency()
				{
					return hasBasicDependency_;
				}

				/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHasBasicDependency(bool value)
				{
					bitField0_ |= unchecked((int)(0x02000000));
					hasBasicDependency_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasBasicDependency = 27;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHasBasicDependency()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x02000000)));
					hasBasicDependency_ = false;
					OnChanged();
					return this;
				}

				private bool hasEnhancedDepenedncy_;

				/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
				public bool HasHasEnhancedDepenedncy()
				{
					return ((bitField0_ & unchecked((int)(0x04000000))) == unchecked((int)(0x04000000)));
				}

				/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
				public bool GetHasEnhancedDepenedncy()
				{
					return hasEnhancedDepenedncy_;
				}

				/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHasEnhancedDepenedncy(bool value)
				{
					bitField0_ |= unchecked((int)(0x04000000));
					hasEnhancedDepenedncy_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasEnhancedDepenedncy = 28;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHasEnhancedDepenedncy()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x04000000)));
					hasEnhancedDepenedncy_ = false;
					OnChanged();
					return this;
				}

				private bool hasContextParseTree_;

				/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
				public bool HasHasContextParseTree()
				{
					return ((bitField0_ & unchecked((int)(0x08000000))) == unchecked((int)(0x08000000)));
				}

				/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
				public bool GetHasContextParseTree()
				{
					return hasContextParseTree_;
				}

				/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHasContextParseTree(bool value)
				{
					bitField0_ |= unchecked((int)(0x08000000));
					hasContextParseTree_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool hasContextParseTree = 29;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHasContextParseTree()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x08000000)));
					hasContextParseTree_ = false;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.IndexedWord headIndexedWord_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> headIndexedWordBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public bool HasHeadIndexedWord()
				{
					return ((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public CoreNLPProtos.IndexedWord GetHeadIndexedWord()
				{
					if (headIndexedWordBuilder_ == null)
					{
						return headIndexedWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headIndexedWord_;
					}
					else
					{
						return headIndexedWordBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHeadIndexedWord(CoreNLPProtos.IndexedWord value)
				{
					if (headIndexedWordBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						headIndexedWord_ = value;
						OnChanged();
					}
					else
					{
						headIndexedWordBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x10000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHeadIndexedWord(CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (headIndexedWordBuilder_ == null)
					{
						headIndexedWord_ = ((CoreNLPProtos.IndexedWord)builderForValue.Build());
						OnChanged();
					}
					else
					{
						headIndexedWordBuilder_.SetMessage(((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x10000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public CoreNLPProtos.Mention.Builder MergeHeadIndexedWord(CoreNLPProtos.IndexedWord value)
				{
					if (headIndexedWordBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x10000000))) == unchecked((int)(0x10000000))) && headIndexedWord_ != null && headIndexedWord_ != CoreNLPProtos.IndexedWord.GetDefaultInstance())
						{
							headIndexedWord_ = ((CoreNLPProtos.IndexedWord)CoreNLPProtos.IndexedWord.NewBuilder(headIndexedWord_).MergeFrom(value).BuildPartial());
						}
						else
						{
							headIndexedWord_ = value;
						}
						OnChanged();
					}
					else
					{
						headIndexedWordBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x10000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHeadIndexedWord()
				{
					if (headIndexedWordBuilder_ == null)
					{
						headIndexedWord_ = null;
						OnChanged();
					}
					else
					{
						headIndexedWordBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x10000000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder GetHeadIndexedWordBuilder()
				{
					bitField0_ |= unchecked((int)(0x10000000));
					OnChanged();
					return GetHeadIndexedWordFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				public CoreNLPProtos.IIndexedWordOrBuilder GetHeadIndexedWordOrBuilder()
				{
					if (headIndexedWordBuilder_ != null)
					{
						return headIndexedWordBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return headIndexedWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headIndexedWord_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> GetHeadIndexedWordFieldBuilder()
				{
					if (headIndexedWordBuilder_ == null)
					{
						headIndexedWordBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder>(GetHeadIndexedWord(), GetParentForChildren(), IsClean());
						headIndexedWord_ = null;
					}
					return headIndexedWordBuilder_;
				}

				private CoreNLPProtos.IndexedWord dependingVerb_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> dependingVerbBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public bool HasDependingVerb()
				{
					return ((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public CoreNLPProtos.IndexedWord GetDependingVerb()
				{
					if (dependingVerbBuilder_ == null)
					{
						return dependingVerb_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : dependingVerb_;
					}
					else
					{
						return dependingVerbBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public CoreNLPProtos.Mention.Builder SetDependingVerb(CoreNLPProtos.IndexedWord value)
				{
					if (dependingVerbBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						dependingVerb_ = value;
						OnChanged();
					}
					else
					{
						dependingVerbBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x20000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public CoreNLPProtos.Mention.Builder SetDependingVerb(CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (dependingVerbBuilder_ == null)
					{
						dependingVerb_ = ((CoreNLPProtos.IndexedWord)builderForValue.Build());
						OnChanged();
					}
					else
					{
						dependingVerbBuilder_.SetMessage(((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x20000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public CoreNLPProtos.Mention.Builder MergeDependingVerb(CoreNLPProtos.IndexedWord value)
				{
					if (dependingVerbBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x20000000))) == unchecked((int)(0x20000000))) && dependingVerb_ != null && dependingVerb_ != CoreNLPProtos.IndexedWord.GetDefaultInstance())
						{
							dependingVerb_ = ((CoreNLPProtos.IndexedWord)CoreNLPProtos.IndexedWord.NewBuilder(dependingVerb_).MergeFrom(value).BuildPartial());
						}
						else
						{
							dependingVerb_ = value;
						}
						OnChanged();
					}
					else
					{
						dependingVerbBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x20000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearDependingVerb()
				{
					if (dependingVerbBuilder_ == null)
					{
						dependingVerb_ = null;
						OnChanged();
					}
					else
					{
						dependingVerbBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x20000000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder GetDependingVerbBuilder()
				{
					bitField0_ |= unchecked((int)(0x20000000));
					OnChanged();
					return GetDependingVerbFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				public CoreNLPProtos.IIndexedWordOrBuilder GetDependingVerbOrBuilder()
				{
					if (dependingVerbBuilder_ != null)
					{
						return dependingVerbBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return dependingVerb_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : dependingVerb_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> GetDependingVerbFieldBuilder()
				{
					if (dependingVerbBuilder_ == null)
					{
						dependingVerbBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder>(GetDependingVerb(), GetParentForChildren(), IsClean());
						dependingVerb_ = null;
					}
					return dependingVerbBuilder_;
				}

				private CoreNLPProtos.IndexedWord headWord_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> headWordBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public bool HasHeadWord()
				{
					return ((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public CoreNLPProtos.IndexedWord GetHeadWord()
				{
					if (headWordBuilder_ == null)
					{
						return headWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headWord_;
					}
					else
					{
						return headWordBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHeadWord(CoreNLPProtos.IndexedWord value)
				{
					if (headWordBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						headWord_ = value;
						OnChanged();
					}
					else
					{
						headWordBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x40000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public CoreNLPProtos.Mention.Builder SetHeadWord(CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (headWordBuilder_ == null)
					{
						headWord_ = ((CoreNLPProtos.IndexedWord)builderForValue.Build());
						OnChanged();
					}
					else
					{
						headWordBuilder_.SetMessage(((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x40000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public CoreNLPProtos.Mention.Builder MergeHeadWord(CoreNLPProtos.IndexedWord value)
				{
					if (headWordBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x40000000))) == unchecked((int)(0x40000000))) && headWord_ != null && headWord_ != CoreNLPProtos.IndexedWord.GetDefaultInstance())
						{
							headWord_ = ((CoreNLPProtos.IndexedWord)CoreNLPProtos.IndexedWord.NewBuilder(headWord_).MergeFrom(value).BuildPartial());
						}
						else
						{
							headWord_ = value;
						}
						OnChanged();
					}
					else
					{
						headWordBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x40000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearHeadWord()
				{
					if (headWordBuilder_ == null)
					{
						headWord_ = null;
						OnChanged();
					}
					else
					{
						headWordBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x40000000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder GetHeadWordBuilder()
				{
					bitField0_ |= unchecked((int)(0x40000000));
					OnChanged();
					return GetHeadWordFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				public CoreNLPProtos.IIndexedWordOrBuilder GetHeadWordOrBuilder()
				{
					if (headWordBuilder_ != null)
					{
						return headWordBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return headWord_ == null ? CoreNLPProtos.IndexedWord.GetDefaultInstance() : headWord_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> GetHeadWordFieldBuilder()
				{
					if (headWordBuilder_ == null)
					{
						headWordBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder>(GetHeadWord(), GetParentForChildren(), IsClean());
						headWord_ = null;
					}
					return headWordBuilder_;
				}

				private CoreNLPProtos.SpeakerInfo speakerInfo_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.SpeakerInfo, CoreNLPProtos.SpeakerInfo.Builder, CoreNLPProtos.ISpeakerInfoOrBuilder> speakerInfoBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public bool HasSpeakerInfo()
				{
					return ((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public CoreNLPProtos.SpeakerInfo GetSpeakerInfo()
				{
					if (speakerInfoBuilder_ == null)
					{
						return speakerInfo_ == null ? CoreNLPProtos.SpeakerInfo.GetDefaultInstance() : speakerInfo_;
					}
					else
					{
						return speakerInfoBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public CoreNLPProtos.Mention.Builder SetSpeakerInfo(CoreNLPProtos.SpeakerInfo value)
				{
					if (speakerInfoBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						speakerInfo_ = value;
						OnChanged();
					}
					else
					{
						speakerInfoBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x80000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public CoreNLPProtos.Mention.Builder SetSpeakerInfo(CoreNLPProtos.SpeakerInfo.Builder builderForValue)
				{
					if (speakerInfoBuilder_ == null)
					{
						speakerInfo_ = ((CoreNLPProtos.SpeakerInfo)builderForValue.Build());
						OnChanged();
					}
					else
					{
						speakerInfoBuilder_.SetMessage(((CoreNLPProtos.SpeakerInfo)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x80000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public CoreNLPProtos.Mention.Builder MergeSpeakerInfo(CoreNLPProtos.SpeakerInfo value)
				{
					if (speakerInfoBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x80000000))) == unchecked((int)(0x80000000))) && speakerInfo_ != null && speakerInfo_ != CoreNLPProtos.SpeakerInfo.GetDefaultInstance())
						{
							speakerInfo_ = ((CoreNLPProtos.SpeakerInfo)CoreNLPProtos.SpeakerInfo.NewBuilder(speakerInfo_).MergeFrom(value).BuildPartial());
						}
						else
						{
							speakerInfo_ = value;
						}
						OnChanged();
					}
					else
					{
						speakerInfoBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x80000000));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearSpeakerInfo()
				{
					if (speakerInfoBuilder_ == null)
					{
						speakerInfo_ = null;
						OnChanged();
					}
					else
					{
						speakerInfoBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x80000000)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder GetSpeakerInfoBuilder()
				{
					bitField0_ |= unchecked((int)(0x80000000));
					OnChanged();
					return GetSpeakerInfoFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				public CoreNLPProtos.ISpeakerInfoOrBuilder GetSpeakerInfoOrBuilder()
				{
					if (speakerInfoBuilder_ != null)
					{
						return speakerInfoBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return speakerInfo_ == null ? CoreNLPProtos.SpeakerInfo.GetDefaultInstance() : speakerInfo_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.SpeakerInfo, CoreNLPProtos.SpeakerInfo.Builder, CoreNLPProtos.ISpeakerInfoOrBuilder> GetSpeakerInfoFieldBuilder()
				{
					if (speakerInfoBuilder_ == null)
					{
						speakerInfoBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.SpeakerInfo, CoreNLPProtos.SpeakerInfo.Builder, CoreNLPProtos.ISpeakerInfoOrBuilder>(GetSpeakerInfo(), GetParentForChildren(), IsClean());
						speakerInfo_ = null;
					}
					return speakerInfoBuilder_;
				}

				private IList<CoreNLPProtos.IndexedWord> sentenceWords_ = Java.Util.Collections.EmptyList();

				private void EnsureSentenceWordsIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						sentenceWords_ = new List<CoreNLPProtos.IndexedWord>(sentenceWords_);
						bitField1_ |= unchecked((int)(0x00000001));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> sentenceWordsBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public IList<CoreNLPProtos.IndexedWord> GetSentenceWordsList()
				{
					if (sentenceWordsBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(sentenceWords_);
					}
					else
					{
						return sentenceWordsBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public int GetSentenceWordsCount()
				{
					if (sentenceWordsBuilder_ == null)
					{
						return sentenceWords_.Count;
					}
					else
					{
						return sentenceWordsBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.IndexedWord GetSentenceWords(int index)
				{
					if (sentenceWordsBuilder_ == null)
					{
						return sentenceWords_[index];
					}
					else
					{
						return sentenceWordsBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder SetSentenceWords(int index, CoreNLPProtos.IndexedWord value)
				{
					if (sentenceWordsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentenceWordsIsMutable();
						sentenceWords_.Set(index, value);
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder SetSentenceWords(int index, CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (sentenceWordsBuilder_ == null)
					{
						EnsureSentenceWordsIsMutable();
						sentenceWords_.Set(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.SetMessage(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder AddSentenceWords(CoreNLPProtos.IndexedWord value)
				{
					if (sentenceWordsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentenceWordsIsMutable();
						sentenceWords_.Add(value);
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder AddSentenceWords(int index, CoreNLPProtos.IndexedWord value)
				{
					if (sentenceWordsBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSentenceWordsIsMutable();
						sentenceWords_.Add(index, value);
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder AddSentenceWords(CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (sentenceWordsBuilder_ == null)
					{
						EnsureSentenceWordsIsMutable();
						sentenceWords_.Add(((CoreNLPProtos.IndexedWord)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.AddMessage(((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder AddSentenceWords(int index, CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (sentenceWordsBuilder_ == null)
					{
						EnsureSentenceWordsIsMutable();
						sentenceWords_.Add(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.AddMessage(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllSentenceWords<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.IndexedWord
				{
					if (sentenceWordsBuilder_ == null)
					{
						EnsureSentenceWordsIsMutable();
						AbstractMessageLite.Builder.AddAll(values, sentenceWords_);
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearSentenceWords()
				{
					if (sentenceWordsBuilder_ == null)
					{
						sentenceWords_ = Java.Util.Collections.EmptyList();
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000001)));
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.Mention.Builder RemoveSentenceWords(int index)
				{
					if (sentenceWordsBuilder_ == null)
					{
						EnsureSentenceWordsIsMutable();
						sentenceWords_.Remove(index);
						OnChanged();
					}
					else
					{
						sentenceWordsBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder GetSentenceWordsBuilder(int index)
				{
					return GetSentenceWordsFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.IIndexedWordOrBuilder GetSentenceWordsOrBuilder(int index)
				{
					if (sentenceWordsBuilder_ == null)
					{
						return sentenceWords_[index];
					}
					else
					{
						return sentenceWordsBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public IList<CoreNLPProtos.IIndexedWordOrBuilder> GetSentenceWordsOrBuilderList()
				{
					if (sentenceWordsBuilder_ != null)
					{
						return sentenceWordsBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(sentenceWords_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder AddSentenceWordsBuilder()
				{
					return GetSentenceWordsFieldBuilder().AddBuilder(CoreNLPProtos.IndexedWord.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder AddSentenceWordsBuilder(int index)
				{
					return GetSentenceWordsFieldBuilder().AddBuilder(index, CoreNLPProtos.IndexedWord.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;</code></summary>
				public IList<CoreNLPProtos.IndexedWord.Builder> GetSentenceWordsBuilderList()
				{
					return GetSentenceWordsFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> GetSentenceWordsFieldBuilder()
				{
					if (sentenceWordsBuilder_ == null)
					{
						sentenceWordsBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder>(sentenceWords_, ((bitField1_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)
							)), GetParentForChildren(), IsClean());
						sentenceWords_ = null;
					}
					return sentenceWordsBuilder_;
				}

				private IList<CoreNLPProtos.IndexedWord> originalSpan_ = Java.Util.Collections.EmptyList();

				private void EnsureOriginalSpanIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						originalSpan_ = new List<CoreNLPProtos.IndexedWord>(originalSpan_);
						bitField1_ |= unchecked((int)(0x00000002));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> originalSpanBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public IList<CoreNLPProtos.IndexedWord> GetOriginalSpanList()
				{
					if (originalSpanBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(originalSpan_);
					}
					else
					{
						return originalSpanBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public int GetOriginalSpanCount()
				{
					if (originalSpanBuilder_ == null)
					{
						return originalSpan_.Count;
					}
					else
					{
						return originalSpanBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.IndexedWord GetOriginalSpan(int index)
				{
					if (originalSpanBuilder_ == null)
					{
						return originalSpan_[index];
					}
					else
					{
						return originalSpanBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder SetOriginalSpan(int index, CoreNLPProtos.IndexedWord value)
				{
					if (originalSpanBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureOriginalSpanIsMutable();
						originalSpan_.Set(index, value);
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder SetOriginalSpan(int index, CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (originalSpanBuilder_ == null)
					{
						EnsureOriginalSpanIsMutable();
						originalSpan_.Set(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.SetMessage(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder AddOriginalSpan(CoreNLPProtos.IndexedWord value)
				{
					if (originalSpanBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureOriginalSpanIsMutable();
						originalSpan_.Add(value);
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder AddOriginalSpan(int index, CoreNLPProtos.IndexedWord value)
				{
					if (originalSpanBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureOriginalSpanIsMutable();
						originalSpan_.Add(index, value);
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder AddOriginalSpan(CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (originalSpanBuilder_ == null)
					{
						EnsureOriginalSpanIsMutable();
						originalSpan_.Add(((CoreNLPProtos.IndexedWord)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.AddMessage(((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder AddOriginalSpan(int index, CoreNLPProtos.IndexedWord.Builder builderForValue)
				{
					if (originalSpanBuilder_ == null)
					{
						EnsureOriginalSpanIsMutable();
						originalSpan_.Add(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.AddMessage(index, ((CoreNLPProtos.IndexedWord)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllOriginalSpan<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.IndexedWord
				{
					if (originalSpanBuilder_ == null)
					{
						EnsureOriginalSpanIsMutable();
						AbstractMessageLite.Builder.AddAll(values, originalSpan_);
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearOriginalSpan()
				{
					if (originalSpanBuilder_ == null)
					{
						originalSpan_ = Java.Util.Collections.EmptyList();
						bitField1_ = (bitField1_ & ~unchecked((int)(0x00000002)));
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.Mention.Builder RemoveOriginalSpan(int index)
				{
					if (originalSpanBuilder_ == null)
					{
						EnsureOriginalSpanIsMutable();
						originalSpan_.Remove(index);
						OnChanged();
					}
					else
					{
						originalSpanBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder GetOriginalSpanBuilder(int index)
				{
					return GetOriginalSpanFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.IIndexedWordOrBuilder GetOriginalSpanOrBuilder(int index)
				{
					if (originalSpanBuilder_ == null)
					{
						return originalSpan_[index];
					}
					else
					{
						return originalSpanBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public IList<CoreNLPProtos.IIndexedWordOrBuilder> GetOriginalSpanOrBuilderList()
				{
					if (originalSpanBuilder_ != null)
					{
						return originalSpanBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(originalSpan_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder AddOriginalSpanBuilder()
				{
					return GetOriginalSpanFieldBuilder().AddBuilder(CoreNLPProtos.IndexedWord.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder AddOriginalSpanBuilder(int index)
				{
					return GetOriginalSpanFieldBuilder().AddBuilder(index, CoreNLPProtos.IndexedWord.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;</code></summary>
				public IList<CoreNLPProtos.IndexedWord.Builder> GetOriginalSpanBuilderList()
				{
					return GetOriginalSpanFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder> GetOriginalSpanFieldBuilder()
				{
					if (originalSpanBuilder_ == null)
					{
						originalSpanBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.IndexedWord, CoreNLPProtos.IndexedWord.Builder, CoreNLPProtos.IIndexedWordOrBuilder>(originalSpan_, ((bitField1_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)))
							, GetParentForChildren(), IsClean());
						originalSpan_ = null;
					}
					return originalSpanBuilder_;
				}

				private ILazyStringList dependents_ = LazyStringArrayList.Empty;

				private void EnsureDependentsIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						dependents_ = new LazyStringArrayList(dependents_);
						bitField1_ |= unchecked((int)(0x00000004));
					}
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public IProtocolStringList GetDependentsList()
				{
					return dependents_.GetUnmodifiableView();
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public int GetDependentsCount()
				{
					return dependents_.Count;
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public string GetDependents(int index)
				{
					return dependents_[index];
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public ByteString GetDependentsBytes(int index)
				{
					return dependents_.GetByteString(index);
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public CoreNLPProtos.Mention.Builder SetDependents(int index, string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureDependentsIsMutable();
					dependents_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public CoreNLPProtos.Mention.Builder AddDependents(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureDependentsIsMutable();
					dependents_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllDependents(IEnumerable<string> values)
				{
					EnsureDependentsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, dependents_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearDependents()
				{
					dependents_ = LazyStringArrayList.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000004)));
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string dependents = 52;</code></summary>
				public CoreNLPProtos.Mention.Builder AddDependentsBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureDependentsIsMutable();
					dependents_.Add(value);
					OnChanged();
					return this;
				}

				private ILazyStringList preprocessedTerms_ = LazyStringArrayList.Empty;

				private void EnsurePreprocessedTermsIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						preprocessedTerms_ = new LazyStringArrayList(preprocessedTerms_);
						bitField1_ |= unchecked((int)(0x00000008));
					}
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public IProtocolStringList GetPreprocessedTermsList()
				{
					return preprocessedTerms_.GetUnmodifiableView();
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public int GetPreprocessedTermsCount()
				{
					return preprocessedTerms_.Count;
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public string GetPreprocessedTerms(int index)
				{
					return preprocessedTerms_[index];
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public ByteString GetPreprocessedTermsBytes(int index)
				{
					return preprocessedTerms_.GetByteString(index);
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public CoreNLPProtos.Mention.Builder SetPreprocessedTerms(int index, string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsurePreprocessedTermsIsMutable();
					preprocessedTerms_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public CoreNLPProtos.Mention.Builder AddPreprocessedTerms(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsurePreprocessedTermsIsMutable();
					preprocessedTerms_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllPreprocessedTerms(IEnumerable<string> values)
				{
					EnsurePreprocessedTermsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, preprocessedTerms_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearPreprocessedTerms()
				{
					preprocessedTerms_ = LazyStringArrayList.Empty;
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000008)));
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string preprocessedTerms = 53;</code></summary>
				public CoreNLPProtos.Mention.Builder AddPreprocessedTermsBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsurePreprocessedTermsIsMutable();
					preprocessedTerms_.Add(value);
					OnChanged();
					return this;
				}

				private IList<int> appositions_ = Java.Util.Collections.EmptyList();

				private void EnsureAppositionsIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						appositions_ = new List<int>(appositions_);
						bitField1_ |= unchecked((int)(0x00000010));
					}
				}

				/// <summary><code>repeated int32 appositions = 54;</code></summary>
				public IList<int> GetAppositionsList()
				{
					return Java.Util.Collections.UnmodifiableList(appositions_);
				}

				/// <summary><code>repeated int32 appositions = 54;</code></summary>
				public int GetAppositionsCount()
				{
					return appositions_.Count;
				}

				/// <summary><code>repeated int32 appositions = 54;</code></summary>
				public int GetAppositions(int index)
				{
					return appositions_[index];
				}

				/// <summary><code>repeated int32 appositions = 54;</code></summary>
				public CoreNLPProtos.Mention.Builder SetAppositions(int index, int value)
				{
					EnsureAppositionsIsMutable();
					appositions_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 appositions = 54;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAppositions(int value)
				{
					EnsureAppositionsIsMutable();
					appositions_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 appositions = 54;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllAppositions<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureAppositionsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, appositions_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 appositions = 54;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearAppositions()
				{
					appositions_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000010)));
					OnChanged();
					return this;
				}

				private IList<int> predicateNominatives_ = Java.Util.Collections.EmptyList();

				private void EnsurePredicateNominativesIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						predicateNominatives_ = new List<int>(predicateNominatives_);
						bitField1_ |= unchecked((int)(0x00000020));
					}
				}

				/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
				public IList<int> GetPredicateNominativesList()
				{
					return Java.Util.Collections.UnmodifiableList(predicateNominatives_);
				}

				/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
				public int GetPredicateNominativesCount()
				{
					return predicateNominatives_.Count;
				}

				/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
				public int GetPredicateNominatives(int index)
				{
					return predicateNominatives_[index];
				}

				/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
				public CoreNLPProtos.Mention.Builder SetPredicateNominatives(int index, int value)
				{
					EnsurePredicateNominativesIsMutable();
					predicateNominatives_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
				public CoreNLPProtos.Mention.Builder AddPredicateNominatives(int value)
				{
					EnsurePredicateNominativesIsMutable();
					predicateNominatives_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllPredicateNominatives<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsurePredicateNominativesIsMutable();
					AbstractMessageLite.Builder.AddAll(values, predicateNominatives_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 predicateNominatives = 55;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearPredicateNominatives()
				{
					predicateNominatives_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000020)));
					OnChanged();
					return this;
				}

				private IList<int> relativePronouns_ = Java.Util.Collections.EmptyList();

				private void EnsureRelativePronounsIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						relativePronouns_ = new List<int>(relativePronouns_);
						bitField1_ |= unchecked((int)(0x00000040));
					}
				}

				/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
				public IList<int> GetRelativePronounsList()
				{
					return Java.Util.Collections.UnmodifiableList(relativePronouns_);
				}

				/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
				public int GetRelativePronounsCount()
				{
					return relativePronouns_.Count;
				}

				/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
				public int GetRelativePronouns(int index)
				{
					return relativePronouns_[index];
				}

				/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
				public CoreNLPProtos.Mention.Builder SetRelativePronouns(int index, int value)
				{
					EnsureRelativePronounsIsMutable();
					relativePronouns_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
				public CoreNLPProtos.Mention.Builder AddRelativePronouns(int value)
				{
					EnsureRelativePronounsIsMutable();
					relativePronouns_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllRelativePronouns<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureRelativePronounsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, relativePronouns_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 relativePronouns = 56;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearRelativePronouns()
				{
					relativePronouns_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000040)));
					OnChanged();
					return this;
				}

				private IList<int> listMembers_ = Java.Util.Collections.EmptyList();

				private void EnsureListMembersIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						listMembers_ = new List<int>(listMembers_);
						bitField1_ |= unchecked((int)(0x00000080));
					}
				}

				/// <summary><code>repeated int32 listMembers = 57;</code></summary>
				public IList<int> GetListMembersList()
				{
					return Java.Util.Collections.UnmodifiableList(listMembers_);
				}

				/// <summary><code>repeated int32 listMembers = 57;</code></summary>
				public int GetListMembersCount()
				{
					return listMembers_.Count;
				}

				/// <summary><code>repeated int32 listMembers = 57;</code></summary>
				public int GetListMembers(int index)
				{
					return listMembers_[index];
				}

				/// <summary><code>repeated int32 listMembers = 57;</code></summary>
				public CoreNLPProtos.Mention.Builder SetListMembers(int index, int value)
				{
					EnsureListMembersIsMutable();
					listMembers_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 listMembers = 57;</code></summary>
				public CoreNLPProtos.Mention.Builder AddListMembers(int value)
				{
					EnsureListMembersIsMutable();
					listMembers_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 listMembers = 57;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllListMembers<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureListMembersIsMutable();
					AbstractMessageLite.Builder.AddAll(values, listMembers_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 listMembers = 57;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearListMembers()
				{
					listMembers_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000080)));
					OnChanged();
					return this;
				}

				private IList<int> belongToLists_ = Java.Util.Collections.EmptyList();

				private void EnsureBelongToListsIsMutable()
				{
					if (!((bitField1_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						belongToLists_ = new List<int>(belongToLists_);
						bitField1_ |= unchecked((int)(0x00000100));
					}
				}

				/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
				public IList<int> GetBelongToListsList()
				{
					return Java.Util.Collections.UnmodifiableList(belongToLists_);
				}

				/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
				public int GetBelongToListsCount()
				{
					return belongToLists_.Count;
				}

				/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
				public int GetBelongToLists(int index)
				{
					return belongToLists_[index];
				}

				/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
				public CoreNLPProtos.Mention.Builder SetBelongToLists(int index, int value)
				{
					EnsureBelongToListsIsMutable();
					belongToLists_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
				public CoreNLPProtos.Mention.Builder AddBelongToLists(int value)
				{
					EnsureBelongToListsIsMutable();
					belongToLists_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
				public CoreNLPProtos.Mention.Builder AddAllBelongToLists<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureBelongToListsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, belongToLists_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 belongToLists = 58;</code></summary>
				public CoreNLPProtos.Mention.Builder ClearBelongToLists()
				{
					belongToLists_ = Java.Util.Collections.EmptyList();
					bitField1_ = (bitField1_ & ~unchecked((int)(0x00000100)));
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Mention.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Mention)
			}

			private static readonly CoreNLPProtos.Mention DefaultInstance;

			static Mention()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Mention)
				DefaultInstance = new CoreNLPProtos.Mention();
			}

			public static CoreNLPProtos.Mention GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_41743 : AbstractParser<CoreNLPProtos.Mention>
			{
				public _AbstractParser_41743()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Mention ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Mention(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Mention> Parser = new _AbstractParser_41743();

			public static IParser<CoreNLPProtos.Mention> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IIndexedWordOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.IndexedWord)
			/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
			bool HasSentenceNum();

			/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
			int GetSentenceNum();

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			bool HasTokenIndex();

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			int GetTokenIndex();

			/// <summary><code>optional uint32 docID = 3;</code></summary>
			bool HasDocID();

			/// <summary><code>optional uint32 docID = 3;</code></summary>
			int GetDocID();

			/// <summary><code>optional uint32 copyCount = 4;</code></summary>
			bool HasCopyCount();

			/// <summary><code>optional uint32 copyCount = 4;</code></summary>
			int GetCopyCount();
		}

		/// <summary>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.IndexedWord</c>
		/// </summary>
		[System.Serializable]
		public sealed class IndexedWord : GeneratedMessageV3, CoreNLPProtos.IIndexedWordOrBuilder
		{
			private IndexedWord(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private IndexedWord()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.IndexedWord)
				// Use IndexedWord.newBuilder() to construct.
				sentenceNum_ = 0;
				tokenIndex_ = 0;
				docID_ = 0;
				copyCount_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private IndexedWord(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								sentenceNum_ = input.ReadUInt32();
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								tokenIndex_ = input.ReadUInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								docID_ = input.ReadUInt32();
								break;
							}

							case 32:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								copyCount_ = input.ReadUInt32();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_IndexedWord_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_IndexedWord_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.IndexedWord), typeof(CoreNLPProtos.IndexedWord.Builder));
			}

			private int bitField0_;

			public const int SentencenumFieldNumber = 1;

			private int sentenceNum_;

			/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
			public bool HasSentenceNum()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
			public int GetSentenceNum()
			{
				return sentenceNum_;
			}

			public const int TokenindexFieldNumber = 2;

			private int tokenIndex_;

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			public bool HasTokenIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			public int GetTokenIndex()
			{
				return tokenIndex_;
			}

			public const int DocidFieldNumber = 3;

			private int docID_;

			/// <summary><code>optional uint32 docID = 3;</code></summary>
			public bool HasDocID()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional uint32 docID = 3;</code></summary>
			public int GetDocID()
			{
				return docID_;
			}

			public const int CopycountFieldNumber = 4;

			private int copyCount_;

			/// <summary><code>optional uint32 copyCount = 4;</code></summary>
			public bool HasCopyCount()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional uint32 copyCount = 4;</code></summary>
			public int GetCopyCount()
			{
				return copyCount_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(1, sentenceNum_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(2, tokenIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteUInt32(3, docID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteUInt32(4, copyCount_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(1, sentenceNum_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, tokenIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, docID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeUInt32Size(4, copyCount_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.IndexedWord))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.IndexedWord other = (CoreNLPProtos.IndexedWord)obj;
				bool result = true;
				result = result && (HasSentenceNum() == other.HasSentenceNum());
				if (HasSentenceNum())
				{
					result = result && (GetSentenceNum() == other.GetSentenceNum());
				}
				result = result && (HasTokenIndex() == other.HasTokenIndex());
				if (HasTokenIndex())
				{
					result = result && (GetTokenIndex() == other.GetTokenIndex());
				}
				result = result && (HasDocID() == other.HasDocID());
				if (HasDocID())
				{
					result = result && (GetDocID() == other.GetDocID());
				}
				result = result && (HasCopyCount() == other.HasCopyCount());
				if (HasCopyCount())
				{
					result = result && (GetCopyCount() == other.GetCopyCount());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasSentenceNum())
				{
					hash = (37 * hash) + SentencenumFieldNumber;
					hash = (53 * hash) + GetSentenceNum();
				}
				if (HasTokenIndex())
				{
					hash = (37 * hash) + TokenindexFieldNumber;
					hash = (53 * hash) + GetTokenIndex();
				}
				if (HasDocID())
				{
					hash = (37 * hash) + DocidFieldNumber;
					hash = (53 * hash) + GetDocID();
				}
				if (HasCopyCount())
				{
					hash = (37 * hash) + CopycountFieldNumber;
					hash = (53 * hash) + GetCopyCount();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.IndexedWord ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.IndexedWord ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.IndexedWord ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.IndexedWord.Builder NewBuilder()
			{
				return ((CoreNLPProtos.IndexedWord.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.IndexedWord.Builder NewBuilder(CoreNLPProtos.IndexedWord prototype)
			{
				return ((CoreNLPProtos.IndexedWord.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.IndexedWord.Builder() : new CoreNLPProtos.IndexedWord.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.IndexedWord.Builder builder = new CoreNLPProtos.IndexedWord.Builder(parent);
				return builder;
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.IndexedWord</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.IndexedWord.Builder>, CoreNLPProtos.IIndexedWordOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.IndexedWord)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_IndexedWord_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_IndexedWord_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.IndexedWord), typeof(CoreNLPProtos.IndexedWord.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.IndexedWord.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					sentenceNum_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					tokenIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					docID_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					copyCount_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_IndexedWord_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.IndexedWord.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.IndexedWord result = ((CoreNLPProtos.IndexedWord)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.IndexedWord result = new CoreNLPProtos.IndexedWord(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.sentenceNum_ = sentenceNum_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.tokenIndex_ = tokenIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.docID_ = docID_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.copyCount_ = copyCount_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.IndexedWord.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.IndexedWord.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.IndexedWord.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.IndexedWord.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.IndexedWord.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.IndexedWord.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.IndexedWord.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.IndexedWord.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.IndexedWord)
					{
						return MergeFrom((CoreNLPProtos.IndexedWord)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.IndexedWord.Builder MergeFrom(CoreNLPProtos.IndexedWord other)
				{
					if (other == CoreNLPProtos.IndexedWord.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasSentenceNum())
					{
						SetSentenceNum(other.GetSentenceNum());
					}
					if (other.HasTokenIndex())
					{
						SetTokenIndex(other.GetTokenIndex());
					}
					if (other.HasDocID())
					{
						SetDocID(other.GetDocID());
					}
					if (other.HasCopyCount())
					{
						SetCopyCount(other.GetCopyCount());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.IndexedWord parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.IndexedWord)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int sentenceNum_;

				/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
				public bool HasSentenceNum()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
				public int GetSentenceNum()
				{
					return sentenceNum_;
				}

				/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder SetSentenceNum(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					sentenceNum_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 sentenceNum = 1;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder ClearSentenceNum()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					sentenceNum_ = 0;
					OnChanged();
					return this;
				}

				private int tokenIndex_;

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public bool HasTokenIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public int GetTokenIndex()
				{
					return tokenIndex_;
				}

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder SetTokenIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					tokenIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder ClearTokenIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					tokenIndex_ = 0;
					OnChanged();
					return this;
				}

				private int docID_;

				/// <summary><code>optional uint32 docID = 3;</code></summary>
				public bool HasDocID()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional uint32 docID = 3;</code></summary>
				public int GetDocID()
				{
					return docID_;
				}

				/// <summary><code>optional uint32 docID = 3;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder SetDocID(int value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					docID_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 docID = 3;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder ClearDocID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					docID_ = 0;
					OnChanged();
					return this;
				}

				private int copyCount_;

				/// <summary><code>optional uint32 copyCount = 4;</code></summary>
				public bool HasCopyCount()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional uint32 copyCount = 4;</code></summary>
				public int GetCopyCount()
				{
					return copyCount_;
				}

				/// <summary><code>optional uint32 copyCount = 4;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder SetCopyCount(int value)
				{
					bitField0_ |= unchecked((int)(0x00000008));
					copyCount_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 copyCount = 4;</code></summary>
				public CoreNLPProtos.IndexedWord.Builder ClearCopyCount()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					copyCount_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.IndexedWord.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.IndexedWord)
			}

			private static readonly CoreNLPProtos.IndexedWord DefaultInstance;

			static IndexedWord()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.IndexedWord)
				DefaultInstance = new CoreNLPProtos.IndexedWord();
			}

			public static CoreNLPProtos.IndexedWord GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_42470 : AbstractParser<CoreNLPProtos.IndexedWord>
			{
				public _AbstractParser_42470()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.IndexedWord ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.IndexedWord(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.IndexedWord> Parser = new _AbstractParser_42470();

			public static IParser<CoreNLPProtos.IndexedWord> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ISpeakerInfoOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.SpeakerInfo)
			/// <summary><code>optional string speakerName = 1;</code></summary>
			bool HasSpeakerName();

			/// <summary><code>optional string speakerName = 1;</code></summary>
			string GetSpeakerName();

			/// <summary><code>optional string speakerName = 1;</code></summary>
			ByteString GetSpeakerNameBytes();

			/// <summary><code>repeated int32 mentions = 2;</code></summary>
			IList<int> GetMentionsList();

			/// <summary><code>repeated int32 mentions = 2;</code></summary>
			int GetMentionsCount();

			/// <summary><code>repeated int32 mentions = 2;</code></summary>
			int GetMentions(int index);
		}

		/// <summary>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.SpeakerInfo</c>
		/// </summary>
		[System.Serializable]
		public sealed class SpeakerInfo : GeneratedMessageV3, CoreNLPProtos.ISpeakerInfoOrBuilder
		{
			private SpeakerInfo(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private SpeakerInfo()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.SpeakerInfo)
				// Use SpeakerInfo.newBuilder() to construct.
				speakerName_ = string.Empty;
				mentions_ = Java.Util.Collections.EmptyList();
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private SpeakerInfo(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								speakerName_ = bs;
								break;
							}

							case 16:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									mentions_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								mentions_.Add(input.ReadInt32());
								break;
							}

							case 18:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))) && input.GetBytesUntilLimit() > 0)
								{
									mentions_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									mentions_.Add(input.ReadInt32());
								}
								input.PopLimit(limit);
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						mentions_ = Java.Util.Collections.UnmodifiableList(mentions_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.SpeakerInfo), typeof(CoreNLPProtos.SpeakerInfo.Builder));
			}

			private int bitField0_;

			public const int SpeakernameFieldNumber = 1;

			private volatile object speakerName_;

			/// <summary><code>optional string speakerName = 1;</code></summary>
			public bool HasSpeakerName()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional string speakerName = 1;</code></summary>
			public string GetSpeakerName()
			{
				object @ref = speakerName_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						speakerName_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string speakerName = 1;</code></summary>
			public ByteString GetSpeakerNameBytes()
			{
				object @ref = speakerName_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					speakerName_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int MentionsFieldNumber = 2;

			private IList<int> mentions_;

			/// <summary><code>repeated int32 mentions = 2;</code></summary>
			public IList<int> GetMentionsList()
			{
				return mentions_;
			}

			/// <summary><code>repeated int32 mentions = 2;</code></summary>
			public int GetMentionsCount()
			{
				return mentions_.Count;
			}

			/// <summary><code>repeated int32 mentions = 2;</code></summary>
			public int GetMentions(int index)
			{
				return mentions_[index];
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 1, speakerName_);
				}
				for (int i = 0; i < mentions_.Count; i++)
				{
					output.WriteInt32(2, mentions_[i]);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, speakerName_);
				}
				{
					int dataSize = 0;
					for (int i = 0; i < mentions_.Count; i++)
					{
						dataSize += CodedOutputStream.ComputeInt32SizeNoTag(mentions_[i]);
					}
					size += dataSize;
					size += 1 * GetMentionsList().Count;
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.SpeakerInfo))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.SpeakerInfo other = (CoreNLPProtos.SpeakerInfo)obj;
				bool result = true;
				result = result && (HasSpeakerName() == other.HasSpeakerName());
				if (HasSpeakerName())
				{
					result = result && GetSpeakerName().Equals(other.GetSpeakerName());
				}
				result = result && GetMentionsList().Equals(other.GetMentionsList());
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasSpeakerName())
				{
					hash = (37 * hash) + SpeakernameFieldNumber;
					hash = (53 * hash) + GetSpeakerName().GetHashCode();
				}
				if (GetMentionsCount() > 0)
				{
					hash = (37 * hash) + MentionsFieldNumber;
					hash = (53 * hash) + GetMentionsList().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SpeakerInfo ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SpeakerInfo ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SpeakerInfo ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.SpeakerInfo.Builder NewBuilder()
			{
				return ((CoreNLPProtos.SpeakerInfo.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.SpeakerInfo.Builder NewBuilder(CoreNLPProtos.SpeakerInfo prototype)
			{
				return ((CoreNLPProtos.SpeakerInfo.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.SpeakerInfo.Builder() : new CoreNLPProtos.SpeakerInfo.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.SpeakerInfo.Builder builder = new CoreNLPProtos.SpeakerInfo.Builder(parent);
				return builder;
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.SpeakerInfo</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.SpeakerInfo.Builder>, CoreNLPProtos.ISpeakerInfoOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.SpeakerInfo)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.SpeakerInfo), typeof(CoreNLPProtos.SpeakerInfo.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.SpeakerInfo.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					speakerName_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					mentions_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.SpeakerInfo.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.SpeakerInfo result = ((CoreNLPProtos.SpeakerInfo)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.SpeakerInfo result = new CoreNLPProtos.SpeakerInfo(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.speakerName_ = speakerName_;
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						mentions_ = Java.Util.Collections.UnmodifiableList(mentions_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					result.mentions_ = mentions_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.SpeakerInfo.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.SpeakerInfo.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.SpeakerInfo.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.SpeakerInfo.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.SpeakerInfo.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.SpeakerInfo.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.SpeakerInfo.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.SpeakerInfo.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.SpeakerInfo)
					{
						return MergeFrom((CoreNLPProtos.SpeakerInfo)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.SpeakerInfo.Builder MergeFrom(CoreNLPProtos.SpeakerInfo other)
				{
					if (other == CoreNLPProtos.SpeakerInfo.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasSpeakerName())
					{
						bitField0_ |= unchecked((int)(0x00000001));
						speakerName_ = other.speakerName_;
						OnChanged();
					}
					if (!other.mentions_.IsEmpty())
					{
						if (mentions_.IsEmpty())
						{
							mentions_ = other.mentions_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						else
						{
							EnsureMentionsIsMutable();
							Sharpen.Collections.AddAll(mentions_, other.mentions_);
						}
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.SpeakerInfo parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.SpeakerInfo)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private object speakerName_ = string.Empty;

				/// <summary><code>optional string speakerName = 1;</code></summary>
				public bool HasSpeakerName()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional string speakerName = 1;</code></summary>
				public string GetSpeakerName()
				{
					object @ref = speakerName_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							speakerName_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string speakerName = 1;</code></summary>
				public ByteString GetSpeakerNameBytes()
				{
					object @ref = speakerName_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						speakerName_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string speakerName = 1;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder SetSpeakerName(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					speakerName_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string speakerName = 1;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder ClearSpeakerName()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					speakerName_ = GetDefaultInstance().GetSpeakerName();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string speakerName = 1;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder SetSpeakerNameBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					speakerName_ = value;
					OnChanged();
					return this;
				}

				private IList<int> mentions_ = Java.Util.Collections.EmptyList();

				private void EnsureMentionsIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						mentions_ = new List<int>(mentions_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				/// <summary><code>repeated int32 mentions = 2;</code></summary>
				public IList<int> GetMentionsList()
				{
					return Java.Util.Collections.UnmodifiableList(mentions_);
				}

				/// <summary><code>repeated int32 mentions = 2;</code></summary>
				public int GetMentionsCount()
				{
					return mentions_.Count;
				}

				/// <summary><code>repeated int32 mentions = 2;</code></summary>
				public int GetMentions(int index)
				{
					return mentions_[index];
				}

				/// <summary><code>repeated int32 mentions = 2;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder SetMentions(int index, int value)
				{
					EnsureMentionsIsMutable();
					mentions_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 mentions = 2;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder AddMentions(int value)
				{
					EnsureMentionsIsMutable();
					mentions_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 mentions = 2;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder AddAllMentions<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureMentionsIsMutable();
					AbstractMessageLite.Builder.AddAll(values, mentions_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated int32 mentions = 2;</code></summary>
				public CoreNLPProtos.SpeakerInfo.Builder ClearMentions()
				{
					mentions_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.SpeakerInfo.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.SpeakerInfo)
			}

			private static readonly CoreNLPProtos.SpeakerInfo DefaultInstance;

			static SpeakerInfo()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.SpeakerInfo)
				DefaultInstance = new CoreNLPProtos.SpeakerInfo();
			}

			public static CoreNLPProtos.SpeakerInfo GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_43175 : AbstractParser<CoreNLPProtos.SpeakerInfo>
			{
				public _AbstractParser_43175()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.SpeakerInfo ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.SpeakerInfo(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.SpeakerInfo> Parser = new _AbstractParser_43175();

			public static IParser<CoreNLPProtos.SpeakerInfo> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ISpanOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Span)
			/// <summary><code>required uint32 begin = 1;</code></summary>
			bool HasBegin();

			/// <summary><code>required uint32 begin = 1;</code></summary>
			int GetBegin();

			/// <summary><code>required uint32 end = 2;</code></summary>
			bool HasEnd();

			/// <summary><code>required uint32 end = 2;</code></summary>
			int GetEnd();
		}

		/// <summary>
		/// <pre>
		/// A Span of text
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Span</c>
		/// </summary>
		[System.Serializable]
		public sealed class Span : GeneratedMessageV3, CoreNLPProtos.ISpanOrBuilder
		{
			private Span(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Span()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Span)
				// Use Span.newBuilder() to construct.
				begin_ = 0;
				end_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Span(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								begin_ = input.ReadUInt32();
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								end_ = input.ReadUInt32();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Span_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Span_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Span), typeof(CoreNLPProtos.Span.Builder));
			}

			private int bitField0_;

			public const int BeginFieldNumber = 1;

			private int begin_;

			/// <summary><code>required uint32 begin = 1;</code></summary>
			public bool HasBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>required uint32 begin = 1;</code></summary>
			public int GetBegin()
			{
				return begin_;
			}

			public const int EndFieldNumber = 2;

			private int end_;

			/// <summary><code>required uint32 end = 2;</code></summary>
			public bool HasEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>required uint32 end = 2;</code></summary>
			public int GetEnd()
			{
				return end_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasBegin())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasEnd())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(1, begin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(2, end_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(1, begin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, end_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Span))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Span other = (CoreNLPProtos.Span)obj;
				bool result = true;
				result = result && (HasBegin() == other.HasBegin());
				if (HasBegin())
				{
					result = result && (GetBegin() == other.GetBegin());
				}
				result = result && (HasEnd() == other.HasEnd());
				if (HasEnd())
				{
					result = result && (GetEnd() == other.GetEnd());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasBegin())
				{
					hash = (37 * hash) + BeginFieldNumber;
					hash = (53 * hash) + GetBegin();
				}
				if (HasEnd())
				{
					hash = (37 * hash) + EndFieldNumber;
					hash = (53 * hash) + GetEnd();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Span ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Span ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Span ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Span ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Span ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Span ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Span ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Span ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Span ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Span ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Span.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Span.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Span.Builder NewBuilder(CoreNLPProtos.Span prototype)
			{
				return ((CoreNLPProtos.Span.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Span.Builder() : new CoreNLPProtos.Span.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Span.Builder builder = new CoreNLPProtos.Span.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A Span of text
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Span</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Span.Builder>, CoreNLPProtos.ISpanOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Span)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Span_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Span_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Span), typeof(CoreNLPProtos.Span.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Span.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					begin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					end_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Span_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Span.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Span result = ((CoreNLPProtos.Span)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Span result = new CoreNLPProtos.Span(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.begin_ = begin_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.end_ = end_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Span.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Span.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Span.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Span.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Span.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Span.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Span.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Span.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Span)
					{
						return MergeFrom((CoreNLPProtos.Span)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Span.Builder MergeFrom(CoreNLPProtos.Span other)
				{
					if (other == CoreNLPProtos.Span.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasBegin())
					{
						SetBegin(other.GetBegin());
					}
					if (other.HasEnd())
					{
						SetEnd(other.GetEnd());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasBegin())
					{
						return false;
					}
					if (!HasEnd())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Span parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Span)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int begin_;

				/// <summary><code>required uint32 begin = 1;</code></summary>
				public bool HasBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required uint32 begin = 1;</code></summary>
				public int GetBegin()
				{
					return begin_;
				}

				/// <summary><code>required uint32 begin = 1;</code></summary>
				public CoreNLPProtos.Span.Builder SetBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					begin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 begin = 1;</code></summary>
				public CoreNLPProtos.Span.Builder ClearBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					begin_ = 0;
					OnChanged();
					return this;
				}

				private int end_;

				/// <summary><code>required uint32 end = 2;</code></summary>
				public bool HasEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required uint32 end = 2;</code></summary>
				public int GetEnd()
				{
					return end_;
				}

				/// <summary><code>required uint32 end = 2;</code></summary>
				public CoreNLPProtos.Span.Builder SetEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					end_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 end = 2;</code></summary>
				public CoreNLPProtos.Span.Builder ClearEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					end_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Span.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Span)
			}

			private static readonly CoreNLPProtos.Span DefaultInstance;

			static Span()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Span)
				DefaultInstance = new CoreNLPProtos.Span();
			}

			public static CoreNLPProtos.Span GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_43750 : AbstractParser<CoreNLPProtos.Span>
			{
				public _AbstractParser_43750()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Span ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Span(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Span> Parser = new _AbstractParser_43750();

			public static IParser<CoreNLPProtos.Span> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ITimexOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Timex)
			/// <summary><code>optional string value = 1;</code></summary>
			bool HasValue();

			/// <summary><code>optional string value = 1;</code></summary>
			string GetValue();

			/// <summary><code>optional string value = 1;</code></summary>
			ByteString GetValueBytes();

			/// <summary><code>optional string altValue = 2;</code></summary>
			bool HasAltValue();

			/// <summary><code>optional string altValue = 2;</code></summary>
			string GetAltValue();

			/// <summary><code>optional string altValue = 2;</code></summary>
			ByteString GetAltValueBytes();

			/// <summary><code>optional string text = 3;</code></summary>
			bool HasText();

			/// <summary><code>optional string text = 3;</code></summary>
			string GetText();

			/// <summary><code>optional string text = 3;</code></summary>
			ByteString GetTextBytes();

			/// <summary><code>optional string type = 4;</code></summary>
			bool HasType();

			/// <summary><code>optional string type = 4;</code></summary>
			string GetType();

			/// <summary><code>optional string type = 4;</code></summary>
			ByteString GetTypeBytes();

			/// <summary><code>optional string tid = 5;</code></summary>
			bool HasTid();

			/// <summary><code>optional string tid = 5;</code></summary>
			string GetTid();

			/// <summary><code>optional string tid = 5;</code></summary>
			ByteString GetTidBytes();

			/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
			bool HasBeginPoint();

			/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
			int GetBeginPoint();

			/// <summary><code>optional uint32 endPoint = 7;</code></summary>
			bool HasEndPoint();

			/// <summary><code>optional uint32 endPoint = 7;</code></summary>
			int GetEndPoint();
		}

		/// <summary>
		/// <pre>
		/// A Timex object, representing a temporal expression (TIMe EXpression)
		/// These fields are not *really* optional.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A Timex object, representing a temporal expression (TIMe EXpression)
		/// These fields are not *really* optional. CoreNLP will crash without them.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Timex</c>
		/// </remarks>
		[System.Serializable]
		public sealed class Timex : GeneratedMessageV3, CoreNLPProtos.ITimexOrBuilder
		{
			private Timex(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Timex()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Timex)
				// Use Timex.newBuilder() to construct.
				value_ = string.Empty;
				altValue_ = string.Empty;
				text_ = string.Empty;
				type_ = string.Empty;
				tid_ = string.Empty;
				beginPoint_ = 0;
				endPoint_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Timex(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								value_ = bs;
								break;
							}

							case 18:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000002));
								altValue_ = bs;
								break;
							}

							case 26:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000004));
								text_ = bs;
								break;
							}

							case 34:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000008));
								type_ = bs;
								break;
							}

							case 42:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000010));
								tid_ = bs;
								break;
							}

							case 48:
							{
								bitField0_ |= unchecked((int)(0x00000020));
								beginPoint_ = input.ReadUInt32();
								break;
							}

							case 56:
							{
								bitField0_ |= unchecked((int)(0x00000040));
								endPoint_ = input.ReadUInt32();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Timex_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Timex_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Timex), typeof(CoreNLPProtos.Timex.Builder));
			}

			private int bitField0_;

			public const int ValueFieldNumber = 1;

			private volatile object value_;

			/// <summary><code>optional string value = 1;</code></summary>
			public bool HasValue()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional string value = 1;</code></summary>
			public string GetValue()
			{
				object @ref = value_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						value_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string value = 1;</code></summary>
			public ByteString GetValueBytes()
			{
				object @ref = value_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					value_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int AltvalueFieldNumber = 2;

			private volatile object altValue_;

			/// <summary><code>optional string altValue = 2;</code></summary>
			public bool HasAltValue()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional string altValue = 2;</code></summary>
			public string GetAltValue()
			{
				object @ref = altValue_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						altValue_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string altValue = 2;</code></summary>
			public ByteString GetAltValueBytes()
			{
				object @ref = altValue_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					altValue_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int TextFieldNumber = 3;

			private volatile object text_;

			/// <summary><code>optional string text = 3;</code></summary>
			public bool HasText()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional string text = 3;</code></summary>
			public string GetText()
			{
				object @ref = text_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						text_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string text = 3;</code></summary>
			public ByteString GetTextBytes()
			{
				object @ref = text_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					text_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int TypeFieldNumber = 4;

			private volatile object type_;

			/// <summary><code>optional string type = 4;</code></summary>
			public bool HasType()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional string type = 4;</code></summary>
			public string GetType()
			{
				object @ref = type_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						type_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string type = 4;</code></summary>
			public ByteString GetTypeBytes()
			{
				object @ref = type_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					type_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int TidFieldNumber = 5;

			private volatile object tid_;

			/// <summary><code>optional string tid = 5;</code></summary>
			public bool HasTid()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional string tid = 5;</code></summary>
			public string GetTid()
			{
				object @ref = tid_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						tid_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string tid = 5;</code></summary>
			public ByteString GetTidBytes()
			{
				object @ref = tid_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					tid_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int BeginpointFieldNumber = 6;

			private int beginPoint_;

			/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
			public bool HasBeginPoint()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
			public int GetBeginPoint()
			{
				return beginPoint_;
			}

			public const int EndpointFieldNumber = 7;

			private int endPoint_;

			/// <summary><code>optional uint32 endPoint = 7;</code></summary>
			public bool HasEndPoint()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>optional uint32 endPoint = 7;</code></summary>
			public int GetEndPoint()
			{
				return endPoint_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 1, value_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					GeneratedMessageV3.WriteString(output, 2, altValue_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 3, text_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					GeneratedMessageV3.WriteString(output, 4, type_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					GeneratedMessageV3.WriteString(output, 5, tid_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteUInt32(6, beginPoint_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteUInt32(7, endPoint_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, value_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += GeneratedMessageV3.ComputeStringSize(2, altValue_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(3, text_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += GeneratedMessageV3.ComputeStringSize(4, type_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += GeneratedMessageV3.ComputeStringSize(5, tid_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeUInt32Size(6, beginPoint_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeUInt32Size(7, endPoint_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Timex))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Timex other = (CoreNLPProtos.Timex)obj;
				bool result = true;
				result = result && (HasValue() == other.HasValue());
				if (HasValue())
				{
					result = result && GetValue().Equals(other.GetValue());
				}
				result = result && (HasAltValue() == other.HasAltValue());
				if (HasAltValue())
				{
					result = result && GetAltValue().Equals(other.GetAltValue());
				}
				result = result && (HasText() == other.HasText());
				if (HasText())
				{
					result = result && GetText().Equals(other.GetText());
				}
				result = result && (HasType() == other.HasType());
				if (HasType())
				{
					result = result && GetType().Equals(other.GetType());
				}
				result = result && (HasTid() == other.HasTid());
				if (HasTid())
				{
					result = result && GetTid().Equals(other.GetTid());
				}
				result = result && (HasBeginPoint() == other.HasBeginPoint());
				if (HasBeginPoint())
				{
					result = result && (GetBeginPoint() == other.GetBeginPoint());
				}
				result = result && (HasEndPoint() == other.HasEndPoint());
				if (HasEndPoint())
				{
					result = result && (GetEndPoint() == other.GetEndPoint());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasValue())
				{
					hash = (37 * hash) + ValueFieldNumber;
					hash = (53 * hash) + GetValue().GetHashCode();
				}
				if (HasAltValue())
				{
					hash = (37 * hash) + AltvalueFieldNumber;
					hash = (53 * hash) + GetAltValue().GetHashCode();
				}
				if (HasText())
				{
					hash = (37 * hash) + TextFieldNumber;
					hash = (53 * hash) + GetText().GetHashCode();
				}
				if (HasType())
				{
					hash = (37 * hash) + TypeFieldNumber;
					hash = (53 * hash) + GetType().GetHashCode();
				}
				if (HasTid())
				{
					hash = (37 * hash) + TidFieldNumber;
					hash = (53 * hash) + GetTid().GetHashCode();
				}
				if (HasBeginPoint())
				{
					hash = (37 * hash) + BeginpointFieldNumber;
					hash = (53 * hash) + GetBeginPoint();
				}
				if (HasEndPoint())
				{
					hash = (37 * hash) + EndpointFieldNumber;
					hash = (53 * hash) + GetEndPoint();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Timex ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Timex ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Timex ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Timex ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Timex ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Timex ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Timex ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Timex ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Timex ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Timex ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Timex.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Timex.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Timex.Builder NewBuilder(CoreNLPProtos.Timex prototype)
			{
				return ((CoreNLPProtos.Timex.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Timex.Builder() : new CoreNLPProtos.Timex.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Timex.Builder builder = new CoreNLPProtos.Timex.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A Timex object, representing a temporal expression (TIMe EXpression)
			/// These fields are not *really* optional.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A Timex object, representing a temporal expression (TIMe EXpression)
			/// These fields are not *really* optional. CoreNLP will crash without them.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Timex</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Timex.Builder>, CoreNLPProtos.ITimexOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Timex)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Timex_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Timex_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Timex), typeof(CoreNLPProtos.Timex.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Timex.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					value_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					altValue_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					text_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					type_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					tid_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					beginPoint_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					endPoint_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Timex_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Timex.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Timex result = ((CoreNLPProtos.Timex)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Timex result = new CoreNLPProtos.Timex(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.value_ = value_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.altValue_ = altValue_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.text_ = text_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.type_ = type_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.tid_ = tid_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.beginPoint_ = beginPoint_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.endPoint_ = endPoint_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Timex.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Timex.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Timex.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Timex.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Timex.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Timex.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Timex.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Timex.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Timex)
					{
						return MergeFrom((CoreNLPProtos.Timex)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Timex.Builder MergeFrom(CoreNLPProtos.Timex other)
				{
					if (other == CoreNLPProtos.Timex.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasValue())
					{
						bitField0_ |= unchecked((int)(0x00000001));
						value_ = other.value_;
						OnChanged();
					}
					if (other.HasAltValue())
					{
						bitField0_ |= unchecked((int)(0x00000002));
						altValue_ = other.altValue_;
						OnChanged();
					}
					if (other.HasText())
					{
						bitField0_ |= unchecked((int)(0x00000004));
						text_ = other.text_;
						OnChanged();
					}
					if (other.HasType())
					{
						bitField0_ |= unchecked((int)(0x00000008));
						type_ = other.type_;
						OnChanged();
					}
					if (other.HasTid())
					{
						bitField0_ |= unchecked((int)(0x00000010));
						tid_ = other.tid_;
						OnChanged();
					}
					if (other.HasBeginPoint())
					{
						SetBeginPoint(other.GetBeginPoint());
					}
					if (other.HasEndPoint())
					{
						SetEndPoint(other.GetEndPoint());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Timex parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Timex)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private object value_ = string.Empty;

				/// <summary><code>optional string value = 1;</code></summary>
				public bool HasValue()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional string value = 1;</code></summary>
				public string GetValue()
				{
					object @ref = value_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							value_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string value = 1;</code></summary>
				public ByteString GetValueBytes()
				{
					object @ref = value_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						value_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string value = 1;</code></summary>
				public CoreNLPProtos.Timex.Builder SetValue(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					value_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string value = 1;</code></summary>
				public CoreNLPProtos.Timex.Builder ClearValue()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					value_ = GetDefaultInstance().GetValue();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string value = 1;</code></summary>
				public CoreNLPProtos.Timex.Builder SetValueBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					value_ = value;
					OnChanged();
					return this;
				}

				private object altValue_ = string.Empty;

				/// <summary><code>optional string altValue = 2;</code></summary>
				public bool HasAltValue()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional string altValue = 2;</code></summary>
				public string GetAltValue()
				{
					object @ref = altValue_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							altValue_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string altValue = 2;</code></summary>
				public ByteString GetAltValueBytes()
				{
					object @ref = altValue_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						altValue_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string altValue = 2;</code></summary>
				public CoreNLPProtos.Timex.Builder SetAltValue(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					altValue_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string altValue = 2;</code></summary>
				public CoreNLPProtos.Timex.Builder ClearAltValue()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					altValue_ = GetDefaultInstance().GetAltValue();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string altValue = 2;</code></summary>
				public CoreNLPProtos.Timex.Builder SetAltValueBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					altValue_ = value;
					OnChanged();
					return this;
				}

				private object text_ = string.Empty;

				/// <summary><code>optional string text = 3;</code></summary>
				public bool HasText()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional string text = 3;</code></summary>
				public string GetText()
				{
					object @ref = text_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							text_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string text = 3;</code></summary>
				public ByteString GetTextBytes()
				{
					object @ref = text_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						text_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string text = 3;</code></summary>
				public CoreNLPProtos.Timex.Builder SetText(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					text_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string text = 3;</code></summary>
				public CoreNLPProtos.Timex.Builder ClearText()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					text_ = GetDefaultInstance().GetText();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string text = 3;</code></summary>
				public CoreNLPProtos.Timex.Builder SetTextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					text_ = value;
					OnChanged();
					return this;
				}

				private object type_ = string.Empty;

				/// <summary><code>optional string type = 4;</code></summary>
				public bool HasType()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public string GetType()
				{
					object @ref = type_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							type_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public ByteString GetTypeBytes()
				{
					object @ref = type_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						type_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Timex.Builder SetType(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					type_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Timex.Builder ClearType()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					type_ = GetDefaultInstance().GetType();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Timex.Builder SetTypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					type_ = value;
					OnChanged();
					return this;
				}

				private object tid_ = string.Empty;

				/// <summary><code>optional string tid = 5;</code></summary>
				public bool HasTid()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional string tid = 5;</code></summary>
				public string GetTid()
				{
					object @ref = tid_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							tid_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string tid = 5;</code></summary>
				public ByteString GetTidBytes()
				{
					object @ref = tid_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						tid_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string tid = 5;</code></summary>
				public CoreNLPProtos.Timex.Builder SetTid(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					tid_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string tid = 5;</code></summary>
				public CoreNLPProtos.Timex.Builder ClearTid()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					tid_ = GetDefaultInstance().GetTid();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string tid = 5;</code></summary>
				public CoreNLPProtos.Timex.Builder SetTidBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					tid_ = value;
					OnChanged();
					return this;
				}

				private int beginPoint_;

				/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
				public bool HasBeginPoint()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
				public int GetBeginPoint()
				{
					return beginPoint_;
				}

				/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
				public CoreNLPProtos.Timex.Builder SetBeginPoint(int value)
				{
					bitField0_ |= unchecked((int)(0x00000020));
					beginPoint_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 beginPoint = 6;</code></summary>
				public CoreNLPProtos.Timex.Builder ClearBeginPoint()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					beginPoint_ = 0;
					OnChanged();
					return this;
				}

				private int endPoint_;

				/// <summary><code>optional uint32 endPoint = 7;</code></summary>
				public bool HasEndPoint()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional uint32 endPoint = 7;</code></summary>
				public int GetEndPoint()
				{
					return endPoint_;
				}

				/// <summary><code>optional uint32 endPoint = 7;</code></summary>
				public CoreNLPProtos.Timex.Builder SetEndPoint(int value)
				{
					bitField0_ |= unchecked((int)(0x00000040));
					endPoint_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 endPoint = 7;</code></summary>
				public CoreNLPProtos.Timex.Builder ClearEndPoint()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					endPoint_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Timex.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Timex)
			}

			private static readonly CoreNLPProtos.Timex DefaultInstance;

			static Timex()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Timex)
				DefaultInstance = new CoreNLPProtos.Timex();
			}

			public static CoreNLPProtos.Timex GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_45138 : AbstractParser<CoreNLPProtos.Timex>
			{
				public _AbstractParser_45138()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Timex ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Timex(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Timex> Parser = new _AbstractParser_45138();

			public static IParser<CoreNLPProtos.Timex> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IEntityOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Entity)
			/// <summary><code>optional uint32 headStart = 6;</code></summary>
			bool HasHeadStart();

			/// <summary><code>optional uint32 headStart = 6;</code></summary>
			int GetHeadStart();

			/// <summary><code>optional uint32 headEnd = 7;</code></summary>
			bool HasHeadEnd();

			/// <summary><code>optional uint32 headEnd = 7;</code></summary>
			int GetHeadEnd();

			/// <summary><code>optional string mentionType = 8;</code></summary>
			bool HasMentionType();

			/// <summary><code>optional string mentionType = 8;</code></summary>
			string GetMentionType();

			/// <summary><code>optional string mentionType = 8;</code></summary>
			ByteString GetMentionTypeBytes();

			/// <summary><code>optional string normalizedName = 9;</code></summary>
			bool HasNormalizedName();

			/// <summary><code>optional string normalizedName = 9;</code></summary>
			string GetNormalizedName();

			/// <summary><code>optional string normalizedName = 9;</code></summary>
			ByteString GetNormalizedNameBytes();

			/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
			bool HasHeadTokenIndex();

			/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
			int GetHeadTokenIndex();

			/// <summary><code>optional string corefID = 11;</code></summary>
			bool HasCorefID();

			/// <summary><code>optional string corefID = 11;</code></summary>
			string GetCorefID();

			/// <summary><code>optional string corefID = 11;</code></summary>
			ByteString GetCorefIDBytes();

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			bool HasObjectID();

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			string GetObjectID();

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			ByteString GetObjectIDBytes();

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			bool HasExtentStart();

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			int GetExtentStart();

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			bool HasExtentEnd();

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			int GetExtentEnd();

			/// <summary><code>optional string type = 4;</code></summary>
			bool HasType();

			/// <summary><code>optional string type = 4;</code></summary>
			string GetType();

			/// <summary><code>optional string type = 4;</code></summary>
			ByteString GetTypeBytes();

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			bool HasSubtype();

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			string GetSubtype();

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			ByteString GetSubtypeBytes();
		}

		/// <summary>
		/// <pre>
		/// A representation of an entity in a relation.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A representation of an entity in a relation.
		/// This corresponds to the EntityMention, and more broadly the
		/// ExtractionObject classes.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Entity</c>
		/// </remarks>
		[System.Serializable]
		public sealed class Entity : GeneratedMessageV3, CoreNLPProtos.IEntityOrBuilder
		{
			private Entity(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Entity()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Entity)
				// Use Entity.newBuilder() to construct.
				headStart_ = 0;
				headEnd_ = 0;
				mentionType_ = string.Empty;
				normalizedName_ = string.Empty;
				headTokenIndex_ = 0;
				corefID_ = string.Empty;
				objectID_ = string.Empty;
				extentStart_ = 0;
				extentEnd_ = 0;
				type_ = string.Empty;
				subtype_ = string.Empty;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Entity(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000040));
								objectID_ = bs;
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000080));
								extentStart_ = input.ReadUInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000100));
								extentEnd_ = input.ReadUInt32();
								break;
							}

							case 34:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000200));
								type_ = bs;
								break;
							}

							case 42:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000400));
								subtype_ = bs;
								break;
							}

							case 48:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								headStart_ = input.ReadUInt32();
								break;
							}

							case 56:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								headEnd_ = input.ReadUInt32();
								break;
							}

							case 66:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000004));
								mentionType_ = bs;
								break;
							}

							case 74:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000008));
								normalizedName_ = bs;
								break;
							}

							case 80:
							{
								bitField0_ |= unchecked((int)(0x00000010));
								headTokenIndex_ = input.ReadUInt32();
								break;
							}

							case 90:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000020));
								corefID_ = bs;
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Entity_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Entity_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Entity), typeof(CoreNLPProtos.Entity.Builder));
			}

			private int bitField0_;

			public const int HeadstartFieldNumber = 6;

			private int headStart_;

			/// <summary><code>optional uint32 headStart = 6;</code></summary>
			public bool HasHeadStart()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional uint32 headStart = 6;</code></summary>
			public int GetHeadStart()
			{
				return headStart_;
			}

			public const int HeadendFieldNumber = 7;

			private int headEnd_;

			/// <summary><code>optional uint32 headEnd = 7;</code></summary>
			public bool HasHeadEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional uint32 headEnd = 7;</code></summary>
			public int GetHeadEnd()
			{
				return headEnd_;
			}

			public const int MentiontypeFieldNumber = 8;

			private volatile object mentionType_;

			/// <summary><code>optional string mentionType = 8;</code></summary>
			public bool HasMentionType()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional string mentionType = 8;</code></summary>
			public string GetMentionType()
			{
				object @ref = mentionType_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						mentionType_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string mentionType = 8;</code></summary>
			public ByteString GetMentionTypeBytes()
			{
				object @ref = mentionType_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					mentionType_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int NormalizednameFieldNumber = 9;

			private volatile object normalizedName_;

			/// <summary><code>optional string normalizedName = 9;</code></summary>
			public bool HasNormalizedName()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional string normalizedName = 9;</code></summary>
			public string GetNormalizedName()
			{
				object @ref = normalizedName_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						normalizedName_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string normalizedName = 9;</code></summary>
			public ByteString GetNormalizedNameBytes()
			{
				object @ref = normalizedName_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					normalizedName_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int HeadtokenindexFieldNumber = 10;

			private int headTokenIndex_;

			/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
			public bool HasHeadTokenIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
			public int GetHeadTokenIndex()
			{
				return headTokenIndex_;
			}

			public const int CorefidFieldNumber = 11;

			private volatile object corefID_;

			/// <summary><code>optional string corefID = 11;</code></summary>
			public bool HasCorefID()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional string corefID = 11;</code></summary>
			public string GetCorefID()
			{
				object @ref = corefID_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						corefID_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string corefID = 11;</code></summary>
			public ByteString GetCorefIDBytes()
			{
				object @ref = corefID_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					corefID_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ObjectidFieldNumber = 1;

			private volatile object objectID_;

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			public bool HasObjectID()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			public string GetObjectID()
			{
				object @ref = objectID_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						objectID_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			public ByteString GetObjectIDBytes()
			{
				object @ref = objectID_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					objectID_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ExtentstartFieldNumber = 2;

			private int extentStart_;

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			public bool HasExtentStart()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			public int GetExtentStart()
			{
				return extentStart_;
			}

			public const int ExtentendFieldNumber = 3;

			private int extentEnd_;

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			public bool HasExtentEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			public int GetExtentEnd()
			{
				return extentEnd_;
			}

			public const int TypeFieldNumber = 4;

			private volatile object type_;

			/// <summary><code>optional string type = 4;</code></summary>
			public bool HasType()
			{
				return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
			}

			/// <summary><code>optional string type = 4;</code></summary>
			public string GetType()
			{
				object @ref = type_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						type_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string type = 4;</code></summary>
			public ByteString GetTypeBytes()
			{
				object @ref = type_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					type_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SubtypeFieldNumber = 5;

			private volatile object subtype_;

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			public bool HasSubtype()
			{
				return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
			}

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			public string GetSubtype()
			{
				object @ref = subtype_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						subtype_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			public ByteString GetSubtypeBytes()
			{
				object @ref = subtype_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					subtype_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					GeneratedMessageV3.WriteString(output, 1, objectID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					output.WriteUInt32(2, extentStart_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					output.WriteUInt32(3, extentEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					GeneratedMessageV3.WriteString(output, 4, type_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					GeneratedMessageV3.WriteString(output, 5, subtype_);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(6, headStart_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(7, headEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 8, mentionType_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					GeneratedMessageV3.WriteString(output, 9, normalizedName_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteUInt32(10, headTokenIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					GeneratedMessageV3.WriteString(output, 11, corefID_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, objectID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, extentStart_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, extentEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					size += GeneratedMessageV3.ComputeStringSize(4, type_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					size += GeneratedMessageV3.ComputeStringSize(5, subtype_);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(6, headStart_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(7, headEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(8, mentionType_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += GeneratedMessageV3.ComputeStringSize(9, normalizedName_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeUInt32Size(10, headTokenIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += GeneratedMessageV3.ComputeStringSize(11, corefID_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Entity))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Entity other = (CoreNLPProtos.Entity)obj;
				bool result = true;
				result = result && (HasHeadStart() == other.HasHeadStart());
				if (HasHeadStart())
				{
					result = result && (GetHeadStart() == other.GetHeadStart());
				}
				result = result && (HasHeadEnd() == other.HasHeadEnd());
				if (HasHeadEnd())
				{
					result = result && (GetHeadEnd() == other.GetHeadEnd());
				}
				result = result && (HasMentionType() == other.HasMentionType());
				if (HasMentionType())
				{
					result = result && GetMentionType().Equals(other.GetMentionType());
				}
				result = result && (HasNormalizedName() == other.HasNormalizedName());
				if (HasNormalizedName())
				{
					result = result && GetNormalizedName().Equals(other.GetNormalizedName());
				}
				result = result && (HasHeadTokenIndex() == other.HasHeadTokenIndex());
				if (HasHeadTokenIndex())
				{
					result = result && (GetHeadTokenIndex() == other.GetHeadTokenIndex());
				}
				result = result && (HasCorefID() == other.HasCorefID());
				if (HasCorefID())
				{
					result = result && GetCorefID().Equals(other.GetCorefID());
				}
				result = result && (HasObjectID() == other.HasObjectID());
				if (HasObjectID())
				{
					result = result && GetObjectID().Equals(other.GetObjectID());
				}
				result = result && (HasExtentStart() == other.HasExtentStart());
				if (HasExtentStart())
				{
					result = result && (GetExtentStart() == other.GetExtentStart());
				}
				result = result && (HasExtentEnd() == other.HasExtentEnd());
				if (HasExtentEnd())
				{
					result = result && (GetExtentEnd() == other.GetExtentEnd());
				}
				result = result && (HasType() == other.HasType());
				if (HasType())
				{
					result = result && GetType().Equals(other.GetType());
				}
				result = result && (HasSubtype() == other.HasSubtype());
				if (HasSubtype())
				{
					result = result && GetSubtype().Equals(other.GetSubtype());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasHeadStart())
				{
					hash = (37 * hash) + HeadstartFieldNumber;
					hash = (53 * hash) + GetHeadStart();
				}
				if (HasHeadEnd())
				{
					hash = (37 * hash) + HeadendFieldNumber;
					hash = (53 * hash) + GetHeadEnd();
				}
				if (HasMentionType())
				{
					hash = (37 * hash) + MentiontypeFieldNumber;
					hash = (53 * hash) + GetMentionType().GetHashCode();
				}
				if (HasNormalizedName())
				{
					hash = (37 * hash) + NormalizednameFieldNumber;
					hash = (53 * hash) + GetNormalizedName().GetHashCode();
				}
				if (HasHeadTokenIndex())
				{
					hash = (37 * hash) + HeadtokenindexFieldNumber;
					hash = (53 * hash) + GetHeadTokenIndex();
				}
				if (HasCorefID())
				{
					hash = (37 * hash) + CorefidFieldNumber;
					hash = (53 * hash) + GetCorefID().GetHashCode();
				}
				if (HasObjectID())
				{
					hash = (37 * hash) + ObjectidFieldNumber;
					hash = (53 * hash) + GetObjectID().GetHashCode();
				}
				if (HasExtentStart())
				{
					hash = (37 * hash) + ExtentstartFieldNumber;
					hash = (53 * hash) + GetExtentStart();
				}
				if (HasExtentEnd())
				{
					hash = (37 * hash) + ExtentendFieldNumber;
					hash = (53 * hash) + GetExtentEnd();
				}
				if (HasType())
				{
					hash = (37 * hash) + TypeFieldNumber;
					hash = (53 * hash) + GetType().GetHashCode();
				}
				if (HasSubtype())
				{
					hash = (37 * hash) + SubtypeFieldNumber;
					hash = (53 * hash) + GetSubtype().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Entity ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Entity ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Entity ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Entity ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Entity ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Entity ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Entity ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Entity ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Entity ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Entity ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Entity.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Entity.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Entity.Builder NewBuilder(CoreNLPProtos.Entity prototype)
			{
				return ((CoreNLPProtos.Entity.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Entity.Builder() : new CoreNLPProtos.Entity.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Entity.Builder builder = new CoreNLPProtos.Entity.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A representation of an entity in a relation.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A representation of an entity in a relation.
			/// This corresponds to the EntityMention, and more broadly the
			/// ExtractionObject classes.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Entity</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Entity.Builder>, CoreNLPProtos.IEntityOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Entity)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Entity_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Entity_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Entity), typeof(CoreNLPProtos.Entity.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Entity.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					headStart_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					headEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					mentionType_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					normalizedName_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					headTokenIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					corefID_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					objectID_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					extentStart_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					extentEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					type_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					subtype_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Entity_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Entity.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Entity result = ((CoreNLPProtos.Entity)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Entity result = new CoreNLPProtos.Entity(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.headStart_ = headStart_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.headEnd_ = headEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.mentionType_ = mentionType_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.normalizedName_ = normalizedName_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.headTokenIndex_ = headTokenIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.corefID_ = corefID_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.objectID_ = objectID_;
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					result.extentStart_ = extentStart_;
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000100));
					}
					result.extentEnd_ = extentEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x00000200));
					}
					result.type_ = type_;
					if (((from_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x00000400));
					}
					result.subtype_ = subtype_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Entity.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Entity.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Entity.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Entity.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Entity.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Entity.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Entity.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Entity.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Entity)
					{
						return MergeFrom((CoreNLPProtos.Entity)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Entity.Builder MergeFrom(CoreNLPProtos.Entity other)
				{
					if (other == CoreNLPProtos.Entity.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasHeadStart())
					{
						SetHeadStart(other.GetHeadStart());
					}
					if (other.HasHeadEnd())
					{
						SetHeadEnd(other.GetHeadEnd());
					}
					if (other.HasMentionType())
					{
						bitField0_ |= unchecked((int)(0x00000004));
						mentionType_ = other.mentionType_;
						OnChanged();
					}
					if (other.HasNormalizedName())
					{
						bitField0_ |= unchecked((int)(0x00000008));
						normalizedName_ = other.normalizedName_;
						OnChanged();
					}
					if (other.HasHeadTokenIndex())
					{
						SetHeadTokenIndex(other.GetHeadTokenIndex());
					}
					if (other.HasCorefID())
					{
						bitField0_ |= unchecked((int)(0x00000020));
						corefID_ = other.corefID_;
						OnChanged();
					}
					if (other.HasObjectID())
					{
						bitField0_ |= unchecked((int)(0x00000040));
						objectID_ = other.objectID_;
						OnChanged();
					}
					if (other.HasExtentStart())
					{
						SetExtentStart(other.GetExtentStart());
					}
					if (other.HasExtentEnd())
					{
						SetExtentEnd(other.GetExtentEnd());
					}
					if (other.HasType())
					{
						bitField0_ |= unchecked((int)(0x00000200));
						type_ = other.type_;
						OnChanged();
					}
					if (other.HasSubtype())
					{
						bitField0_ |= unchecked((int)(0x00000400));
						subtype_ = other.subtype_;
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Entity parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Entity)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int headStart_;

				/// <summary><code>optional uint32 headStart = 6;</code></summary>
				public bool HasHeadStart()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional uint32 headStart = 6;</code></summary>
				public int GetHeadStart()
				{
					return headStart_;
				}

				/// <summary><code>optional uint32 headStart = 6;</code></summary>
				public CoreNLPProtos.Entity.Builder SetHeadStart(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					headStart_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 headStart = 6;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearHeadStart()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					headStart_ = 0;
					OnChanged();
					return this;
				}

				private int headEnd_;

				/// <summary><code>optional uint32 headEnd = 7;</code></summary>
				public bool HasHeadEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional uint32 headEnd = 7;</code></summary>
				public int GetHeadEnd()
				{
					return headEnd_;
				}

				/// <summary><code>optional uint32 headEnd = 7;</code></summary>
				public CoreNLPProtos.Entity.Builder SetHeadEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					headEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 headEnd = 7;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearHeadEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					headEnd_ = 0;
					OnChanged();
					return this;
				}

				private object mentionType_ = string.Empty;

				/// <summary><code>optional string mentionType = 8;</code></summary>
				public bool HasMentionType()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional string mentionType = 8;</code></summary>
				public string GetMentionType()
				{
					object @ref = mentionType_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							mentionType_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string mentionType = 8;</code></summary>
				public ByteString GetMentionTypeBytes()
				{
					object @ref = mentionType_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						mentionType_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string mentionType = 8;</code></summary>
				public CoreNLPProtos.Entity.Builder SetMentionType(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					mentionType_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionType = 8;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearMentionType()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					mentionType_ = GetDefaultInstance().GetMentionType();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string mentionType = 8;</code></summary>
				public CoreNLPProtos.Entity.Builder SetMentionTypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					mentionType_ = value;
					OnChanged();
					return this;
				}

				private object normalizedName_ = string.Empty;

				/// <summary><code>optional string normalizedName = 9;</code></summary>
				public bool HasNormalizedName()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional string normalizedName = 9;</code></summary>
				public string GetNormalizedName()
				{
					object @ref = normalizedName_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							normalizedName_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string normalizedName = 9;</code></summary>
				public ByteString GetNormalizedNameBytes()
				{
					object @ref = normalizedName_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						normalizedName_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string normalizedName = 9;</code></summary>
				public CoreNLPProtos.Entity.Builder SetNormalizedName(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					normalizedName_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string normalizedName = 9;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearNormalizedName()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					normalizedName_ = GetDefaultInstance().GetNormalizedName();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string normalizedName = 9;</code></summary>
				public CoreNLPProtos.Entity.Builder SetNormalizedNameBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					normalizedName_ = value;
					OnChanged();
					return this;
				}

				private int headTokenIndex_;

				/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
				public bool HasHeadTokenIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
				public int GetHeadTokenIndex()
				{
					return headTokenIndex_;
				}

				/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
				public CoreNLPProtos.Entity.Builder SetHeadTokenIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000010));
					headTokenIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 headTokenIndex = 10;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearHeadTokenIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					headTokenIndex_ = 0;
					OnChanged();
					return this;
				}

				private object corefID_ = string.Empty;

				/// <summary><code>optional string corefID = 11;</code></summary>
				public bool HasCorefID()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional string corefID = 11;</code></summary>
				public string GetCorefID()
				{
					object @ref = corefID_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							corefID_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string corefID = 11;</code></summary>
				public ByteString GetCorefIDBytes()
				{
					object @ref = corefID_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						corefID_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string corefID = 11;</code></summary>
				public CoreNLPProtos.Entity.Builder SetCorefID(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					corefID_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string corefID = 11;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearCorefID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					corefID_ = GetDefaultInstance().GetCorefID();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string corefID = 11;</code></summary>
				public CoreNLPProtos.Entity.Builder SetCorefIDBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					corefID_ = value;
					OnChanged();
					return this;
				}

				private object objectID_ = string.Empty;

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public bool HasObjectID()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public string GetObjectID()
				{
					object @ref = objectID_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							objectID_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public ByteString GetObjectIDBytes()
				{
					object @ref = objectID_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						objectID_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public CoreNLPProtos.Entity.Builder SetObjectID(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000040));
					objectID_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public CoreNLPProtos.Entity.Builder ClearObjectID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					objectID_ = GetDefaultInstance().GetObjectID();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public CoreNLPProtos.Entity.Builder SetObjectIDBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000040));
					objectID_ = value;
					OnChanged();
					return this;
				}

				private int extentStart_;

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public bool HasExtentStart()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public int GetExtentStart()
				{
					return extentStart_;
				}

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public CoreNLPProtos.Entity.Builder SetExtentStart(int value)
				{
					bitField0_ |= unchecked((int)(0x00000080));
					extentStart_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearExtentStart()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					extentStart_ = 0;
					OnChanged();
					return this;
				}

				private int extentEnd_;

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public bool HasExtentEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public int GetExtentEnd()
				{
					return extentEnd_;
				}

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public CoreNLPProtos.Entity.Builder SetExtentEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000100));
					extentEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearExtentEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					extentEnd_ = 0;
					OnChanged();
					return this;
				}

				private object type_ = string.Empty;

				/// <summary><code>optional string type = 4;</code></summary>
				public bool HasType()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public string GetType()
				{
					object @ref = type_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							type_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public ByteString GetTypeBytes()
				{
					object @ref = type_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						type_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Entity.Builder SetType(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					type_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Entity.Builder ClearType()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					type_ = GetDefaultInstance().GetType();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Entity.Builder SetTypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000200));
					type_ = value;
					OnChanged();
					return this;
				}

				private object subtype_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public bool HasSubtype()
				{
					return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public string GetSubtype()
				{
					object @ref = subtype_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							subtype_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public ByteString GetSubtypeBytes()
				{
					object @ref = subtype_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						subtype_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public CoreNLPProtos.Entity.Builder SetSubtype(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					subtype_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public CoreNLPProtos.Entity.Builder ClearSubtype()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					subtype_ = GetDefaultInstance().GetSubtype();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public CoreNLPProtos.Entity.Builder SetSubtypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000400));
					subtype_ = value;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Entity.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Entity)
			}

			private static readonly CoreNLPProtos.Entity DefaultInstance;

			static Entity()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Entity)
				DefaultInstance = new CoreNLPProtos.Entity();
			}

			public static CoreNLPProtos.Entity GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_47062 : AbstractParser<CoreNLPProtos.Entity>
			{
				public _AbstractParser_47062()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Entity ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Entity(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Entity> Parser = new _AbstractParser_47062();

			public static IParser<CoreNLPProtos.Entity> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IRelationOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Relation)
			/// <summary><code>repeated string argName = 6;</code></summary>
			IList<string> GetArgNameList();

			/// <summary><code>repeated string argName = 6;</code></summary>
			int GetArgNameCount();

			/// <summary><code>repeated string argName = 6;</code></summary>
			string GetArgName(int index);

			/// <summary><code>repeated string argName = 6;</code></summary>
			ByteString GetArgNameBytes(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			IList<CoreNLPProtos.Entity> GetArgList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			CoreNLPProtos.Entity GetArg(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			int GetArgCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			IList<CoreNLPProtos.IEntityOrBuilder> GetArgOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			CoreNLPProtos.IEntityOrBuilder GetArgOrBuilder(int index);

			/// <summary><code>optional string signature = 8;</code></summary>
			bool HasSignature();

			/// <summary><code>optional string signature = 8;</code></summary>
			string GetSignature();

			/// <summary><code>optional string signature = 8;</code></summary>
			ByteString GetSignatureBytes();

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			bool HasObjectID();

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			string GetObjectID();

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			ByteString GetObjectIDBytes();

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			bool HasExtentStart();

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			int GetExtentStart();

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			bool HasExtentEnd();

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			int GetExtentEnd();

			/// <summary><code>optional string type = 4;</code></summary>
			bool HasType();

			/// <summary><code>optional string type = 4;</code></summary>
			string GetType();

			/// <summary><code>optional string type = 4;</code></summary>
			ByteString GetTypeBytes();

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			bool HasSubtype();

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			string GetSubtype();

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			ByteString GetSubtypeBytes();
		}

		/// <summary>
		/// <pre>
		/// A representation of a relation, mirroring RelationMention
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Relation</c>
		/// </summary>
		[System.Serializable]
		public sealed class Relation : GeneratedMessageV3, CoreNLPProtos.IRelationOrBuilder
		{
			private Relation(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Relation()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Relation)
				// Use Relation.newBuilder() to construct.
				argName_ = LazyStringArrayList.Empty;
				arg_ = Java.Util.Collections.EmptyList();
				signature_ = string.Empty;
				objectID_ = string.Empty;
				extentStart_ = 0;
				extentEnd_ = 0;
				type_ = string.Empty;
				subtype_ = string.Empty;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Relation(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000002));
								objectID_ = bs;
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								extentStart_ = input.ReadUInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								extentEnd_ = input.ReadUInt32();
								break;
							}

							case 34:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000010));
								type_ = bs;
								break;
							}

							case 42:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000020));
								subtype_ = bs;
								break;
							}

							case 50:
							{
								ByteString bs = input.ReadBytes();
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									argName_ = new LazyStringArrayList();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								argName_.Add(bs);
								break;
							}

							case 58:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									arg_ = new List<CoreNLPProtos.Entity>();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								arg_.Add(input.ReadMessage(CoreNLPProtos.Entity.Parser, extensionRegistry));
								break;
							}

							case 66:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								signature_ = bs;
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						argName_ = argName_.GetUnmodifiableView();
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						arg_ = Java.Util.Collections.UnmodifiableList(arg_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Relation_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Relation_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Relation), typeof(CoreNLPProtos.Relation.Builder));
			}

			private int bitField0_;

			public const int ArgnameFieldNumber = 6;

			private ILazyStringList argName_;

			/// <summary><code>repeated string argName = 6;</code></summary>
			public IProtocolStringList GetArgNameList()
			{
				return argName_;
			}

			/// <summary><code>repeated string argName = 6;</code></summary>
			public int GetArgNameCount()
			{
				return argName_.Count;
			}

			/// <summary><code>repeated string argName = 6;</code></summary>
			public string GetArgName(int index)
			{
				return argName_[index];
			}

			/// <summary><code>repeated string argName = 6;</code></summary>
			public ByteString GetArgNameBytes(int index)
			{
				return argName_.GetByteString(index);
			}

			public const int ArgFieldNumber = 7;

			private IList<CoreNLPProtos.Entity> arg_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			public IList<CoreNLPProtos.Entity> GetArgList()
			{
				return arg_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			public IList<CoreNLPProtos.IEntityOrBuilder> GetArgOrBuilderList()
			{
				return arg_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			public int GetArgCount()
			{
				return arg_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			public CoreNLPProtos.Entity GetArg(int index)
			{
				return arg_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
			public CoreNLPProtos.IEntityOrBuilder GetArgOrBuilder(int index)
			{
				return arg_[index];
			}

			public const int SignatureFieldNumber = 8;

			private volatile object signature_;

			/// <summary><code>optional string signature = 8;</code></summary>
			public bool HasSignature()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional string signature = 8;</code></summary>
			public string GetSignature()
			{
				object @ref = signature_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						signature_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string signature = 8;</code></summary>
			public ByteString GetSignatureBytes()
			{
				object @ref = signature_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					signature_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ObjectidFieldNumber = 1;

			private volatile object objectID_;

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			public bool HasObjectID()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			public string GetObjectID()
			{
				object @ref = objectID_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						objectID_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// inherited from ExtractionObject
			/// </pre>
			/// <code>optional string objectID = 1;</code>
			/// </summary>
			public ByteString GetObjectIDBytes()
			{
				object @ref = objectID_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					objectID_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ExtentstartFieldNumber = 2;

			private int extentStart_;

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			public bool HasExtentStart()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional uint32 extentStart = 2;</code></summary>
			public int GetExtentStart()
			{
				return extentStart_;
			}

			public const int ExtentendFieldNumber = 3;

			private int extentEnd_;

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			public bool HasExtentEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
			public int GetExtentEnd()
			{
				return extentEnd_;
			}

			public const int TypeFieldNumber = 4;

			private volatile object type_;

			/// <summary><code>optional string type = 4;</code></summary>
			public bool HasType()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional string type = 4;</code></summary>
			public string GetType()
			{
				object @ref = type_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						type_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string type = 4;</code></summary>
			public ByteString GetTypeBytes()
			{
				object @ref = type_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					type_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SubtypeFieldNumber = 5;

			private volatile object subtype_;

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			public bool HasSubtype()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			public string GetSubtype()
			{
				object @ref = subtype_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						subtype_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// Implicit
			/// uint32 sentence       &#64;see implicit in sentence
			/// </pre>
			/// <code>optional string subtype = 5;</code>
			/// </summary>
			public ByteString GetSubtypeBytes()
			{
				object @ref = subtype_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					subtype_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					GeneratedMessageV3.WriteString(output, 1, objectID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteUInt32(2, extentStart_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteUInt32(3, extentEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					GeneratedMessageV3.WriteString(output, 4, type_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					GeneratedMessageV3.WriteString(output, 5, subtype_);
				}
				for (int i = 0; i < argName_.Count; i++)
				{
					GeneratedMessageV3.WriteString(output, 6, argName_.GetRaw(i));
				}
				for (int i_1 = 0; i_1 < arg_.Count; i_1++)
				{
					output.WriteMessage(7, arg_[i_1]);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 8, signature_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, objectID_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, extentStart_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, extentEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += GeneratedMessageV3.ComputeStringSize(4, type_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += GeneratedMessageV3.ComputeStringSize(5, subtype_);
				}
				{
					int dataSize = 0;
					for (int i = 0; i < argName_.Count; i++)
					{
						dataSize += ComputeStringSizeNoTag(argName_.GetRaw(i));
					}
					size += dataSize;
					size += 1 * GetArgNameList().Count;
				}
				for (int i_1 = 0; i_1 < arg_.Count; i_1++)
				{
					size += CodedOutputStream.ComputeMessageSize(7, arg_[i_1]);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(8, signature_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Relation))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Relation other = (CoreNLPProtos.Relation)obj;
				bool result = true;
				result = result && GetArgNameList().Equals(other.GetArgNameList());
				result = result && GetArgList().Equals(other.GetArgList());
				result = result && (HasSignature() == other.HasSignature());
				if (HasSignature())
				{
					result = result && GetSignature().Equals(other.GetSignature());
				}
				result = result && (HasObjectID() == other.HasObjectID());
				if (HasObjectID())
				{
					result = result && GetObjectID().Equals(other.GetObjectID());
				}
				result = result && (HasExtentStart() == other.HasExtentStart());
				if (HasExtentStart())
				{
					result = result && (GetExtentStart() == other.GetExtentStart());
				}
				result = result && (HasExtentEnd() == other.HasExtentEnd());
				if (HasExtentEnd())
				{
					result = result && (GetExtentEnd() == other.GetExtentEnd());
				}
				result = result && (HasType() == other.HasType());
				if (HasType())
				{
					result = result && GetType().Equals(other.GetType());
				}
				result = result && (HasSubtype() == other.HasSubtype());
				if (HasSubtype())
				{
					result = result && GetSubtype().Equals(other.GetSubtype());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (GetArgNameCount() > 0)
				{
					hash = (37 * hash) + ArgnameFieldNumber;
					hash = (53 * hash) + GetArgNameList().GetHashCode();
				}
				if (GetArgCount() > 0)
				{
					hash = (37 * hash) + ArgFieldNumber;
					hash = (53 * hash) + GetArgList().GetHashCode();
				}
				if (HasSignature())
				{
					hash = (37 * hash) + SignatureFieldNumber;
					hash = (53 * hash) + GetSignature().GetHashCode();
				}
				if (HasObjectID())
				{
					hash = (37 * hash) + ObjectidFieldNumber;
					hash = (53 * hash) + GetObjectID().GetHashCode();
				}
				if (HasExtentStart())
				{
					hash = (37 * hash) + ExtentstartFieldNumber;
					hash = (53 * hash) + GetExtentStart();
				}
				if (HasExtentEnd())
				{
					hash = (37 * hash) + ExtentendFieldNumber;
					hash = (53 * hash) + GetExtentEnd();
				}
				if (HasType())
				{
					hash = (37 * hash) + TypeFieldNumber;
					hash = (53 * hash) + GetType().GetHashCode();
				}
				if (HasSubtype())
				{
					hash = (37 * hash) + SubtypeFieldNumber;
					hash = (53 * hash) + GetSubtype().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Relation ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Relation ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Relation ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Relation ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Relation ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Relation ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Relation ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Relation ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Relation ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Relation ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Relation.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Relation.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Relation.Builder NewBuilder(CoreNLPProtos.Relation prototype)
			{
				return ((CoreNLPProtos.Relation.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Relation.Builder() : new CoreNLPProtos.Relation.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Relation.Builder builder = new CoreNLPProtos.Relation.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A representation of a relation, mirroring RelationMention
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Relation</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Relation.Builder>, CoreNLPProtos.IRelationOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Relation)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Relation_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Relation_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Relation), typeof(CoreNLPProtos.Relation.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Relation.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetArgFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					argName_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					if (argBuilder_ == null)
					{
						arg_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					else
					{
						argBuilder_.Clear();
					}
					signature_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					objectID_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					extentStart_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					extentEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					type_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					subtype_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Relation_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Relation.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Relation result = ((CoreNLPProtos.Relation)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Relation result = new CoreNLPProtos.Relation(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						argName_ = argName_.GetUnmodifiableView();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					result.argName_ = argName_;
					if (argBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
						{
							arg_ = Java.Util.Collections.UnmodifiableList(arg_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						result.arg_ = arg_;
					}
					else
					{
						result.arg_ = argBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.signature_ = signature_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.objectID_ = objectID_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.extentStart_ = extentStart_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.extentEnd_ = extentEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.type_ = type_;
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.subtype_ = subtype_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Relation.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Relation.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Relation.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Relation.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Relation.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Relation.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Relation.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Relation.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Relation)
					{
						return MergeFrom((CoreNLPProtos.Relation)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Relation.Builder MergeFrom(CoreNLPProtos.Relation other)
				{
					if (other == CoreNLPProtos.Relation.GetDefaultInstance())
					{
						return this;
					}
					if (!other.argName_.IsEmpty())
					{
						if (argName_.IsEmpty())
						{
							argName_ = other.argName_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						else
						{
							EnsureArgNameIsMutable();
							Sharpen.Collections.AddAll(argName_, other.argName_);
						}
						OnChanged();
					}
					if (argBuilder_ == null)
					{
						if (!other.arg_.IsEmpty())
						{
							if (arg_.IsEmpty())
							{
								arg_ = other.arg_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
							}
							else
							{
								EnsureArgIsMutable();
								Sharpen.Collections.AddAll(arg_, other.arg_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.arg_.IsEmpty())
						{
							if (argBuilder_.IsEmpty())
							{
								argBuilder_.Dispose();
								argBuilder_ = null;
								arg_ = other.arg_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
								argBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetArgFieldBuilder() : null;
							}
							else
							{
								argBuilder_.AddAllMessages(other.arg_);
							}
						}
					}
					if (other.HasSignature())
					{
						bitField0_ |= unchecked((int)(0x00000004));
						signature_ = other.signature_;
						OnChanged();
					}
					if (other.HasObjectID())
					{
						bitField0_ |= unchecked((int)(0x00000008));
						objectID_ = other.objectID_;
						OnChanged();
					}
					if (other.HasExtentStart())
					{
						SetExtentStart(other.GetExtentStart());
					}
					if (other.HasExtentEnd())
					{
						SetExtentEnd(other.GetExtentEnd());
					}
					if (other.HasType())
					{
						bitField0_ |= unchecked((int)(0x00000040));
						type_ = other.type_;
						OnChanged();
					}
					if (other.HasSubtype())
					{
						bitField0_ |= unchecked((int)(0x00000080));
						subtype_ = other.subtype_;
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Relation parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Relation)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private ILazyStringList argName_ = LazyStringArrayList.Empty;

				private void EnsureArgNameIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						argName_ = new LazyStringArrayList(argName_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public IProtocolStringList GetArgNameList()
				{
					return argName_.GetUnmodifiableView();
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public int GetArgNameCount()
				{
					return argName_.Count;
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public string GetArgName(int index)
				{
					return argName_[index];
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public ByteString GetArgNameBytes(int index)
				{
					return argName_.GetByteString(index);
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public CoreNLPProtos.Relation.Builder SetArgName(int index, string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureArgNameIsMutable();
					argName_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public CoreNLPProtos.Relation.Builder AddArgName(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureArgNameIsMutable();
					argName_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public CoreNLPProtos.Relation.Builder AddAllArgName(IEnumerable<string> values)
				{
					EnsureArgNameIsMutable();
					AbstractMessageLite.Builder.AddAll(values, argName_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public CoreNLPProtos.Relation.Builder ClearArgName()
				{
					argName_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string argName = 6;</code></summary>
				public CoreNLPProtos.Relation.Builder AddArgNameBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureArgNameIsMutable();
					argName_.Add(value);
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.Entity> arg_ = Java.Util.Collections.EmptyList();

				private void EnsureArgIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						arg_ = new List<CoreNLPProtos.Entity>(arg_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Entity, CoreNLPProtos.Entity.Builder, CoreNLPProtos.IEntityOrBuilder> argBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public IList<CoreNLPProtos.Entity> GetArgList()
				{
					if (argBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(arg_);
					}
					else
					{
						return argBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public int GetArgCount()
				{
					if (argBuilder_ == null)
					{
						return arg_.Count;
					}
					else
					{
						return argBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Entity GetArg(int index)
				{
					if (argBuilder_ == null)
					{
						return arg_[index];
					}
					else
					{
						return argBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder SetArg(int index, CoreNLPProtos.Entity value)
				{
					if (argBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureArgIsMutable();
						arg_.Set(index, value);
						OnChanged();
					}
					else
					{
						argBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder SetArg(int index, CoreNLPProtos.Entity.Builder builderForValue)
				{
					if (argBuilder_ == null)
					{
						EnsureArgIsMutable();
						arg_.Set(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						argBuilder_.SetMessage(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder AddArg(CoreNLPProtos.Entity value)
				{
					if (argBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureArgIsMutable();
						arg_.Add(value);
						OnChanged();
					}
					else
					{
						argBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder AddArg(int index, CoreNLPProtos.Entity value)
				{
					if (argBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureArgIsMutable();
						arg_.Add(index, value);
						OnChanged();
					}
					else
					{
						argBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder AddArg(CoreNLPProtos.Entity.Builder builderForValue)
				{
					if (argBuilder_ == null)
					{
						EnsureArgIsMutable();
						arg_.Add(((CoreNLPProtos.Entity)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						argBuilder_.AddMessage(((CoreNLPProtos.Entity)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder AddArg(int index, CoreNLPProtos.Entity.Builder builderForValue)
				{
					if (argBuilder_ == null)
					{
						EnsureArgIsMutable();
						arg_.Add(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						argBuilder_.AddMessage(index, ((CoreNLPProtos.Entity)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder AddAllArg<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Entity
				{
					if (argBuilder_ == null)
					{
						EnsureArgIsMutable();
						AbstractMessageLite.Builder.AddAll(values, arg_);
						OnChanged();
					}
					else
					{
						argBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder ClearArg()
				{
					if (argBuilder_ == null)
					{
						arg_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						OnChanged();
					}
					else
					{
						argBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Relation.Builder RemoveArg(int index)
				{
					if (argBuilder_ == null)
					{
						EnsureArgIsMutable();
						arg_.Remove(index);
						OnChanged();
					}
					else
					{
						argBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Entity.Builder GetArgBuilder(int index)
				{
					return GetArgFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.IEntityOrBuilder GetArgOrBuilder(int index)
				{
					if (argBuilder_ == null)
					{
						return arg_[index];
					}
					else
					{
						return argBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public IList<CoreNLPProtos.IEntityOrBuilder> GetArgOrBuilderList()
				{
					if (argBuilder_ != null)
					{
						return argBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(arg_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Entity.Builder AddArgBuilder()
				{
					return GetArgFieldBuilder().AddBuilder(CoreNLPProtos.Entity.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public CoreNLPProtos.Entity.Builder AddArgBuilder(int index)
				{
					return GetArgFieldBuilder().AddBuilder(index, CoreNLPProtos.Entity.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Entity arg = 7;</code></summary>
				public IList<CoreNLPProtos.Entity.Builder> GetArgBuilderList()
				{
					return GetArgFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Entity, CoreNLPProtos.Entity.Builder, CoreNLPProtos.IEntityOrBuilder> GetArgFieldBuilder()
				{
					if (argBuilder_ == null)
					{
						argBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Entity, CoreNLPProtos.Entity.Builder, CoreNLPProtos.IEntityOrBuilder>(arg_, ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))), GetParentForChildren(), IsClean
							());
						arg_ = null;
					}
					return argBuilder_;
				}

				private object signature_ = string.Empty;

				/// <summary><code>optional string signature = 8;</code></summary>
				public bool HasSignature()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional string signature = 8;</code></summary>
				public string GetSignature()
				{
					object @ref = signature_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							signature_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string signature = 8;</code></summary>
				public ByteString GetSignatureBytes()
				{
					object @ref = signature_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						signature_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string signature = 8;</code></summary>
				public CoreNLPProtos.Relation.Builder SetSignature(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					signature_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string signature = 8;</code></summary>
				public CoreNLPProtos.Relation.Builder ClearSignature()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					signature_ = GetDefaultInstance().GetSignature();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string signature = 8;</code></summary>
				public CoreNLPProtos.Relation.Builder SetSignatureBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					signature_ = value;
					OnChanged();
					return this;
				}

				private object objectID_ = string.Empty;

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public bool HasObjectID()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public string GetObjectID()
				{
					object @ref = objectID_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							objectID_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public ByteString GetObjectIDBytes()
				{
					object @ref = objectID_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						objectID_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public CoreNLPProtos.Relation.Builder SetObjectID(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					objectID_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public CoreNLPProtos.Relation.Builder ClearObjectID()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					objectID_ = GetDefaultInstance().GetObjectID();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// inherited from ExtractionObject
				/// </pre>
				/// <code>optional string objectID = 1;</code>
				/// </summary>
				public CoreNLPProtos.Relation.Builder SetObjectIDBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					objectID_ = value;
					OnChanged();
					return this;
				}

				private int extentStart_;

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public bool HasExtentStart()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public int GetExtentStart()
				{
					return extentStart_;
				}

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public CoreNLPProtos.Relation.Builder SetExtentStart(int value)
				{
					bitField0_ |= unchecked((int)(0x00000010));
					extentStart_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 extentStart = 2;</code></summary>
				public CoreNLPProtos.Relation.Builder ClearExtentStart()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					extentStart_ = 0;
					OnChanged();
					return this;
				}

				private int extentEnd_;

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public bool HasExtentEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public int GetExtentEnd()
				{
					return extentEnd_;
				}

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public CoreNLPProtos.Relation.Builder SetExtentEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000020));
					extentEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 extentEnd = 3;</code></summary>
				public CoreNLPProtos.Relation.Builder ClearExtentEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					extentEnd_ = 0;
					OnChanged();
					return this;
				}

				private object type_ = string.Empty;

				/// <summary><code>optional string type = 4;</code></summary>
				public bool HasType()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public string GetType()
				{
					object @ref = type_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							type_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public ByteString GetTypeBytes()
				{
					object @ref = type_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						type_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Relation.Builder SetType(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000040));
					type_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Relation.Builder ClearType()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					type_ = GetDefaultInstance().GetType();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string type = 4;</code></summary>
				public CoreNLPProtos.Relation.Builder SetTypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000040));
					type_ = value;
					OnChanged();
					return this;
				}

				private object subtype_ = string.Empty;

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public bool HasSubtype()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public string GetSubtype()
				{
					object @ref = subtype_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							subtype_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public ByteString GetSubtypeBytes()
				{
					object @ref = subtype_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						subtype_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public CoreNLPProtos.Relation.Builder SetSubtype(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					subtype_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public CoreNLPProtos.Relation.Builder ClearSubtype()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					subtype_ = GetDefaultInstance().GetSubtype();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// Implicit
				/// uint32 sentence       &#64;see implicit in sentence
				/// </pre>
				/// <code>optional string subtype = 5;</code>
				/// </summary>
				public CoreNLPProtos.Relation.Builder SetSubtypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					subtype_ = value;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Relation.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Relation)
			}

			private static readonly CoreNLPProtos.Relation DefaultInstance;

			static Relation()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Relation)
				DefaultInstance = new CoreNLPProtos.Relation();
			}

			public static CoreNLPProtos.Relation GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_48946 : AbstractParser<CoreNLPProtos.Relation>
			{
				public _AbstractParser_48946()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Relation ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Relation(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Relation> Parser = new _AbstractParser_48946();

			public static IParser<CoreNLPProtos.Relation> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IOperatorOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Operator)
			/// <summary><code>required string name = 1;</code></summary>
			bool HasName();

			/// <summary><code>required string name = 1;</code></summary>
			string GetName();

			/// <summary><code>required string name = 1;</code></summary>
			ByteString GetNameBytes();

			/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
			bool HasQuantifierSpanBegin();

			/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
			int GetQuantifierSpanBegin();

			/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
			bool HasQuantifierSpanEnd();

			/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
			int GetQuantifierSpanEnd();

			/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
			bool HasSubjectSpanBegin();

			/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
			int GetSubjectSpanBegin();

			/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
			bool HasSubjectSpanEnd();

			/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
			int GetSubjectSpanEnd();

			/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
			bool HasObjectSpanBegin();

			/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
			int GetObjectSpanBegin();

			/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
			bool HasObjectSpanEnd();

			/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
			int GetObjectSpanEnd();
		}

		/// <summary>
		/// <pre>
		/// A Natural Logic operator
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Operator</c>
		/// </summary>
		[System.Serializable]
		public sealed class Operator : GeneratedMessageV3, CoreNLPProtos.IOperatorOrBuilder
		{
			private Operator(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Operator()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Operator)
				// Use Operator.newBuilder() to construct.
				name_ = string.Empty;
				quantifierSpanBegin_ = 0;
				quantifierSpanEnd_ = 0;
				subjectSpanBegin_ = 0;
				subjectSpanEnd_ = 0;
				objectSpanBegin_ = 0;
				objectSpanEnd_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Operator(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								name_ = bs;
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								quantifierSpanBegin_ = input.ReadInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								quantifierSpanEnd_ = input.ReadInt32();
								break;
							}

							case 32:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								subjectSpanBegin_ = input.ReadInt32();
								break;
							}

							case 40:
							{
								bitField0_ |= unchecked((int)(0x00000010));
								subjectSpanEnd_ = input.ReadInt32();
								break;
							}

							case 48:
							{
								bitField0_ |= unchecked((int)(0x00000020));
								objectSpanBegin_ = input.ReadInt32();
								break;
							}

							case 56:
							{
								bitField0_ |= unchecked((int)(0x00000040));
								objectSpanEnd_ = input.ReadInt32();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Operator_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Operator_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Operator), typeof(CoreNLPProtos.Operator.Builder));
			}

			private int bitField0_;

			public const int NameFieldNumber = 1;

			private volatile object name_;

			/// <summary><code>required string name = 1;</code></summary>
			public bool HasName()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>required string name = 1;</code></summary>
			public string GetName()
			{
				object @ref = name_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						name_ = s;
					}
					return s;
				}
			}

			/// <summary><code>required string name = 1;</code></summary>
			public ByteString GetNameBytes()
			{
				object @ref = name_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					name_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int QuantifierspanbeginFieldNumber = 2;

			private int quantifierSpanBegin_;

			/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
			public bool HasQuantifierSpanBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
			public int GetQuantifierSpanBegin()
			{
				return quantifierSpanBegin_;
			}

			public const int QuantifierspanendFieldNumber = 3;

			private int quantifierSpanEnd_;

			/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
			public bool HasQuantifierSpanEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
			public int GetQuantifierSpanEnd()
			{
				return quantifierSpanEnd_;
			}

			public const int SubjectspanbeginFieldNumber = 4;

			private int subjectSpanBegin_;

			/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
			public bool HasSubjectSpanBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
			public int GetSubjectSpanBegin()
			{
				return subjectSpanBegin_;
			}

			public const int SubjectspanendFieldNumber = 5;

			private int subjectSpanEnd_;

			/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
			public bool HasSubjectSpanEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
			public int GetSubjectSpanEnd()
			{
				return subjectSpanEnd_;
			}

			public const int ObjectspanbeginFieldNumber = 6;

			private int objectSpanBegin_;

			/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
			public bool HasObjectSpanBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
			public int GetObjectSpanBegin()
			{
				return objectSpanBegin_;
			}

			public const int ObjectspanendFieldNumber = 7;

			private int objectSpanEnd_;

			/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
			public bool HasObjectSpanEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
			public int GetObjectSpanEnd()
			{
				return objectSpanEnd_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasName())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasQuantifierSpanBegin())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasQuantifierSpanEnd())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasSubjectSpanBegin())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasSubjectSpanEnd())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasObjectSpanBegin())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasObjectSpanEnd())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 1, name_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteInt32(2, quantifierSpanBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteInt32(3, quantifierSpanEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteInt32(4, subjectSpanBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteInt32(5, subjectSpanEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteInt32(6, objectSpanBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteInt32(7, objectSpanEnd_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, name_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeInt32Size(2, quantifierSpanBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeInt32Size(3, quantifierSpanEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeInt32Size(4, subjectSpanBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeInt32Size(5, subjectSpanEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeInt32Size(6, objectSpanBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeInt32Size(7, objectSpanEnd_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Operator))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Operator other = (CoreNLPProtos.Operator)obj;
				bool result = true;
				result = result && (HasName() == other.HasName());
				if (HasName())
				{
					result = result && GetName().Equals(other.GetName());
				}
				result = result && (HasQuantifierSpanBegin() == other.HasQuantifierSpanBegin());
				if (HasQuantifierSpanBegin())
				{
					result = result && (GetQuantifierSpanBegin() == other.GetQuantifierSpanBegin());
				}
				result = result && (HasQuantifierSpanEnd() == other.HasQuantifierSpanEnd());
				if (HasQuantifierSpanEnd())
				{
					result = result && (GetQuantifierSpanEnd() == other.GetQuantifierSpanEnd());
				}
				result = result && (HasSubjectSpanBegin() == other.HasSubjectSpanBegin());
				if (HasSubjectSpanBegin())
				{
					result = result && (GetSubjectSpanBegin() == other.GetSubjectSpanBegin());
				}
				result = result && (HasSubjectSpanEnd() == other.HasSubjectSpanEnd());
				if (HasSubjectSpanEnd())
				{
					result = result && (GetSubjectSpanEnd() == other.GetSubjectSpanEnd());
				}
				result = result && (HasObjectSpanBegin() == other.HasObjectSpanBegin());
				if (HasObjectSpanBegin())
				{
					result = result && (GetObjectSpanBegin() == other.GetObjectSpanBegin());
				}
				result = result && (HasObjectSpanEnd() == other.HasObjectSpanEnd());
				if (HasObjectSpanEnd())
				{
					result = result && (GetObjectSpanEnd() == other.GetObjectSpanEnd());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasName())
				{
					hash = (37 * hash) + NameFieldNumber;
					hash = (53 * hash) + GetName().GetHashCode();
				}
				if (HasQuantifierSpanBegin())
				{
					hash = (37 * hash) + QuantifierspanbeginFieldNumber;
					hash = (53 * hash) + GetQuantifierSpanBegin();
				}
				if (HasQuantifierSpanEnd())
				{
					hash = (37 * hash) + QuantifierspanendFieldNumber;
					hash = (53 * hash) + GetQuantifierSpanEnd();
				}
				if (HasSubjectSpanBegin())
				{
					hash = (37 * hash) + SubjectspanbeginFieldNumber;
					hash = (53 * hash) + GetSubjectSpanBegin();
				}
				if (HasSubjectSpanEnd())
				{
					hash = (37 * hash) + SubjectspanendFieldNumber;
					hash = (53 * hash) + GetSubjectSpanEnd();
				}
				if (HasObjectSpanBegin())
				{
					hash = (37 * hash) + ObjectspanbeginFieldNumber;
					hash = (53 * hash) + GetObjectSpanBegin();
				}
				if (HasObjectSpanEnd())
				{
					hash = (37 * hash) + ObjectspanendFieldNumber;
					hash = (53 * hash) + GetObjectSpanEnd();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Operator ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Operator ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Operator ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Operator ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Operator ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Operator ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Operator ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Operator ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Operator ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Operator ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Operator.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Operator.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Operator.Builder NewBuilder(CoreNLPProtos.Operator prototype)
			{
				return ((CoreNLPProtos.Operator.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Operator.Builder() : new CoreNLPProtos.Operator.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Operator.Builder builder = new CoreNLPProtos.Operator.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A Natural Logic operator
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Operator</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Operator.Builder>, CoreNLPProtos.IOperatorOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Operator)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Operator_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Operator_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Operator), typeof(CoreNLPProtos.Operator.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Operator.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					name_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					quantifierSpanBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					quantifierSpanEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					subjectSpanBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					subjectSpanEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					objectSpanBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					objectSpanEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Operator_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Operator.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Operator result = ((CoreNLPProtos.Operator)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Operator result = new CoreNLPProtos.Operator(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.name_ = name_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.quantifierSpanBegin_ = quantifierSpanBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.quantifierSpanEnd_ = quantifierSpanEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.subjectSpanBegin_ = subjectSpanBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.subjectSpanEnd_ = subjectSpanEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.objectSpanBegin_ = objectSpanBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.objectSpanEnd_ = objectSpanEnd_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Operator.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Operator.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Operator.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Operator.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Operator.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Operator.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Operator.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Operator.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Operator)
					{
						return MergeFrom((CoreNLPProtos.Operator)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Operator.Builder MergeFrom(CoreNLPProtos.Operator other)
				{
					if (other == CoreNLPProtos.Operator.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasName())
					{
						bitField0_ |= unchecked((int)(0x00000001));
						name_ = other.name_;
						OnChanged();
					}
					if (other.HasQuantifierSpanBegin())
					{
						SetQuantifierSpanBegin(other.GetQuantifierSpanBegin());
					}
					if (other.HasQuantifierSpanEnd())
					{
						SetQuantifierSpanEnd(other.GetQuantifierSpanEnd());
					}
					if (other.HasSubjectSpanBegin())
					{
						SetSubjectSpanBegin(other.GetSubjectSpanBegin());
					}
					if (other.HasSubjectSpanEnd())
					{
						SetSubjectSpanEnd(other.GetSubjectSpanEnd());
					}
					if (other.HasObjectSpanBegin())
					{
						SetObjectSpanBegin(other.GetObjectSpanBegin());
					}
					if (other.HasObjectSpanEnd())
					{
						SetObjectSpanEnd(other.GetObjectSpanEnd());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasName())
					{
						return false;
					}
					if (!HasQuantifierSpanBegin())
					{
						return false;
					}
					if (!HasQuantifierSpanEnd())
					{
						return false;
					}
					if (!HasSubjectSpanBegin())
					{
						return false;
					}
					if (!HasSubjectSpanEnd())
					{
						return false;
					}
					if (!HasObjectSpanBegin())
					{
						return false;
					}
					if (!HasObjectSpanEnd())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Operator parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Operator)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private object name_ = string.Empty;

				/// <summary><code>required string name = 1;</code></summary>
				public bool HasName()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required string name = 1;</code></summary>
				public string GetName()
				{
					object @ref = name_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							name_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>required string name = 1;</code></summary>
				public ByteString GetNameBytes()
				{
					object @ref = name_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						name_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>required string name = 1;</code></summary>
				public CoreNLPProtos.Operator.Builder SetName(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					name_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required string name = 1;</code></summary>
				public CoreNLPProtos.Operator.Builder ClearName()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					name_ = GetDefaultInstance().GetName();
					OnChanged();
					return this;
				}

				/// <summary><code>required string name = 1;</code></summary>
				public CoreNLPProtos.Operator.Builder SetNameBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					name_ = value;
					OnChanged();
					return this;
				}

				private int quantifierSpanBegin_;

				/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
				public bool HasQuantifierSpanBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
				public int GetQuantifierSpanBegin()
				{
					return quantifierSpanBegin_;
				}

				/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
				public CoreNLPProtos.Operator.Builder SetQuantifierSpanBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					quantifierSpanBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required int32 quantifierSpanBegin = 2;</code></summary>
				public CoreNLPProtos.Operator.Builder ClearQuantifierSpanBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					quantifierSpanBegin_ = 0;
					OnChanged();
					return this;
				}

				private int quantifierSpanEnd_;

				/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
				public bool HasQuantifierSpanEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
				public int GetQuantifierSpanEnd()
				{
					return quantifierSpanEnd_;
				}

				/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
				public CoreNLPProtos.Operator.Builder SetQuantifierSpanEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					quantifierSpanEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required int32 quantifierSpanEnd = 3;</code></summary>
				public CoreNLPProtos.Operator.Builder ClearQuantifierSpanEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					quantifierSpanEnd_ = 0;
					OnChanged();
					return this;
				}

				private int subjectSpanBegin_;

				/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
				public bool HasSubjectSpanBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
				public int GetSubjectSpanBegin()
				{
					return subjectSpanBegin_;
				}

				/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
				public CoreNLPProtos.Operator.Builder SetSubjectSpanBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000008));
					subjectSpanBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required int32 subjectSpanBegin = 4;</code></summary>
				public CoreNLPProtos.Operator.Builder ClearSubjectSpanBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					subjectSpanBegin_ = 0;
					OnChanged();
					return this;
				}

				private int subjectSpanEnd_;

				/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
				public bool HasSubjectSpanEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
				public int GetSubjectSpanEnd()
				{
					return subjectSpanEnd_;
				}

				/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
				public CoreNLPProtos.Operator.Builder SetSubjectSpanEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000010));
					subjectSpanEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required int32 subjectSpanEnd = 5;</code></summary>
				public CoreNLPProtos.Operator.Builder ClearSubjectSpanEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					subjectSpanEnd_ = 0;
					OnChanged();
					return this;
				}

				private int objectSpanBegin_;

				/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
				public bool HasObjectSpanBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
				public int GetObjectSpanBegin()
				{
					return objectSpanBegin_;
				}

				/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
				public CoreNLPProtos.Operator.Builder SetObjectSpanBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000020));
					objectSpanBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required int32 objectSpanBegin = 6;</code></summary>
				public CoreNLPProtos.Operator.Builder ClearObjectSpanBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					objectSpanBegin_ = 0;
					OnChanged();
					return this;
				}

				private int objectSpanEnd_;

				/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
				public bool HasObjectSpanEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
				public int GetObjectSpanEnd()
				{
					return objectSpanEnd_;
				}

				/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
				public CoreNLPProtos.Operator.Builder SetObjectSpanEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000040));
					objectSpanEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required int32 objectSpanEnd = 7;</code></summary>
				public CoreNLPProtos.Operator.Builder ClearObjectSpanEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					objectSpanEnd_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Operator.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Operator)
			}

			private static readonly CoreNLPProtos.Operator DefaultInstance;

			static Operator()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Operator)
				DefaultInstance = new CoreNLPProtos.Operator();
			}

			public static CoreNLPProtos.Operator GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_50069 : AbstractParser<CoreNLPProtos.Operator>
			{
				public _AbstractParser_50069()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Operator ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Operator(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Operator> Parser = new _AbstractParser_50069();

			public static IParser<CoreNLPProtos.Operator> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IPolarityOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Polarity)
			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
			bool HasProjectEquivalence();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
			CoreNLPProtos.NaturalLogicRelation GetProjectEquivalence();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
			bool HasProjectForwardEntailment();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
			CoreNLPProtos.NaturalLogicRelation GetProjectForwardEntailment();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
			bool HasProjectReverseEntailment();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
			CoreNLPProtos.NaturalLogicRelation GetProjectReverseEntailment();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
			bool HasProjectNegation();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
			CoreNLPProtos.NaturalLogicRelation GetProjectNegation();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
			bool HasProjectAlternation();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
			CoreNLPProtos.NaturalLogicRelation GetProjectAlternation();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
			bool HasProjectCover();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
			CoreNLPProtos.NaturalLogicRelation GetProjectCover();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
			bool HasProjectIndependence();

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
			CoreNLPProtos.NaturalLogicRelation GetProjectIndependence();
		}

		/// <summary>
		/// <pre>
		/// The polarity of a word, according to Natural Logic
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Polarity</c>
		/// </summary>
		[System.Serializable]
		public sealed class Polarity : GeneratedMessageV3, CoreNLPProtos.IPolarityOrBuilder
		{
			private Polarity(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Polarity()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Polarity)
				// Use Polarity.newBuilder() to construct.
				projectEquivalence_ = 0;
				projectForwardEntailment_ = 0;
				projectReverseEntailment_ = 0;
				projectNegation_ = 0;
				projectAlternation_ = 0;
				projectCover_ = 0;
				projectIndependence_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Polarity(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.NaturalLogicRelation value = CoreNLPProtos.NaturalLogicRelation.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(1, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000001));
									projectEquivalence_ = rawValue;
								}
								break;
							}

							case 16:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.NaturalLogicRelation value = CoreNLPProtos.NaturalLogicRelation.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(2, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000002));
									projectForwardEntailment_ = rawValue;
								}
								break;
							}

							case 24:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.NaturalLogicRelation value = CoreNLPProtos.NaturalLogicRelation.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(3, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000004));
									projectReverseEntailment_ = rawValue;
								}
								break;
							}

							case 32:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.NaturalLogicRelation value = CoreNLPProtos.NaturalLogicRelation.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(4, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000008));
									projectNegation_ = rawValue;
								}
								break;
							}

							case 40:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.NaturalLogicRelation value = CoreNLPProtos.NaturalLogicRelation.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(5, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000010));
									projectAlternation_ = rawValue;
								}
								break;
							}

							case 48:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.NaturalLogicRelation value = CoreNLPProtos.NaturalLogicRelation.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(6, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000020));
									projectCover_ = rawValue;
								}
								break;
							}

							case 56:
							{
								int rawValue = input.ReadEnum();
								CoreNLPProtos.NaturalLogicRelation value = CoreNLPProtos.NaturalLogicRelation.ValueOf(rawValue);
								if (value == null)
								{
									unknownFields.MergeVarintField(7, rawValue);
								}
								else
								{
									bitField0_ |= unchecked((int)(0x00000040));
									projectIndependence_ = rawValue;
								}
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Polarity_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Polarity_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Polarity), typeof(CoreNLPProtos.Polarity.Builder));
			}

			private int bitField0_;

			public const int ProjectequivalenceFieldNumber = 1;

			private int projectEquivalence_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
			public bool HasProjectEquivalence()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
			public CoreNLPProtos.NaturalLogicRelation GetProjectEquivalence()
			{
				CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectEquivalence_);
				return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
			}

			public const int ProjectforwardentailmentFieldNumber = 2;

			private int projectForwardEntailment_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
			public bool HasProjectForwardEntailment()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
			public CoreNLPProtos.NaturalLogicRelation GetProjectForwardEntailment()
			{
				CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectForwardEntailment_);
				return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
			}

			public const int ProjectreverseentailmentFieldNumber = 3;

			private int projectReverseEntailment_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
			public bool HasProjectReverseEntailment()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
			public CoreNLPProtos.NaturalLogicRelation GetProjectReverseEntailment()
			{
				CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectReverseEntailment_);
				return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
			}

			public const int ProjectnegationFieldNumber = 4;

			private int projectNegation_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
			public bool HasProjectNegation()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
			public CoreNLPProtos.NaturalLogicRelation GetProjectNegation()
			{
				CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectNegation_);
				return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
			}

			public const int ProjectalternationFieldNumber = 5;

			private int projectAlternation_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
			public bool HasProjectAlternation()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
			public CoreNLPProtos.NaturalLogicRelation GetProjectAlternation()
			{
				CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectAlternation_);
				return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
			}

			public const int ProjectcoverFieldNumber = 6;

			private int projectCover_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
			public bool HasProjectCover()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
			public CoreNLPProtos.NaturalLogicRelation GetProjectCover()
			{
				CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectCover_);
				return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
			}

			public const int ProjectindependenceFieldNumber = 7;

			private int projectIndependence_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
			public bool HasProjectIndependence()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
			public CoreNLPProtos.NaturalLogicRelation GetProjectIndependence()
			{
				CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectIndependence_);
				return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasProjectEquivalence())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasProjectForwardEntailment())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasProjectReverseEntailment())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasProjectNegation())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasProjectAlternation())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasProjectCover())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasProjectIndependence())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteEnum(1, projectEquivalence_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteEnum(2, projectForwardEntailment_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteEnum(3, projectReverseEntailment_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteEnum(4, projectNegation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteEnum(5, projectAlternation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteEnum(6, projectCover_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteEnum(7, projectIndependence_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeEnumSize(1, projectEquivalence_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeEnumSize(2, projectForwardEntailment_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeEnumSize(3, projectReverseEntailment_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeEnumSize(4, projectNegation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeEnumSize(5, projectAlternation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeEnumSize(6, projectCover_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeEnumSize(7, projectIndependence_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Polarity))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Polarity other = (CoreNLPProtos.Polarity)obj;
				bool result = true;
				result = result && (HasProjectEquivalence() == other.HasProjectEquivalence());
				if (HasProjectEquivalence())
				{
					result = result && projectEquivalence_ == other.projectEquivalence_;
				}
				result = result && (HasProjectForwardEntailment() == other.HasProjectForwardEntailment());
				if (HasProjectForwardEntailment())
				{
					result = result && projectForwardEntailment_ == other.projectForwardEntailment_;
				}
				result = result && (HasProjectReverseEntailment() == other.HasProjectReverseEntailment());
				if (HasProjectReverseEntailment())
				{
					result = result && projectReverseEntailment_ == other.projectReverseEntailment_;
				}
				result = result && (HasProjectNegation() == other.HasProjectNegation());
				if (HasProjectNegation())
				{
					result = result && projectNegation_ == other.projectNegation_;
				}
				result = result && (HasProjectAlternation() == other.HasProjectAlternation());
				if (HasProjectAlternation())
				{
					result = result && projectAlternation_ == other.projectAlternation_;
				}
				result = result && (HasProjectCover() == other.HasProjectCover());
				if (HasProjectCover())
				{
					result = result && projectCover_ == other.projectCover_;
				}
				result = result && (HasProjectIndependence() == other.HasProjectIndependence());
				if (HasProjectIndependence())
				{
					result = result && projectIndependence_ == other.projectIndependence_;
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasProjectEquivalence())
				{
					hash = (37 * hash) + ProjectequivalenceFieldNumber;
					hash = (53 * hash) + projectEquivalence_;
				}
				if (HasProjectForwardEntailment())
				{
					hash = (37 * hash) + ProjectforwardentailmentFieldNumber;
					hash = (53 * hash) + projectForwardEntailment_;
				}
				if (HasProjectReverseEntailment())
				{
					hash = (37 * hash) + ProjectreverseentailmentFieldNumber;
					hash = (53 * hash) + projectReverseEntailment_;
				}
				if (HasProjectNegation())
				{
					hash = (37 * hash) + ProjectnegationFieldNumber;
					hash = (53 * hash) + projectNegation_;
				}
				if (HasProjectAlternation())
				{
					hash = (37 * hash) + ProjectalternationFieldNumber;
					hash = (53 * hash) + projectAlternation_;
				}
				if (HasProjectCover())
				{
					hash = (37 * hash) + ProjectcoverFieldNumber;
					hash = (53 * hash) + projectCover_;
				}
				if (HasProjectIndependence())
				{
					hash = (37 * hash) + ProjectindependenceFieldNumber;
					hash = (53 * hash) + projectIndependence_;
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Polarity ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Polarity ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Polarity ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Polarity ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Polarity ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Polarity ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Polarity ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Polarity ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Polarity ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Polarity ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Polarity.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Polarity.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Polarity.Builder NewBuilder(CoreNLPProtos.Polarity prototype)
			{
				return ((CoreNLPProtos.Polarity.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Polarity.Builder() : new CoreNLPProtos.Polarity.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Polarity.Builder builder = new CoreNLPProtos.Polarity.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// The polarity of a word, according to Natural Logic
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Polarity</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Polarity.Builder>, CoreNLPProtos.IPolarityOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Polarity)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Polarity_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Polarity_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Polarity), typeof(CoreNLPProtos.Polarity.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Polarity.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					projectEquivalence_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					projectForwardEntailment_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					projectReverseEntailment_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					projectNegation_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					projectAlternation_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					projectCover_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					projectIndependence_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Polarity_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Polarity.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Polarity result = ((CoreNLPProtos.Polarity)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Polarity result = new CoreNLPProtos.Polarity(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.projectEquivalence_ = projectEquivalence_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.projectForwardEntailment_ = projectForwardEntailment_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.projectReverseEntailment_ = projectReverseEntailment_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.projectNegation_ = projectNegation_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.projectAlternation_ = projectAlternation_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.projectCover_ = projectCover_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.projectIndependence_ = projectIndependence_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Polarity.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Polarity.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Polarity.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Polarity.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Polarity.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Polarity.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Polarity.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Polarity.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Polarity)
					{
						return MergeFrom((CoreNLPProtos.Polarity)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Polarity.Builder MergeFrom(CoreNLPProtos.Polarity other)
				{
					if (other == CoreNLPProtos.Polarity.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasProjectEquivalence())
					{
						SetProjectEquivalence(other.GetProjectEquivalence());
					}
					if (other.HasProjectForwardEntailment())
					{
						SetProjectForwardEntailment(other.GetProjectForwardEntailment());
					}
					if (other.HasProjectReverseEntailment())
					{
						SetProjectReverseEntailment(other.GetProjectReverseEntailment());
					}
					if (other.HasProjectNegation())
					{
						SetProjectNegation(other.GetProjectNegation());
					}
					if (other.HasProjectAlternation())
					{
						SetProjectAlternation(other.GetProjectAlternation());
					}
					if (other.HasProjectCover())
					{
						SetProjectCover(other.GetProjectCover());
					}
					if (other.HasProjectIndependence())
					{
						SetProjectIndependence(other.GetProjectIndependence());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasProjectEquivalence())
					{
						return false;
					}
					if (!HasProjectForwardEntailment())
					{
						return false;
					}
					if (!HasProjectReverseEntailment())
					{
						return false;
					}
					if (!HasProjectNegation())
					{
						return false;
					}
					if (!HasProjectAlternation())
					{
						return false;
					}
					if (!HasProjectCover())
					{
						return false;
					}
					if (!HasProjectIndependence())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Polarity parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Polarity)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int projectEquivalence_ = 0;

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
				public bool HasProjectEquivalence()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
				public CoreNLPProtos.NaturalLogicRelation GetProjectEquivalence()
				{
					CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectEquivalence_);
					return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
				public CoreNLPProtos.Polarity.Builder SetProjectEquivalence(CoreNLPProtos.NaturalLogicRelation value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					projectEquivalence_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;</code></summary>
				public CoreNLPProtos.Polarity.Builder ClearProjectEquivalence()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					projectEquivalence_ = 0;
					OnChanged();
					return this;
				}

				private int projectForwardEntailment_ = 0;

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
				public bool HasProjectForwardEntailment()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
				public CoreNLPProtos.NaturalLogicRelation GetProjectForwardEntailment()
				{
					CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectForwardEntailment_);
					return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
				public CoreNLPProtos.Polarity.Builder SetProjectForwardEntailment(CoreNLPProtos.NaturalLogicRelation value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					projectForwardEntailment_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;</code></summary>
				public CoreNLPProtos.Polarity.Builder ClearProjectForwardEntailment()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					projectForwardEntailment_ = 0;
					OnChanged();
					return this;
				}

				private int projectReverseEntailment_ = 0;

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
				public bool HasProjectReverseEntailment()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
				public CoreNLPProtos.NaturalLogicRelation GetProjectReverseEntailment()
				{
					CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectReverseEntailment_);
					return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
				public CoreNLPProtos.Polarity.Builder SetProjectReverseEntailment(CoreNLPProtos.NaturalLogicRelation value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					projectReverseEntailment_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;</code></summary>
				public CoreNLPProtos.Polarity.Builder ClearProjectReverseEntailment()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					projectReverseEntailment_ = 0;
					OnChanged();
					return this;
				}

				private int projectNegation_ = 0;

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
				public bool HasProjectNegation()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
				public CoreNLPProtos.NaturalLogicRelation GetProjectNegation()
				{
					CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectNegation_);
					return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
				public CoreNLPProtos.Polarity.Builder SetProjectNegation(CoreNLPProtos.NaturalLogicRelation value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					projectNegation_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;</code></summary>
				public CoreNLPProtos.Polarity.Builder ClearProjectNegation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					projectNegation_ = 0;
					OnChanged();
					return this;
				}

				private int projectAlternation_ = 0;

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
				public bool HasProjectAlternation()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
				public CoreNLPProtos.NaturalLogicRelation GetProjectAlternation()
				{
					CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectAlternation_);
					return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
				public CoreNLPProtos.Polarity.Builder SetProjectAlternation(CoreNLPProtos.NaturalLogicRelation value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					projectAlternation_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;</code></summary>
				public CoreNLPProtos.Polarity.Builder ClearProjectAlternation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					projectAlternation_ = 0;
					OnChanged();
					return this;
				}

				private int projectCover_ = 0;

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
				public bool HasProjectCover()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
				public CoreNLPProtos.NaturalLogicRelation GetProjectCover()
				{
					CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectCover_);
					return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
				public CoreNLPProtos.Polarity.Builder SetProjectCover(CoreNLPProtos.NaturalLogicRelation value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					projectCover_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;</code></summary>
				public CoreNLPProtos.Polarity.Builder ClearProjectCover()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					projectCover_ = 0;
					OnChanged();
					return this;
				}

				private int projectIndependence_ = 0;

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
				public bool HasProjectIndependence()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
				public CoreNLPProtos.NaturalLogicRelation GetProjectIndependence()
				{
					CoreNLPProtos.NaturalLogicRelation result = CoreNLPProtos.NaturalLogicRelation.ValueOf(projectIndependence_);
					return result == null ? CoreNLPProtos.NaturalLogicRelation.Equivalence : result;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
				public CoreNLPProtos.Polarity.Builder SetProjectIndependence(CoreNLPProtos.NaturalLogicRelation value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000040));
					projectIndependence_ = value.GetNumber();
					OnChanged();
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;</code></summary>
				public CoreNLPProtos.Polarity.Builder ClearProjectIndependence()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					projectIndependence_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Polarity.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Polarity)
			}

			private static readonly CoreNLPProtos.Polarity DefaultInstance;

			static Polarity()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Polarity)
				DefaultInstance = new CoreNLPProtos.Polarity();
			}

			public static CoreNLPProtos.Polarity GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_51184 : AbstractParser<CoreNLPProtos.Polarity>
			{
				public _AbstractParser_51184()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Polarity ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Polarity(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Polarity> Parser = new _AbstractParser_51184();

			public static IParser<CoreNLPProtos.Polarity> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface INERMentionOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.NERMention)
			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			bool HasSentenceIndex();

			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			int GetSentenceIndex();

			/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
			bool HasTokenStartInSentenceInclusive();

			/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
			int GetTokenStartInSentenceInclusive();

			/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
			bool HasTokenEndInSentenceExclusive();

			/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
			int GetTokenEndInSentenceExclusive();

			/// <summary><code>required string ner = 4;</code></summary>
			bool HasNer();

			/// <summary><code>required string ner = 4;</code></summary>
			string GetNer();

			/// <summary><code>required string ner = 4;</code></summary>
			ByteString GetNerBytes();

			/// <summary><code>optional string normalizedNER = 5;</code></summary>
			bool HasNormalizedNER();

			/// <summary><code>optional string normalizedNER = 5;</code></summary>
			string GetNormalizedNER();

			/// <summary><code>optional string normalizedNER = 5;</code></summary>
			ByteString GetNormalizedNERBytes();

			/// <summary><code>optional string entityType = 6;</code></summary>
			bool HasEntityType();

			/// <summary><code>optional string entityType = 6;</code></summary>
			string GetEntityType();

			/// <summary><code>optional string entityType = 6;</code></summary>
			ByteString GetEntityTypeBytes();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
			bool HasTimex();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
			CoreNLPProtos.Timex GetTimex();

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
			CoreNLPProtos.ITimexOrBuilder GetTimexOrBuilder();

			/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
			bool HasWikipediaEntity();

			/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
			string GetWikipediaEntity();

			/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
			ByteString GetWikipediaEntityBytes();

			/// <summary><code>optional string gender = 9;</code></summary>
			bool HasGender();

			/// <summary><code>optional string gender = 9;</code></summary>
			string GetGender();

			/// <summary><code>optional string gender = 9;</code></summary>
			ByteString GetGenderBytes();

			/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
			bool HasEntityMentionIndex();

			/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
			int GetEntityMentionIndex();

			/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
			bool HasCanonicalEntityMentionIndex();

			/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
			int GetCanonicalEntityMentionIndex();

			/// <summary><code>optional string entityMentionText = 12;</code></summary>
			bool HasEntityMentionText();

			/// <summary><code>optional string entityMentionText = 12;</code></summary>
			string GetEntityMentionText();

			/// <summary><code>optional string entityMentionText = 12;</code></summary>
			ByteString GetEntityMentionTextBytes();
		}

		/// <summary>
		/// <pre>
		/// An NER mention in the text
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.NERMention</c>
		/// </summary>
		[System.Serializable]
		public sealed class NERMention : GeneratedMessageV3, CoreNLPProtos.INERMentionOrBuilder
		{
			private NERMention(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private NERMention()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.NERMention)
				// Use NERMention.newBuilder() to construct.
				sentenceIndex_ = 0;
				tokenStartInSentenceInclusive_ = 0;
				tokenEndInSentenceExclusive_ = 0;
				ner_ = string.Empty;
				normalizedNER_ = string.Empty;
				entityType_ = string.Empty;
				wikipediaEntity_ = string.Empty;
				gender_ = string.Empty;
				entityMentionIndex_ = 0;
				canonicalEntityMentionIndex_ = 0;
				entityMentionText_ = string.Empty;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private NERMention(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								sentenceIndex_ = input.ReadUInt32();
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								tokenStartInSentenceInclusive_ = input.ReadUInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								tokenEndInSentenceExclusive_ = input.ReadUInt32();
								break;
							}

							case 34:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000008));
								ner_ = bs;
								break;
							}

							case 42:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000010));
								normalizedNER_ = bs;
								break;
							}

							case 50:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000020));
								entityType_ = bs;
								break;
							}

							case 58:
							{
								CoreNLPProtos.Timex.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
								{
									subBuilder = ((CoreNLPProtos.Timex.Builder)timex_.ToBuilder());
								}
								timex_ = input.ReadMessage(CoreNLPProtos.Timex.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(timex_);
									timex_ = ((CoreNLPProtos.Timex)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000040));
								break;
							}

							case 66:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000080));
								wikipediaEntity_ = bs;
								break;
							}

							case 74:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000100));
								gender_ = bs;
								break;
							}

							case 80:
							{
								bitField0_ |= unchecked((int)(0x00000200));
								entityMentionIndex_ = input.ReadUInt32();
								break;
							}

							case 88:
							{
								bitField0_ |= unchecked((int)(0x00000400));
								canonicalEntityMentionIndex_ = input.ReadUInt32();
								break;
							}

							case 98:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000800));
								entityMentionText_ = bs;
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_NERMention_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_NERMention_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.NERMention), typeof(CoreNLPProtos.NERMention.Builder));
			}

			private int bitField0_;

			public const int SentenceindexFieldNumber = 1;

			private int sentenceIndex_;

			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			public bool HasSentenceIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			public int GetSentenceIndex()
			{
				return sentenceIndex_;
			}

			public const int TokenstartinsentenceinclusiveFieldNumber = 2;

			private int tokenStartInSentenceInclusive_;

			/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
			public bool HasTokenStartInSentenceInclusive()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
			public int GetTokenStartInSentenceInclusive()
			{
				return tokenStartInSentenceInclusive_;
			}

			public const int TokenendinsentenceexclusiveFieldNumber = 3;

			private int tokenEndInSentenceExclusive_;

			/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
			public bool HasTokenEndInSentenceExclusive()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
			public int GetTokenEndInSentenceExclusive()
			{
				return tokenEndInSentenceExclusive_;
			}

			public const int NerFieldNumber = 4;

			private volatile object ner_;

			/// <summary><code>required string ner = 4;</code></summary>
			public bool HasNer()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>required string ner = 4;</code></summary>
			public string GetNer()
			{
				object @ref = ner_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						ner_ = s;
					}
					return s;
				}
			}

			/// <summary><code>required string ner = 4;</code></summary>
			public ByteString GetNerBytes()
			{
				object @ref = ner_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					ner_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int NormalizednerFieldNumber = 5;

			private volatile object normalizedNER_;

			/// <summary><code>optional string normalizedNER = 5;</code></summary>
			public bool HasNormalizedNER()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional string normalizedNER = 5;</code></summary>
			public string GetNormalizedNER()
			{
				object @ref = normalizedNER_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						normalizedNER_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string normalizedNER = 5;</code></summary>
			public ByteString GetNormalizedNERBytes()
			{
				object @ref = normalizedNER_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					normalizedNER_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int EntitytypeFieldNumber = 6;

			private volatile object entityType_;

			/// <summary><code>optional string entityType = 6;</code></summary>
			public bool HasEntityType()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional string entityType = 6;</code></summary>
			public string GetEntityType()
			{
				object @ref = entityType_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						entityType_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string entityType = 6;</code></summary>
			public ByteString GetEntityTypeBytes()
			{
				object @ref = entityType_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					entityType_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int TimexFieldNumber = 7;

			private CoreNLPProtos.Timex timex_;

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
			public bool HasTimex()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
			public CoreNLPProtos.Timex GetTimex()
			{
				return timex_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timex_;
			}

			/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
			public CoreNLPProtos.ITimexOrBuilder GetTimexOrBuilder()
			{
				return timex_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timex_;
			}

			public const int WikipediaentityFieldNumber = 8;

			private volatile object wikipediaEntity_;

			/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
			public bool HasWikipediaEntity()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
			public string GetWikipediaEntity()
			{
				object @ref = wikipediaEntity_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						wikipediaEntity_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
			public ByteString GetWikipediaEntityBytes()
			{
				object @ref = wikipediaEntity_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					wikipediaEntity_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int GenderFieldNumber = 9;

			private volatile object gender_;

			/// <summary><code>optional string gender = 9;</code></summary>
			public bool HasGender()
			{
				return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary><code>optional string gender = 9;</code></summary>
			public string GetGender()
			{
				object @ref = gender_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						gender_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string gender = 9;</code></summary>
			public ByteString GetGenderBytes()
			{
				object @ref = gender_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					gender_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int EntitymentionindexFieldNumber = 10;

			private int entityMentionIndex_;

			/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
			public bool HasEntityMentionIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
			}

			/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
			public int GetEntityMentionIndex()
			{
				return entityMentionIndex_;
			}

			public const int CanonicalentitymentionindexFieldNumber = 11;

			private int canonicalEntityMentionIndex_;

			/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
			public bool HasCanonicalEntityMentionIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
			}

			/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
			public int GetCanonicalEntityMentionIndex()
			{
				return canonicalEntityMentionIndex_;
			}

			public const int EntitymentiontextFieldNumber = 12;

			private volatile object entityMentionText_;

			/// <summary><code>optional string entityMentionText = 12;</code></summary>
			public bool HasEntityMentionText()
			{
				return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
			}

			/// <summary><code>optional string entityMentionText = 12;</code></summary>
			public string GetEntityMentionText()
			{
				object @ref = entityMentionText_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						entityMentionText_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string entityMentionText = 12;</code></summary>
			public ByteString GetEntityMentionTextBytes()
			{
				object @ref = entityMentionText_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					entityMentionText_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasTokenStartInSentenceInclusive())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasTokenEndInSentenceExclusive())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasNer())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(1, sentenceIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(2, tokenStartInSentenceInclusive_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteUInt32(3, tokenEndInSentenceExclusive_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					GeneratedMessageV3.WriteString(output, 4, ner_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					GeneratedMessageV3.WriteString(output, 5, normalizedNER_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					GeneratedMessageV3.WriteString(output, 6, entityType_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteMessage(7, GetTimex());
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					GeneratedMessageV3.WriteString(output, 8, wikipediaEntity_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					GeneratedMessageV3.WriteString(output, 9, gender_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					output.WriteUInt32(10, entityMentionIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					output.WriteUInt32(11, canonicalEntityMentionIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					GeneratedMessageV3.WriteString(output, 12, entityMentionText_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(1, sentenceIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, tokenStartInSentenceInclusive_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeUInt32Size(3, tokenEndInSentenceExclusive_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += GeneratedMessageV3.ComputeStringSize(4, ner_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += GeneratedMessageV3.ComputeStringSize(5, normalizedNER_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += GeneratedMessageV3.ComputeStringSize(6, entityType_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeMessageSize(7, GetTimex());
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += GeneratedMessageV3.ComputeStringSize(8, wikipediaEntity_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += GeneratedMessageV3.ComputeStringSize(9, gender_);
				}
				if (((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
				{
					size += CodedOutputStream.ComputeUInt32Size(10, entityMentionIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
				{
					size += CodedOutputStream.ComputeUInt32Size(11, canonicalEntityMentionIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
				{
					size += GeneratedMessageV3.ComputeStringSize(12, entityMentionText_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.NERMention))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.NERMention other = (CoreNLPProtos.NERMention)obj;
				bool result = true;
				result = result && (HasSentenceIndex() == other.HasSentenceIndex());
				if (HasSentenceIndex())
				{
					result = result && (GetSentenceIndex() == other.GetSentenceIndex());
				}
				result = result && (HasTokenStartInSentenceInclusive() == other.HasTokenStartInSentenceInclusive());
				if (HasTokenStartInSentenceInclusive())
				{
					result = result && (GetTokenStartInSentenceInclusive() == other.GetTokenStartInSentenceInclusive());
				}
				result = result && (HasTokenEndInSentenceExclusive() == other.HasTokenEndInSentenceExclusive());
				if (HasTokenEndInSentenceExclusive())
				{
					result = result && (GetTokenEndInSentenceExclusive() == other.GetTokenEndInSentenceExclusive());
				}
				result = result && (HasNer() == other.HasNer());
				if (HasNer())
				{
					result = result && GetNer().Equals(other.GetNer());
				}
				result = result && (HasNormalizedNER() == other.HasNormalizedNER());
				if (HasNormalizedNER())
				{
					result = result && GetNormalizedNER().Equals(other.GetNormalizedNER());
				}
				result = result && (HasEntityType() == other.HasEntityType());
				if (HasEntityType())
				{
					result = result && GetEntityType().Equals(other.GetEntityType());
				}
				result = result && (HasTimex() == other.HasTimex());
				if (HasTimex())
				{
					result = result && GetTimex().Equals(other.GetTimex());
				}
				result = result && (HasWikipediaEntity() == other.HasWikipediaEntity());
				if (HasWikipediaEntity())
				{
					result = result && GetWikipediaEntity().Equals(other.GetWikipediaEntity());
				}
				result = result && (HasGender() == other.HasGender());
				if (HasGender())
				{
					result = result && GetGender().Equals(other.GetGender());
				}
				result = result && (HasEntityMentionIndex() == other.HasEntityMentionIndex());
				if (HasEntityMentionIndex())
				{
					result = result && (GetEntityMentionIndex() == other.GetEntityMentionIndex());
				}
				result = result && (HasCanonicalEntityMentionIndex() == other.HasCanonicalEntityMentionIndex());
				if (HasCanonicalEntityMentionIndex())
				{
					result = result && (GetCanonicalEntityMentionIndex() == other.GetCanonicalEntityMentionIndex());
				}
				result = result && (HasEntityMentionText() == other.HasEntityMentionText());
				if (HasEntityMentionText())
				{
					result = result && GetEntityMentionText().Equals(other.GetEntityMentionText());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasSentenceIndex())
				{
					hash = (37 * hash) + SentenceindexFieldNumber;
					hash = (53 * hash) + GetSentenceIndex();
				}
				if (HasTokenStartInSentenceInclusive())
				{
					hash = (37 * hash) + TokenstartinsentenceinclusiveFieldNumber;
					hash = (53 * hash) + GetTokenStartInSentenceInclusive();
				}
				if (HasTokenEndInSentenceExclusive())
				{
					hash = (37 * hash) + TokenendinsentenceexclusiveFieldNumber;
					hash = (53 * hash) + GetTokenEndInSentenceExclusive();
				}
				if (HasNer())
				{
					hash = (37 * hash) + NerFieldNumber;
					hash = (53 * hash) + GetNer().GetHashCode();
				}
				if (HasNormalizedNER())
				{
					hash = (37 * hash) + NormalizednerFieldNumber;
					hash = (53 * hash) + GetNormalizedNER().GetHashCode();
				}
				if (HasEntityType())
				{
					hash = (37 * hash) + EntitytypeFieldNumber;
					hash = (53 * hash) + GetEntityType().GetHashCode();
				}
				if (HasTimex())
				{
					hash = (37 * hash) + TimexFieldNumber;
					hash = (53 * hash) + GetTimex().GetHashCode();
				}
				if (HasWikipediaEntity())
				{
					hash = (37 * hash) + WikipediaentityFieldNumber;
					hash = (53 * hash) + GetWikipediaEntity().GetHashCode();
				}
				if (HasGender())
				{
					hash = (37 * hash) + GenderFieldNumber;
					hash = (53 * hash) + GetGender().GetHashCode();
				}
				if (HasEntityMentionIndex())
				{
					hash = (37 * hash) + EntitymentionindexFieldNumber;
					hash = (53 * hash) + GetEntityMentionIndex();
				}
				if (HasCanonicalEntityMentionIndex())
				{
					hash = (37 * hash) + CanonicalentitymentionindexFieldNumber;
					hash = (53 * hash) + GetCanonicalEntityMentionIndex();
				}
				if (HasEntityMentionText())
				{
					hash = (37 * hash) + EntitymentiontextFieldNumber;
					hash = (53 * hash) + GetEntityMentionText().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.NERMention ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.NERMention ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.NERMention ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.NERMention ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.NERMention ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.NERMention ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.NERMention ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.NERMention ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.NERMention ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.NERMention ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.NERMention.Builder NewBuilder()
			{
				return ((CoreNLPProtos.NERMention.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.NERMention.Builder NewBuilder(CoreNLPProtos.NERMention prototype)
			{
				return ((CoreNLPProtos.NERMention.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.NERMention.Builder() : new CoreNLPProtos.NERMention.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.NERMention.Builder builder = new CoreNLPProtos.NERMention.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// An NER mention in the text
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.NERMention</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.NERMention.Builder>, CoreNLPProtos.INERMentionOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.NERMention)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_NERMention_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_NERMention_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.NERMention), typeof(CoreNLPProtos.NERMention.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.NERMention.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetTimexFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					sentenceIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					tokenStartInSentenceInclusive_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					tokenEndInSentenceExclusive_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					ner_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					normalizedNER_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					entityType_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					if (timexBuilder_ == null)
					{
						timex_ = null;
					}
					else
					{
						timexBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					wikipediaEntity_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					gender_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					entityMentionIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					canonicalEntityMentionIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					entityMentionText_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_NERMention_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.NERMention.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.NERMention result = ((CoreNLPProtos.NERMention)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.NERMention result = new CoreNLPProtos.NERMention(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.sentenceIndex_ = sentenceIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.tokenStartInSentenceInclusive_ = tokenStartInSentenceInclusive_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.tokenEndInSentenceExclusive_ = tokenEndInSentenceExclusive_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.ner_ = ner_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.normalizedNER_ = normalizedNER_;
					if (((from_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.entityType_ = entityType_;
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					if (timexBuilder_ == null)
					{
						result.timex_ = timex_;
					}
					else
					{
						result.timex_ = timexBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					result.wikipediaEntity_ = wikipediaEntity_;
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000100));
					}
					result.gender_ = gender_;
					if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x00000200));
					}
					result.entityMentionIndex_ = entityMentionIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x00000400));
					}
					result.canonicalEntityMentionIndex_ = canonicalEntityMentionIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField0_ |= unchecked((int)(0x00000800));
					}
					result.entityMentionText_ = entityMentionText_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.NERMention.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.NERMention.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.NERMention.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.NERMention.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.NERMention.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.NERMention.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.NERMention.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.NERMention.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.NERMention)
					{
						return MergeFrom((CoreNLPProtos.NERMention)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.NERMention.Builder MergeFrom(CoreNLPProtos.NERMention other)
				{
					if (other == CoreNLPProtos.NERMention.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasSentenceIndex())
					{
						SetSentenceIndex(other.GetSentenceIndex());
					}
					if (other.HasTokenStartInSentenceInclusive())
					{
						SetTokenStartInSentenceInclusive(other.GetTokenStartInSentenceInclusive());
					}
					if (other.HasTokenEndInSentenceExclusive())
					{
						SetTokenEndInSentenceExclusive(other.GetTokenEndInSentenceExclusive());
					}
					if (other.HasNer())
					{
						bitField0_ |= unchecked((int)(0x00000008));
						ner_ = other.ner_;
						OnChanged();
					}
					if (other.HasNormalizedNER())
					{
						bitField0_ |= unchecked((int)(0x00000010));
						normalizedNER_ = other.normalizedNER_;
						OnChanged();
					}
					if (other.HasEntityType())
					{
						bitField0_ |= unchecked((int)(0x00000020));
						entityType_ = other.entityType_;
						OnChanged();
					}
					if (other.HasTimex())
					{
						MergeTimex(other.GetTimex());
					}
					if (other.HasWikipediaEntity())
					{
						bitField0_ |= unchecked((int)(0x00000080));
						wikipediaEntity_ = other.wikipediaEntity_;
						OnChanged();
					}
					if (other.HasGender())
					{
						bitField0_ |= unchecked((int)(0x00000100));
						gender_ = other.gender_;
						OnChanged();
					}
					if (other.HasEntityMentionIndex())
					{
						SetEntityMentionIndex(other.GetEntityMentionIndex());
					}
					if (other.HasCanonicalEntityMentionIndex())
					{
						SetCanonicalEntityMentionIndex(other.GetCanonicalEntityMentionIndex());
					}
					if (other.HasEntityMentionText())
					{
						bitField0_ |= unchecked((int)(0x00000800));
						entityMentionText_ = other.entityMentionText_;
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasTokenStartInSentenceInclusive())
					{
						return false;
					}
					if (!HasTokenEndInSentenceExclusive())
					{
						return false;
					}
					if (!HasNer())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.NERMention parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.NERMention)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int sentenceIndex_;

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public bool HasSentenceIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public int GetSentenceIndex()
				{
					return sentenceIndex_;
				}

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetSentenceIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					sentenceIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearSentenceIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					sentenceIndex_ = 0;
					OnChanged();
					return this;
				}

				private int tokenStartInSentenceInclusive_;

				/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
				public bool HasTokenStartInSentenceInclusive()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
				public int GetTokenStartInSentenceInclusive()
				{
					return tokenStartInSentenceInclusive_;
				}

				/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetTokenStartInSentenceInclusive(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					tokenStartInSentenceInclusive_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 tokenStartInSentenceInclusive = 2;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearTokenStartInSentenceInclusive()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					tokenStartInSentenceInclusive_ = 0;
					OnChanged();
					return this;
				}

				private int tokenEndInSentenceExclusive_;

				/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
				public bool HasTokenEndInSentenceExclusive()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
				public int GetTokenEndInSentenceExclusive()
				{
					return tokenEndInSentenceExclusive_;
				}

				/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetTokenEndInSentenceExclusive(int value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					tokenEndInSentenceExclusive_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 tokenEndInSentenceExclusive = 3;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearTokenEndInSentenceExclusive()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					tokenEndInSentenceExclusive_ = 0;
					OnChanged();
					return this;
				}

				private object ner_ = string.Empty;

				/// <summary><code>required string ner = 4;</code></summary>
				public bool HasNer()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>required string ner = 4;</code></summary>
				public string GetNer()
				{
					object @ref = ner_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							ner_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>required string ner = 4;</code></summary>
				public ByteString GetNerBytes()
				{
					object @ref = ner_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						ner_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>required string ner = 4;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetNer(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					ner_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required string ner = 4;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearNer()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					ner_ = GetDefaultInstance().GetNer();
					OnChanged();
					return this;
				}

				/// <summary><code>required string ner = 4;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetNerBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000008));
					ner_ = value;
					OnChanged();
					return this;
				}

				private object normalizedNER_ = string.Empty;

				/// <summary><code>optional string normalizedNER = 5;</code></summary>
				public bool HasNormalizedNER()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional string normalizedNER = 5;</code></summary>
				public string GetNormalizedNER()
				{
					object @ref = normalizedNER_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							normalizedNER_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string normalizedNER = 5;</code></summary>
				public ByteString GetNormalizedNERBytes()
				{
					object @ref = normalizedNER_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						normalizedNER_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string normalizedNER = 5;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetNormalizedNER(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					normalizedNER_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string normalizedNER = 5;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearNormalizedNER()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					normalizedNER_ = GetDefaultInstance().GetNormalizedNER();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string normalizedNER = 5;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetNormalizedNERBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					normalizedNER_ = value;
					OnChanged();
					return this;
				}

				private object entityType_ = string.Empty;

				/// <summary><code>optional string entityType = 6;</code></summary>
				public bool HasEntityType()
				{
					return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
				}

				/// <summary><code>optional string entityType = 6;</code></summary>
				public string GetEntityType()
				{
					object @ref = entityType_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							entityType_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string entityType = 6;</code></summary>
				public ByteString GetEntityTypeBytes()
				{
					object @ref = entityType_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						entityType_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string entityType = 6;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetEntityType(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					entityType_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string entityType = 6;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearEntityType()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					entityType_ = GetDefaultInstance().GetEntityType();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string entityType = 6;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetEntityTypeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000020));
					entityType_ = value;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.Timex timex_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.Timex, CoreNLPProtos.Timex.Builder, CoreNLPProtos.ITimexOrBuilder> timexBuilder_;

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public bool HasTimex()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public CoreNLPProtos.Timex GetTimex()
				{
					if (timexBuilder_ == null)
					{
						return timex_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timex_;
					}
					else
					{
						return timexBuilder_.GetMessage();
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetTimex(CoreNLPProtos.Timex value)
				{
					if (timexBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						timex_ = value;
						OnChanged();
					}
					else
					{
						timexBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00000040));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetTimex(CoreNLPProtos.Timex.Builder builderForValue)
				{
					if (timexBuilder_ == null)
					{
						timex_ = ((CoreNLPProtos.Timex)builderForValue.Build());
						OnChanged();
					}
					else
					{
						timexBuilder_.SetMessage(((CoreNLPProtos.Timex)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00000040));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public CoreNLPProtos.NERMention.Builder MergeTimex(CoreNLPProtos.Timex value)
				{
					if (timexBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))) && timex_ != null && timex_ != CoreNLPProtos.Timex.GetDefaultInstance())
						{
							timex_ = ((CoreNLPProtos.Timex)CoreNLPProtos.Timex.NewBuilder(timex_).MergeFrom(value).BuildPartial());
						}
						else
						{
							timex_ = value;
						}
						OnChanged();
					}
					else
					{
						timexBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00000040));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearTimex()
				{
					if (timexBuilder_ == null)
					{
						timex_ = null;
						OnChanged();
					}
					else
					{
						timexBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					return this;
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public CoreNLPProtos.Timex.Builder GetTimexBuilder()
				{
					bitField0_ |= unchecked((int)(0x00000040));
					OnChanged();
					return GetTimexFieldBuilder().GetBuilder();
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				public CoreNLPProtos.ITimexOrBuilder GetTimexOrBuilder()
				{
					if (timexBuilder_ != null)
					{
						return timexBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return timex_ == null ? CoreNLPProtos.Timex.GetDefaultInstance() : timex_;
					}
				}

				/// <summary><code>optional .edu.stanford.nlp.pipeline.Timex timex = 7;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.Timex, CoreNLPProtos.Timex.Builder, CoreNLPProtos.ITimexOrBuilder> GetTimexFieldBuilder()
				{
					if (timexBuilder_ == null)
					{
						timexBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.Timex, CoreNLPProtos.Timex.Builder, CoreNLPProtos.ITimexOrBuilder>(GetTimex(), GetParentForChildren(), IsClean());
						timex_ = null;
					}
					return timexBuilder_;
				}

				private object wikipediaEntity_ = string.Empty;

				/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
				public bool HasWikipediaEntity()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
				public string GetWikipediaEntity()
				{
					object @ref = wikipediaEntity_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							wikipediaEntity_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
				public ByteString GetWikipediaEntityBytes()
				{
					object @ref = wikipediaEntity_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						wikipediaEntity_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetWikipediaEntity(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					wikipediaEntity_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearWikipediaEntity()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					wikipediaEntity_ = GetDefaultInstance().GetWikipediaEntity();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string wikipediaEntity = 8;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetWikipediaEntityBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000080));
					wikipediaEntity_ = value;
					OnChanged();
					return this;
				}

				private object gender_ = string.Empty;

				/// <summary><code>optional string gender = 9;</code></summary>
				public bool HasGender()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary><code>optional string gender = 9;</code></summary>
				public string GetGender()
				{
					object @ref = gender_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							gender_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string gender = 9;</code></summary>
				public ByteString GetGenderBytes()
				{
					object @ref = gender_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						gender_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string gender = 9;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetGender(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000100));
					gender_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string gender = 9;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearGender()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					gender_ = GetDefaultInstance().GetGender();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string gender = 9;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetGenderBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000100));
					gender_ = value;
					OnChanged();
					return this;
				}

				private int entityMentionIndex_;

				/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
				public bool HasEntityMentionIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
				public int GetEntityMentionIndex()
				{
					return entityMentionIndex_;
				}

				/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetEntityMentionIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000200));
					entityMentionIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 entityMentionIndex = 10;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearEntityMentionIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					entityMentionIndex_ = 0;
					OnChanged();
					return this;
				}

				private int canonicalEntityMentionIndex_;

				/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
				public bool HasCanonicalEntityMentionIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
				public int GetCanonicalEntityMentionIndex()
				{
					return canonicalEntityMentionIndex_;
				}

				/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetCanonicalEntityMentionIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000400));
					canonicalEntityMentionIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 canonicalEntityMentionIndex = 11;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearCanonicalEntityMentionIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					canonicalEntityMentionIndex_ = 0;
					OnChanged();
					return this;
				}

				private object entityMentionText_ = string.Empty;

				/// <summary><code>optional string entityMentionText = 12;</code></summary>
				public bool HasEntityMentionText()
				{
					return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary><code>optional string entityMentionText = 12;</code></summary>
				public string GetEntityMentionText()
				{
					object @ref = entityMentionText_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							entityMentionText_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string entityMentionText = 12;</code></summary>
				public ByteString GetEntityMentionTextBytes()
				{
					object @ref = entityMentionText_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						entityMentionText_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string entityMentionText = 12;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetEntityMentionText(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000800));
					entityMentionText_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string entityMentionText = 12;</code></summary>
				public CoreNLPProtos.NERMention.Builder ClearEntityMentionText()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					entityMentionText_ = GetDefaultInstance().GetEntityMentionText();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string entityMentionText = 12;</code></summary>
				public CoreNLPProtos.NERMention.Builder SetEntityMentionTextBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000800));
					entityMentionText_ = value;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.NERMention.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.NERMention)
			}

			private static readonly CoreNLPProtos.NERMention DefaultInstance;

			static NERMention()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.NERMention)
				DefaultInstance = new CoreNLPProtos.NERMention();
			}

			public static CoreNLPProtos.NERMention GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_53216 : AbstractParser<CoreNLPProtos.NERMention>
			{
				public _AbstractParser_53216()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.NERMention ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.NERMention(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.NERMention> Parser = new _AbstractParser_53216();

			public static IParser<CoreNLPProtos.NERMention> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ISentenceFragmentOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.SentenceFragment)
			/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
			IList<int> GetTokenIndexList();

			/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
			int GetTokenIndexCount();

			/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
			int GetTokenIndex(int index);

			/// <summary><code>optional uint32 root = 2;</code></summary>
			bool HasRoot();

			/// <summary><code>optional uint32 root = 2;</code></summary>
			int GetRoot();

			/// <summary><code>optional bool assumedTruth = 3;</code></summary>
			bool HasAssumedTruth();

			/// <summary><code>optional bool assumedTruth = 3;</code></summary>
			bool GetAssumedTruth();

			/// <summary><code>optional double score = 4;</code></summary>
			bool HasScore();

			/// <summary><code>optional double score = 4;</code></summary>
			double GetScore();
		}

		/// <summary>
		/// <pre>
		/// An entailed sentence fragment.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// An entailed sentence fragment.
		/// Created by the openie annotator.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.SentenceFragment</c>
		/// </remarks>
		[System.Serializable]
		public sealed class SentenceFragment : GeneratedMessageV3, CoreNLPProtos.ISentenceFragmentOrBuilder
		{
			private SentenceFragment(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private SentenceFragment()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.SentenceFragment)
				// Use SentenceFragment.newBuilder() to construct.
				tokenIndex_ = Java.Util.Collections.EmptyList();
				root_ = 0;
				assumedTruth_ = false;
				score_ = 0D;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private SentenceFragment(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									tokenIndex_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								tokenIndex_.Add(input.ReadUInt32());
								break;
							}

							case 10:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))) && input.GetBytesUntilLimit() > 0)
								{
									tokenIndex_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									tokenIndex_.Add(input.ReadUInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								root_ = input.ReadUInt32();
								break;
							}

							case 24:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								assumedTruth_ = input.ReadBool();
								break;
							}

							case 33:
							{
								bitField0_ |= unchecked((int)(0x00000004));
								score_ = input.ReadDouble();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						tokenIndex_ = Java.Util.Collections.UnmodifiableList(tokenIndex_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SentenceFragment_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SentenceFragment_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.SentenceFragment), typeof(CoreNLPProtos.SentenceFragment.Builder));
			}

			private int bitField0_;

			public const int TokenindexFieldNumber = 1;

			private IList<int> tokenIndex_;

			/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
			public IList<int> GetTokenIndexList()
			{
				return tokenIndex_;
			}

			/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
			public int GetTokenIndexCount()
			{
				return tokenIndex_.Count;
			}

			/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
			public int GetTokenIndex(int index)
			{
				return tokenIndex_[index];
			}

			public const int RootFieldNumber = 2;

			private int root_;

			/// <summary><code>optional uint32 root = 2;</code></summary>
			public bool HasRoot()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional uint32 root = 2;</code></summary>
			public int GetRoot()
			{
				return root_;
			}

			public const int AssumedtruthFieldNumber = 3;

			private bool assumedTruth_;

			/// <summary><code>optional bool assumedTruth = 3;</code></summary>
			public bool HasAssumedTruth()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional bool assumedTruth = 3;</code></summary>
			public bool GetAssumedTruth()
			{
				return assumedTruth_;
			}

			public const int ScoreFieldNumber = 4;

			private double score_;

			/// <summary><code>optional double score = 4;</code></summary>
			public bool HasScore()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional double score = 4;</code></summary>
			public double GetScore()
			{
				return score_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				for (int i = 0; i < tokenIndex_.Count; i++)
				{
					output.WriteUInt32(1, tokenIndex_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(2, root_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteBool(3, assumedTruth_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					output.WriteDouble(4, score_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				{
					int dataSize = 0;
					for (int i = 0; i < tokenIndex_.Count; i++)
					{
						dataSize += CodedOutputStream.ComputeUInt32SizeNoTag(tokenIndex_[i]);
					}
					size += dataSize;
					size += 1 * GetTokenIndexList().Count;
				}
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, root_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeBoolSize(3, assumedTruth_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += CodedOutputStream.ComputeDoubleSize(4, score_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.SentenceFragment))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.SentenceFragment other = (CoreNLPProtos.SentenceFragment)obj;
				bool result = true;
				result = result && GetTokenIndexList().Equals(other.GetTokenIndexList());
				result = result && (HasRoot() == other.HasRoot());
				if (HasRoot())
				{
					result = result && (GetRoot() == other.GetRoot());
				}
				result = result && (HasAssumedTruth() == other.HasAssumedTruth());
				if (HasAssumedTruth())
				{
					result = result && (GetAssumedTruth() == other.GetAssumedTruth());
				}
				result = result && (HasScore() == other.HasScore());
				if (HasScore())
				{
					result = result && (double.DoubleToLongBits(GetScore()) == double.DoubleToLongBits(other.GetScore()));
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (GetTokenIndexCount() > 0)
				{
					hash = (37 * hash) + TokenindexFieldNumber;
					hash = (53 * hash) + GetTokenIndexList().GetHashCode();
				}
				if (HasRoot())
				{
					hash = (37 * hash) + RootFieldNumber;
					hash = (53 * hash) + GetRoot();
				}
				if (HasAssumedTruth())
				{
					hash = (37 * hash) + AssumedtruthFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetAssumedTruth());
				}
				if (HasScore())
				{
					hash = (37 * hash) + ScoreFieldNumber;
					hash = (53 * hash) + Internal.HashLong(double.DoubleToLongBits(GetScore()));
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SentenceFragment ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SentenceFragment ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.SentenceFragment ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.SentenceFragment.Builder NewBuilder()
			{
				return ((CoreNLPProtos.SentenceFragment.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.SentenceFragment.Builder NewBuilder(CoreNLPProtos.SentenceFragment prototype)
			{
				return ((CoreNLPProtos.SentenceFragment.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.SentenceFragment.Builder() : new CoreNLPProtos.SentenceFragment.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.SentenceFragment.Builder builder = new CoreNLPProtos.SentenceFragment.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// An entailed sentence fragment.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// An entailed sentence fragment.
			/// Created by the openie annotator.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.SentenceFragment</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.SentenceFragment.Builder>, CoreNLPProtos.ISentenceFragmentOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.SentenceFragment)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SentenceFragment_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SentenceFragment_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.SentenceFragment), typeof(CoreNLPProtos.SentenceFragment.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.SentenceFragment.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					tokenIndex_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					root_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					assumedTruth_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					score_ = 0D;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_SentenceFragment_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.SentenceFragment.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.SentenceFragment result = ((CoreNLPProtos.SentenceFragment)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.SentenceFragment result = new CoreNLPProtos.SentenceFragment(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						tokenIndex_ = Java.Util.Collections.UnmodifiableList(tokenIndex_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					result.tokenIndex_ = tokenIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.root_ = root_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.assumedTruth_ = assumedTruth_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.score_ = score_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.SentenceFragment.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.SentenceFragment.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.SentenceFragment.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.SentenceFragment.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.SentenceFragment.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.SentenceFragment.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.SentenceFragment.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.SentenceFragment.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.SentenceFragment)
					{
						return MergeFrom((CoreNLPProtos.SentenceFragment)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.SentenceFragment.Builder MergeFrom(CoreNLPProtos.SentenceFragment other)
				{
					if (other == CoreNLPProtos.SentenceFragment.GetDefaultInstance())
					{
						return this;
					}
					if (!other.tokenIndex_.IsEmpty())
					{
						if (tokenIndex_.IsEmpty())
						{
							tokenIndex_ = other.tokenIndex_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						else
						{
							EnsureTokenIndexIsMutable();
							Sharpen.Collections.AddAll(tokenIndex_, other.tokenIndex_);
						}
						OnChanged();
					}
					if (other.HasRoot())
					{
						SetRoot(other.GetRoot());
					}
					if (other.HasAssumedTruth())
					{
						SetAssumedTruth(other.GetAssumedTruth());
					}
					if (other.HasScore())
					{
						SetScore(other.GetScore());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.SentenceFragment parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.SentenceFragment)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private IList<int> tokenIndex_ = Java.Util.Collections.EmptyList();

				private void EnsureTokenIndexIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						tokenIndex_ = new List<int>(tokenIndex_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
				public IList<int> GetTokenIndexList()
				{
					return Java.Util.Collections.UnmodifiableList(tokenIndex_);
				}

				/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
				public int GetTokenIndexCount()
				{
					return tokenIndex_.Count;
				}

				/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
				public int GetTokenIndex(int index)
				{
					return tokenIndex_[index];
				}

				/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder SetTokenIndex(int index, int value)
				{
					EnsureTokenIndexIsMutable();
					tokenIndex_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder AddTokenIndex(int value)
				{
					EnsureTokenIndexIsMutable();
					tokenIndex_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder AddAllTokenIndex<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureTokenIndexIsMutable();
					AbstractMessageLite.Builder.AddAll(values, tokenIndex_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 tokenIndex = 1;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder ClearTokenIndex()
				{
					tokenIndex_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					OnChanged();
					return this;
				}

				private int root_;

				/// <summary><code>optional uint32 root = 2;</code></summary>
				public bool HasRoot()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional uint32 root = 2;</code></summary>
				public int GetRoot()
				{
					return root_;
				}

				/// <summary><code>optional uint32 root = 2;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder SetRoot(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					root_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 root = 2;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder ClearRoot()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					root_ = 0;
					OnChanged();
					return this;
				}

				private bool assumedTruth_;

				/// <summary><code>optional bool assumedTruth = 3;</code></summary>
				public bool HasAssumedTruth()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional bool assumedTruth = 3;</code></summary>
				public bool GetAssumedTruth()
				{
					return assumedTruth_;
				}

				/// <summary><code>optional bool assumedTruth = 3;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder SetAssumedTruth(bool value)
				{
					bitField0_ |= unchecked((int)(0x00000004));
					assumedTruth_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional bool assumedTruth = 3;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder ClearAssumedTruth()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					assumedTruth_ = false;
					OnChanged();
					return this;
				}

				private double score_;

				/// <summary><code>optional double score = 4;</code></summary>
				public bool HasScore()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary><code>optional double score = 4;</code></summary>
				public double GetScore()
				{
					return score_;
				}

				/// <summary><code>optional double score = 4;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder SetScore(double value)
				{
					bitField0_ |= unchecked((int)(0x00000008));
					score_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional double score = 4;</code></summary>
				public CoreNLPProtos.SentenceFragment.Builder ClearScore()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					score_ = 0D;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.SentenceFragment.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.SentenceFragment)
			}

			private static readonly CoreNLPProtos.SentenceFragment DefaultInstance;

			static SentenceFragment()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.SentenceFragment)
				DefaultInstance = new CoreNLPProtos.SentenceFragment();
			}

			public static CoreNLPProtos.SentenceFragment GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_54031 : AbstractParser<CoreNLPProtos.SentenceFragment>
			{
				public _AbstractParser_54031()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.SentenceFragment ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.SentenceFragment(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.SentenceFragment> Parser = new _AbstractParser_54031();

			public static IParser<CoreNLPProtos.SentenceFragment> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ITokenLocationOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.TokenLocation)
			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			bool HasSentenceIndex();

			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			int GetSentenceIndex();

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			bool HasTokenIndex();

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			int GetTokenIndex();
		}

		/// <summary>
		/// <pre>
		/// The index of a token in a document, including the sentence
		/// index and the offset.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// The index of a token in a document, including the sentence
		/// index and the offset.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.TokenLocation</c>
		/// </remarks>
		[System.Serializable]
		public sealed class TokenLocation : GeneratedMessageV3, CoreNLPProtos.ITokenLocationOrBuilder
		{
			private TokenLocation(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private TokenLocation()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.TokenLocation)
				// Use TokenLocation.newBuilder() to construct.
				sentenceIndex_ = 0;
				tokenIndex_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private TokenLocation(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								sentenceIndex_ = input.ReadUInt32();
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								tokenIndex_ = input.ReadUInt32();
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_TokenLocation_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_TokenLocation_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.TokenLocation), typeof(CoreNLPProtos.TokenLocation.Builder));
			}

			private int bitField0_;

			public const int SentenceindexFieldNumber = 1;

			private int sentenceIndex_;

			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			public bool HasSentenceIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
			public int GetSentenceIndex()
			{
				return sentenceIndex_;
			}

			public const int TokenindexFieldNumber = 2;

			private int tokenIndex_;

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			public bool HasTokenIndex()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
			public int GetTokenIndex()
			{
				return tokenIndex_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(1, sentenceIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(2, tokenIndex_);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(1, sentenceIndex_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, tokenIndex_);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.TokenLocation))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.TokenLocation other = (CoreNLPProtos.TokenLocation)obj;
				bool result = true;
				result = result && (HasSentenceIndex() == other.HasSentenceIndex());
				if (HasSentenceIndex())
				{
					result = result && (GetSentenceIndex() == other.GetSentenceIndex());
				}
				result = result && (HasTokenIndex() == other.HasTokenIndex());
				if (HasTokenIndex())
				{
					result = result && (GetTokenIndex() == other.GetTokenIndex());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasSentenceIndex())
				{
					hash = (37 * hash) + SentenceindexFieldNumber;
					hash = (53 * hash) + GetSentenceIndex();
				}
				if (HasTokenIndex())
				{
					hash = (37 * hash) + TokenindexFieldNumber;
					hash = (53 * hash) + GetTokenIndex();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.TokenLocation ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.TokenLocation ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.TokenLocation ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.TokenLocation.Builder NewBuilder()
			{
				return ((CoreNLPProtos.TokenLocation.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.TokenLocation.Builder NewBuilder(CoreNLPProtos.TokenLocation prototype)
			{
				return ((CoreNLPProtos.TokenLocation.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.TokenLocation.Builder() : new CoreNLPProtos.TokenLocation.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.TokenLocation.Builder builder = new CoreNLPProtos.TokenLocation.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// The index of a token in a document, including the sentence
			/// index and the offset.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// The index of a token in a document, including the sentence
			/// index and the offset.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.TokenLocation</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.TokenLocation.Builder>, CoreNLPProtos.ITokenLocationOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.TokenLocation)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_TokenLocation_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_TokenLocation_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.TokenLocation), typeof(CoreNLPProtos.TokenLocation.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.TokenLocation.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					sentenceIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					tokenIndex_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_TokenLocation_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.TokenLocation.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.TokenLocation result = ((CoreNLPProtos.TokenLocation)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.TokenLocation result = new CoreNLPProtos.TokenLocation(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.sentenceIndex_ = sentenceIndex_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.tokenIndex_ = tokenIndex_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.TokenLocation.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.TokenLocation.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.TokenLocation.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.TokenLocation.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.TokenLocation.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.TokenLocation.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.TokenLocation.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.TokenLocation.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.TokenLocation)
					{
						return MergeFrom((CoreNLPProtos.TokenLocation)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.TokenLocation.Builder MergeFrom(CoreNLPProtos.TokenLocation other)
				{
					if (other == CoreNLPProtos.TokenLocation.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasSentenceIndex())
					{
						SetSentenceIndex(other.GetSentenceIndex());
					}
					if (other.HasTokenIndex())
					{
						SetTokenIndex(other.GetTokenIndex());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.TokenLocation parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.TokenLocation)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int sentenceIndex_;

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public bool HasSentenceIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public int GetSentenceIndex()
				{
					return sentenceIndex_;
				}

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public CoreNLPProtos.TokenLocation.Builder SetSentenceIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					sentenceIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 sentenceIndex = 1;</code></summary>
				public CoreNLPProtos.TokenLocation.Builder ClearSentenceIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					sentenceIndex_ = 0;
					OnChanged();
					return this;
				}

				private int tokenIndex_;

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public bool HasTokenIndex()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public int GetTokenIndex()
				{
					return tokenIndex_;
				}

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public CoreNLPProtos.TokenLocation.Builder SetTokenIndex(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					tokenIndex_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 tokenIndex = 2;</code></summary>
				public CoreNLPProtos.TokenLocation.Builder ClearTokenIndex()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					tokenIndex_ = 0;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.TokenLocation.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.TokenLocation)
			}

			private static readonly CoreNLPProtos.TokenLocation DefaultInstance;

			static TokenLocation()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.TokenLocation)
				DefaultInstance = new CoreNLPProtos.TokenLocation();
			}

			public static CoreNLPProtos.TokenLocation GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_54594 : AbstractParser<CoreNLPProtos.TokenLocation>
			{
				public _AbstractParser_54594()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.TokenLocation ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.TokenLocation(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.TokenLocation> Parser = new _AbstractParser_54594();

			public static IParser<CoreNLPProtos.TokenLocation> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IRelationTripleOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.RelationTriple)
			/// <summary>
			/// <pre>
			/// The surface form of the subject
			/// </pre>
			/// <code>optional string subject = 1;</code>
			/// </summary>
			bool HasSubject();

			/// <summary>
			/// <pre>
			/// The surface form of the subject
			/// </pre>
			/// <code>optional string subject = 1;</code>
			/// </summary>
			string GetSubject();

			/// <summary>
			/// <pre>
			/// The surface form of the subject
			/// </pre>
			/// <code>optional string subject = 1;</code>
			/// </summary>
			ByteString GetSubjectBytes();

			/// <summary>
			/// <pre>
			/// The surface form of the relation (required)
			/// </pre>
			/// <code>optional string relation = 2;</code>
			/// </summary>
			bool HasRelation();

			/// <summary>
			/// <pre>
			/// The surface form of the relation (required)
			/// </pre>
			/// <code>optional string relation = 2;</code>
			/// </summary>
			string GetRelation();

			/// <summary>
			/// <pre>
			/// The surface form of the relation (required)
			/// </pre>
			/// <code>optional string relation = 2;</code>
			/// </summary>
			ByteString GetRelationBytes();

			/// <summary>
			/// <pre>
			/// The surface form of the object
			/// </pre>
			/// <code>optional string object = 3;</code>
			/// </summary>
			bool HasObject();

			/// <summary>
			/// <pre>
			/// The surface form of the object
			/// </pre>
			/// <code>optional string object = 3;</code>
			/// </summary>
			string GetObject();

			/// <summary>
			/// <pre>
			/// The surface form of the object
			/// </pre>
			/// <code>optional string object = 3;</code>
			/// </summary>
			ByteString GetObjectBytes();

			/// <summary>
			/// <pre>
			/// The [optional] confidence of the extraction
			/// </pre>
			/// <code>optional double confidence = 4;</code>
			/// </summary>
			bool HasConfidence();

			/// <summary>
			/// <pre>
			/// The [optional] confidence of the extraction
			/// </pre>
			/// <code>optional double confidence = 4;</code>
			/// </summary>
			double GetConfidence();

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			IList<CoreNLPProtos.TokenLocation> GetSubjectTokensList();

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			CoreNLPProtos.TokenLocation GetSubjectTokens(int index);

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			int GetSubjectTokensCount();

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			IList<CoreNLPProtos.ITokenLocationOrBuilder> GetSubjectTokensOrBuilderList();

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			CoreNLPProtos.ITokenLocationOrBuilder GetSubjectTokensOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			IList<CoreNLPProtos.TokenLocation> GetRelationTokensList();

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			CoreNLPProtos.TokenLocation GetRelationTokens(int index);

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			int GetRelationTokensCount();

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			IList<CoreNLPProtos.ITokenLocationOrBuilder> GetRelationTokensOrBuilderList();

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			CoreNLPProtos.ITokenLocationOrBuilder GetRelationTokensOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			IList<CoreNLPProtos.TokenLocation> GetObjectTokensList();

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			CoreNLPProtos.TokenLocation GetObjectTokens(int index);

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			int GetObjectTokensCount();

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			IList<CoreNLPProtos.ITokenLocationOrBuilder> GetObjectTokensOrBuilderList();

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			CoreNLPProtos.ITokenLocationOrBuilder GetObjectTokensOrBuilder(int index);

			/// <summary>
			/// <pre>
			/// The dependency graph fragment for this triple
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
			/// </summary>
			bool HasTree();

			/// <summary>
			/// <pre>
			/// The dependency graph fragment for this triple
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
			/// </summary>
			CoreNLPProtos.DependencyGraph GetTree();

			/// <summary>
			/// <pre>
			/// The dependency graph fragment for this triple
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
			/// </summary>
			CoreNLPProtos.IDependencyGraphOrBuilder GetTreeOrBuilder();

			/// <summary>
			/// <pre>
			/// If true, this expresses an implicit tmod relation
			/// </pre>
			/// <code>optional bool istmod = 9;</code>
			/// </summary>
			bool HasIstmod();

			/// <summary>
			/// <pre>
			/// If true, this expresses an implicit tmod relation
			/// </pre>
			/// <code>optional bool istmod = 9;</code>
			/// </summary>
			bool GetIstmod();

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' prefix
			/// </pre>
			/// <code>optional bool prefixBe = 10;</code>
			/// </summary>
			bool HasPrefixBe();

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' prefix
			/// </pre>
			/// <code>optional bool prefixBe = 10;</code>
			/// </summary>
			bool GetPrefixBe();

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' suffix
			/// </pre>
			/// <code>optional bool suffixBe = 11;</code>
			/// </summary>
			bool HasSuffixBe();

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' suffix
			/// </pre>
			/// <code>optional bool suffixBe = 11;</code>
			/// </summary>
			bool GetSuffixBe();

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'of' prefix
			/// </pre>
			/// <code>optional bool suffixOf = 12;</code>
			/// </summary>
			bool HasSuffixOf();

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'of' prefix
			/// </pre>
			/// <code>optional bool suffixOf = 12;</code>
			/// </summary>
			bool GetSuffixOf();
		}

		/// <summary>
		/// <pre>
		/// An OpenIE relation triple.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// An OpenIE relation triple.
		/// Created by the openie annotator.
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.RelationTriple</c>
		/// </remarks>
		[System.Serializable]
		public sealed class RelationTriple : GeneratedMessageV3, CoreNLPProtos.IRelationTripleOrBuilder
		{
			private RelationTriple(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private RelationTriple()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.RelationTriple)
				// Use RelationTriple.newBuilder() to construct.
				subject_ = string.Empty;
				relation_ = string.Empty;
				object_ = string.Empty;
				confidence_ = 0D;
				subjectTokens_ = Java.Util.Collections.EmptyList();
				relationTokens_ = Java.Util.Collections.EmptyList();
				objectTokens_ = Java.Util.Collections.EmptyList();
				istmod_ = false;
				prefixBe_ = false;
				suffixBe_ = false;
				suffixOf_ = false;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private RelationTriple(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000001));
								subject_ = bs;
								break;
							}

							case 18:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000002));
								relation_ = bs;
								break;
							}

							case 26:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000004));
								object_ = bs;
								break;
							}

							case 33:
							{
								bitField0_ |= unchecked((int)(0x00000008));
								confidence_ = input.ReadDouble();
								break;
							}

							case 66:
							{
								CoreNLPProtos.DependencyGraph.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
								{
									subBuilder = ((CoreNLPProtos.DependencyGraph.Builder)tree_.ToBuilder());
								}
								tree_ = input.ReadMessage(CoreNLPProtos.DependencyGraph.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(tree_);
									tree_ = ((CoreNLPProtos.DependencyGraph)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000010));
								break;
							}

							case 72:
							{
								bitField0_ |= unchecked((int)(0x00000020));
								istmod_ = input.ReadBool();
								break;
							}

							case 80:
							{
								bitField0_ |= unchecked((int)(0x00000040));
								prefixBe_ = input.ReadBool();
								break;
							}

							case 88:
							{
								bitField0_ |= unchecked((int)(0x00000080));
								suffixBe_ = input.ReadBool();
								break;
							}

							case 96:
							{
								bitField0_ |= unchecked((int)(0x00000100));
								suffixOf_ = input.ReadBool();
								break;
							}

							case 106:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
								{
									subjectTokens_ = new List<CoreNLPProtos.TokenLocation>();
									mutable_bitField0_ |= unchecked((int)(0x00000010));
								}
								subjectTokens_.Add(input.ReadMessage(CoreNLPProtos.TokenLocation.Parser, extensionRegistry));
								break;
							}

							case 114:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
								{
									relationTokens_ = new List<CoreNLPProtos.TokenLocation>();
									mutable_bitField0_ |= unchecked((int)(0x00000020));
								}
								relationTokens_.Add(input.ReadMessage(CoreNLPProtos.TokenLocation.Parser, extensionRegistry));
								break;
							}

							case 122:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
								{
									objectTokens_ = new List<CoreNLPProtos.TokenLocation>();
									mutable_bitField0_ |= unchecked((int)(0x00000040));
								}
								objectTokens_.Add(input.ReadMessage(CoreNLPProtos.TokenLocation.Parser, extensionRegistry));
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						subjectTokens_ = Java.Util.Collections.UnmodifiableList(subjectTokens_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						relationTokens_ = Java.Util.Collections.UnmodifiableList(relationTokens_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						objectTokens_ = Java.Util.Collections.UnmodifiableList(objectTokens_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_RelationTriple_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_RelationTriple_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.RelationTriple), typeof(CoreNLPProtos.RelationTriple.Builder));
			}

			private int bitField0_;

			public const int SubjectFieldNumber = 1;

			private volatile object subject_;

			/// <summary>
			/// <pre>
			/// The surface form of the subject
			/// </pre>
			/// <code>optional string subject = 1;</code>
			/// </summary>
			public bool HasSubject()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary>
			/// <pre>
			/// The surface form of the subject
			/// </pre>
			/// <code>optional string subject = 1;</code>
			/// </summary>
			public string GetSubject()
			{
				object @ref = subject_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						subject_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The surface form of the subject
			/// </pre>
			/// <code>optional string subject = 1;</code>
			/// </summary>
			public ByteString GetSubjectBytes()
			{
				object @ref = subject_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					subject_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int RelationFieldNumber = 2;

			private volatile object relation_;

			/// <summary>
			/// <pre>
			/// The surface form of the relation (required)
			/// </pre>
			/// <code>optional string relation = 2;</code>
			/// </summary>
			public bool HasRelation()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary>
			/// <pre>
			/// The surface form of the relation (required)
			/// </pre>
			/// <code>optional string relation = 2;</code>
			/// </summary>
			public string GetRelation()
			{
				object @ref = relation_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						relation_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The surface form of the relation (required)
			/// </pre>
			/// <code>optional string relation = 2;</code>
			/// </summary>
			public ByteString GetRelationBytes()
			{
				object @ref = relation_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					relation_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ObjectFieldNumber = 3;

			private volatile object object_;

			/// <summary>
			/// <pre>
			/// The surface form of the object
			/// </pre>
			/// <code>optional string object = 3;</code>
			/// </summary>
			public bool HasObject()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary>
			/// <pre>
			/// The surface form of the object
			/// </pre>
			/// <code>optional string object = 3;</code>
			/// </summary>
			public string GetObject()
			{
				object @ref = object_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						object_ = s;
					}
					return s;
				}
			}

			/// <summary>
			/// <pre>
			/// The surface form of the object
			/// </pre>
			/// <code>optional string object = 3;</code>
			/// </summary>
			public ByteString GetObjectBytes()
			{
				object @ref = object_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					object_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int ConfidenceFieldNumber = 4;

			private double confidence_;

			/// <summary>
			/// <pre>
			/// The [optional] confidence of the extraction
			/// </pre>
			/// <code>optional double confidence = 4;</code>
			/// </summary>
			public bool HasConfidence()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary>
			/// <pre>
			/// The [optional] confidence of the extraction
			/// </pre>
			/// <code>optional double confidence = 4;</code>
			/// </summary>
			public double GetConfidence()
			{
				return confidence_;
			}

			public const int SubjecttokensFieldNumber = 13;

			private IList<CoreNLPProtos.TokenLocation> subjectTokens_;

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			public IList<CoreNLPProtos.TokenLocation> GetSubjectTokensList()
			{
				return subjectTokens_;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			public IList<CoreNLPProtos.ITokenLocationOrBuilder> GetSubjectTokensOrBuilderList()
			{
				return subjectTokens_;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			public int GetSubjectTokensCount()
			{
				return subjectTokens_.Count;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			public CoreNLPProtos.TokenLocation GetSubjectTokens(int index)
			{
				return subjectTokens_[index];
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the subject of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
			/// </summary>
			public CoreNLPProtos.ITokenLocationOrBuilder GetSubjectTokensOrBuilder(int index)
			{
				return subjectTokens_[index];
			}

			public const int RelationtokensFieldNumber = 14;

			private IList<CoreNLPProtos.TokenLocation> relationTokens_;

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			public IList<CoreNLPProtos.TokenLocation> GetRelationTokensList()
			{
				return relationTokens_;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			public IList<CoreNLPProtos.ITokenLocationOrBuilder> GetRelationTokensOrBuilderList()
			{
				return relationTokens_;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			public int GetRelationTokensCount()
			{
				return relationTokens_.Count;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			public CoreNLPProtos.TokenLocation GetRelationTokens(int index)
			{
				return relationTokens_[index];
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the relation of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
			/// </summary>
			public CoreNLPProtos.ITokenLocationOrBuilder GetRelationTokensOrBuilder(int index)
			{
				return relationTokens_[index];
			}

			public const int ObjecttokensFieldNumber = 15;

			private IList<CoreNLPProtos.TokenLocation> objectTokens_;

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			public IList<CoreNLPProtos.TokenLocation> GetObjectTokensList()
			{
				return objectTokens_;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			public IList<CoreNLPProtos.ITokenLocationOrBuilder> GetObjectTokensOrBuilderList()
			{
				return objectTokens_;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			public int GetObjectTokensCount()
			{
				return objectTokens_.Count;
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			public CoreNLPProtos.TokenLocation GetObjectTokens(int index)
			{
				return objectTokens_[index];
			}

			/// <summary>
			/// <pre>
			/// The tokens comprising the object of the triple
			/// </pre>
			/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
			/// </summary>
			public CoreNLPProtos.ITokenLocationOrBuilder GetObjectTokensOrBuilder(int index)
			{
				return objectTokens_[index];
			}

			public const int TreeFieldNumber = 8;

			private CoreNLPProtos.DependencyGraph tree_;

			/// <summary>
			/// <pre>
			/// The dependency graph fragment for this triple
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
			/// </summary>
			public bool HasTree()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary>
			/// <pre>
			/// The dependency graph fragment for this triple
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
			/// </summary>
			public CoreNLPProtos.DependencyGraph GetTree()
			{
				return tree_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : tree_;
			}

			/// <summary>
			/// <pre>
			/// The dependency graph fragment for this triple
			/// </pre>
			/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
			/// </summary>
			public CoreNLPProtos.IDependencyGraphOrBuilder GetTreeOrBuilder()
			{
				return tree_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : tree_;
			}

			public const int IstmodFieldNumber = 9;

			private bool istmod_;

			/// <summary>
			/// <pre>
			/// If true, this expresses an implicit tmod relation
			/// </pre>
			/// <code>optional bool istmod = 9;</code>
			/// </summary>
			public bool HasIstmod()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary>
			/// <pre>
			/// If true, this expresses an implicit tmod relation
			/// </pre>
			/// <code>optional bool istmod = 9;</code>
			/// </summary>
			public bool GetIstmod()
			{
				return istmod_;
			}

			public const int PrefixbeFieldNumber = 10;

			private bool prefixBe_;

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' prefix
			/// </pre>
			/// <code>optional bool prefixBe = 10;</code>
			/// </summary>
			public bool HasPrefixBe()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' prefix
			/// </pre>
			/// <code>optional bool prefixBe = 10;</code>
			/// </summary>
			public bool GetPrefixBe()
			{
				return prefixBe_;
			}

			public const int SuffixbeFieldNumber = 11;

			private bool suffixBe_;

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' suffix
			/// </pre>
			/// <code>optional bool suffixBe = 11;</code>
			/// </summary>
			public bool HasSuffixBe()
			{
				return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
			}

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'be' suffix
			/// </pre>
			/// <code>optional bool suffixBe = 11;</code>
			/// </summary>
			public bool GetSuffixBe()
			{
				return suffixBe_;
			}

			public const int SuffixofFieldNumber = 12;

			private bool suffixOf_;

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'of' prefix
			/// </pre>
			/// <code>optional bool suffixOf = 12;</code>
			/// </summary>
			public bool HasSuffixOf()
			{
				return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
			}

			/// <summary>
			/// <pre>
			/// If true, this relation string is missing a 'of' prefix
			/// </pre>
			/// <code>optional bool suffixOf = 12;</code>
			/// </summary>
			public bool GetSuffixOf()
			{
				return suffixOf_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (HasTree())
				{
					if (!GetTree().IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					GeneratedMessageV3.WriteString(output, 1, subject_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					GeneratedMessageV3.WriteString(output, 2, relation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 3, object_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					output.WriteDouble(4, confidence_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteMessage(8, GetTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteBool(9, istmod_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteBool(10, prefixBe_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					output.WriteBool(11, suffixBe_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					output.WriteBool(12, suffixOf_);
				}
				for (int i = 0; i < subjectTokens_.Count; i++)
				{
					output.WriteMessage(13, subjectTokens_[i]);
				}
				for (int i_1 = 0; i_1 < relationTokens_.Count; i_1++)
				{
					output.WriteMessage(14, relationTokens_[i_1]);
				}
				for (int i_2 = 0; i_2 < objectTokens_.Count; i_2++)
				{
					output.WriteMessage(15, objectTokens_[i_2]);
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += GeneratedMessageV3.ComputeStringSize(1, subject_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += GeneratedMessageV3.ComputeStringSize(2, relation_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(3, object_);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += CodedOutputStream.ComputeDoubleSize(4, confidence_);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeMessageSize(8, GetTree());
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeBoolSize(9, istmod_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeBoolSize(10, prefixBe_);
				}
				if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
				{
					size += CodedOutputStream.ComputeBoolSize(11, suffixBe_);
				}
				if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
				{
					size += CodedOutputStream.ComputeBoolSize(12, suffixOf_);
				}
				for (int i = 0; i < subjectTokens_.Count; i++)
				{
					size += CodedOutputStream.ComputeMessageSize(13, subjectTokens_[i]);
				}
				for (int i_1 = 0; i_1 < relationTokens_.Count; i_1++)
				{
					size += CodedOutputStream.ComputeMessageSize(14, relationTokens_[i_1]);
				}
				for (int i_2 = 0; i_2 < objectTokens_.Count; i_2++)
				{
					size += CodedOutputStream.ComputeMessageSize(15, objectTokens_[i_2]);
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.RelationTriple))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.RelationTriple other = (CoreNLPProtos.RelationTriple)obj;
				bool result = true;
				result = result && (HasSubject() == other.HasSubject());
				if (HasSubject())
				{
					result = result && GetSubject().Equals(other.GetSubject());
				}
				result = result && (HasRelation() == other.HasRelation());
				if (HasRelation())
				{
					result = result && GetRelation().Equals(other.GetRelation());
				}
				result = result && (HasObject() == other.HasObject());
				if (HasObject())
				{
					result = result && GetObject().Equals(other.GetObject());
				}
				result = result && (HasConfidence() == other.HasConfidence());
				if (HasConfidence())
				{
					result = result && (double.DoubleToLongBits(GetConfidence()) == double.DoubleToLongBits(other.GetConfidence()));
				}
				result = result && GetSubjectTokensList().Equals(other.GetSubjectTokensList());
				result = result && GetRelationTokensList().Equals(other.GetRelationTokensList());
				result = result && GetObjectTokensList().Equals(other.GetObjectTokensList());
				result = result && (HasTree() == other.HasTree());
				if (HasTree())
				{
					result = result && GetTree().Equals(other.GetTree());
				}
				result = result && (HasIstmod() == other.HasIstmod());
				if (HasIstmod())
				{
					result = result && (GetIstmod() == other.GetIstmod());
				}
				result = result && (HasPrefixBe() == other.HasPrefixBe());
				if (HasPrefixBe())
				{
					result = result && (GetPrefixBe() == other.GetPrefixBe());
				}
				result = result && (HasSuffixBe() == other.HasSuffixBe());
				if (HasSuffixBe())
				{
					result = result && (GetSuffixBe() == other.GetSuffixBe());
				}
				result = result && (HasSuffixOf() == other.HasSuffixOf());
				if (HasSuffixOf())
				{
					result = result && (GetSuffixOf() == other.GetSuffixOf());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasSubject())
				{
					hash = (37 * hash) + SubjectFieldNumber;
					hash = (53 * hash) + GetSubject().GetHashCode();
				}
				if (HasRelation())
				{
					hash = (37 * hash) + RelationFieldNumber;
					hash = (53 * hash) + GetRelation().GetHashCode();
				}
				if (HasObject())
				{
					hash = (37 * hash) + ObjectFieldNumber;
					hash = (53 * hash) + GetObject().GetHashCode();
				}
				if (HasConfidence())
				{
					hash = (37 * hash) + ConfidenceFieldNumber;
					hash = (53 * hash) + Internal.HashLong(double.DoubleToLongBits(GetConfidence()));
				}
				if (GetSubjectTokensCount() > 0)
				{
					hash = (37 * hash) + SubjecttokensFieldNumber;
					hash = (53 * hash) + GetSubjectTokensList().GetHashCode();
				}
				if (GetRelationTokensCount() > 0)
				{
					hash = (37 * hash) + RelationtokensFieldNumber;
					hash = (53 * hash) + GetRelationTokensList().GetHashCode();
				}
				if (GetObjectTokensCount() > 0)
				{
					hash = (37 * hash) + ObjecttokensFieldNumber;
					hash = (53 * hash) + GetObjectTokensList().GetHashCode();
				}
				if (HasTree())
				{
					hash = (37 * hash) + TreeFieldNumber;
					hash = (53 * hash) + GetTree().GetHashCode();
				}
				if (HasIstmod())
				{
					hash = (37 * hash) + IstmodFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetIstmod());
				}
				if (HasPrefixBe())
				{
					hash = (37 * hash) + PrefixbeFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetPrefixBe());
				}
				if (HasSuffixBe())
				{
					hash = (37 * hash) + SuffixbeFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetSuffixBe());
				}
				if (HasSuffixOf())
				{
					hash = (37 * hash) + SuffixofFieldNumber;
					hash = (53 * hash) + Internal.HashBoolean(GetSuffixOf());
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.RelationTriple ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.RelationTriple ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.RelationTriple ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.RelationTriple.Builder NewBuilder()
			{
				return ((CoreNLPProtos.RelationTriple.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.RelationTriple.Builder NewBuilder(CoreNLPProtos.RelationTriple prototype)
			{
				return ((CoreNLPProtos.RelationTriple.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.RelationTriple.Builder() : new CoreNLPProtos.RelationTriple.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.RelationTriple.Builder builder = new CoreNLPProtos.RelationTriple.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// An OpenIE relation triple.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// An OpenIE relation triple.
			/// Created by the openie annotator.
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.RelationTriple</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.RelationTriple.Builder>, CoreNLPProtos.IRelationTripleOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.RelationTriple)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_RelationTriple_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_RelationTriple_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.RelationTriple), typeof(CoreNLPProtos.RelationTriple.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.RelationTriple.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetSubjectTokensFieldBuilder();
						GetRelationTokensFieldBuilder();
						GetObjectTokensFieldBuilder();
						GetTreeFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					subject_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					relation_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					object_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					confidence_ = 0D;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					if (subjectTokensBuilder_ == null)
					{
						subjectTokens_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					}
					else
					{
						subjectTokensBuilder_.Clear();
					}
					if (relationTokensBuilder_ == null)
					{
						relationTokens_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					}
					else
					{
						relationTokensBuilder_.Clear();
					}
					if (objectTokensBuilder_ == null)
					{
						objectTokens_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					}
					else
					{
						objectTokensBuilder_.Clear();
					}
					if (treeBuilder_ == null)
					{
						tree_ = null;
					}
					else
					{
						treeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					istmod_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					prefixBe_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					suffixBe_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					suffixOf_ = false;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_RelationTriple_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.RelationTriple.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.RelationTriple result = ((CoreNLPProtos.RelationTriple)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.RelationTriple result = new CoreNLPProtos.RelationTriple(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.subject_ = subject_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.relation_ = relation_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.object_ = object_;
					if (((from_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.confidence_ = confidence_;
					if (subjectTokensBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
						{
							subjectTokens_ = Java.Util.Collections.UnmodifiableList(subjectTokens_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
						}
						result.subjectTokens_ = subjectTokens_;
					}
					else
					{
						result.subjectTokens_ = subjectTokensBuilder_.Build();
					}
					if (relationTokensBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
						{
							relationTokens_ = Java.Util.Collections.UnmodifiableList(relationTokens_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						}
						result.relationTokens_ = relationTokens_;
					}
					else
					{
						result.relationTokens_ = relationTokensBuilder_.Build();
					}
					if (objectTokensBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
						{
							objectTokens_ = Java.Util.Collections.UnmodifiableList(objectTokens_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						}
						result.objectTokens_ = objectTokens_;
					}
					else
					{
						result.objectTokens_ = objectTokensBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					if (treeBuilder_ == null)
					{
						result.tree_ = tree_;
					}
					else
					{
						result.tree_ = treeBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.istmod_ = istmod_;
					if (((from_bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					result.prefixBe_ = prefixBe_;
					if (((from_bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400))))
					{
						to_bitField0_ |= unchecked((int)(0x00000080));
					}
					result.suffixBe_ = suffixBe_;
					if (((from_bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800))))
					{
						to_bitField0_ |= unchecked((int)(0x00000100));
					}
					result.suffixOf_ = suffixOf_;
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.RelationTriple.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.RelationTriple.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.RelationTriple.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.RelationTriple.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.RelationTriple.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.RelationTriple.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.RelationTriple.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.RelationTriple.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.RelationTriple)
					{
						return MergeFrom((CoreNLPProtos.RelationTriple)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.RelationTriple.Builder MergeFrom(CoreNLPProtos.RelationTriple other)
				{
					if (other == CoreNLPProtos.RelationTriple.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasSubject())
					{
						bitField0_ |= unchecked((int)(0x00000001));
						subject_ = other.subject_;
						OnChanged();
					}
					if (other.HasRelation())
					{
						bitField0_ |= unchecked((int)(0x00000002));
						relation_ = other.relation_;
						OnChanged();
					}
					if (other.HasObject())
					{
						bitField0_ |= unchecked((int)(0x00000004));
						object_ = other.object_;
						OnChanged();
					}
					if (other.HasConfidence())
					{
						SetConfidence(other.GetConfidence());
					}
					if (subjectTokensBuilder_ == null)
					{
						if (!other.subjectTokens_.IsEmpty())
						{
							if (subjectTokens_.IsEmpty())
							{
								subjectTokens_ = other.subjectTokens_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
							}
							else
							{
								EnsureSubjectTokensIsMutable();
								Sharpen.Collections.AddAll(subjectTokens_, other.subjectTokens_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.subjectTokens_.IsEmpty())
						{
							if (subjectTokensBuilder_.IsEmpty())
							{
								subjectTokensBuilder_.Dispose();
								subjectTokensBuilder_ = null;
								subjectTokens_ = other.subjectTokens_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
								subjectTokensBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetSubjectTokensFieldBuilder() : null;
							}
							else
							{
								subjectTokensBuilder_.AddAllMessages(other.subjectTokens_);
							}
						}
					}
					if (relationTokensBuilder_ == null)
					{
						if (!other.relationTokens_.IsEmpty())
						{
							if (relationTokens_.IsEmpty())
							{
								relationTokens_ = other.relationTokens_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
							}
							else
							{
								EnsureRelationTokensIsMutable();
								Sharpen.Collections.AddAll(relationTokens_, other.relationTokens_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.relationTokens_.IsEmpty())
						{
							if (relationTokensBuilder_.IsEmpty())
							{
								relationTokensBuilder_.Dispose();
								relationTokensBuilder_ = null;
								relationTokens_ = other.relationTokens_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
								relationTokensBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetRelationTokensFieldBuilder() : null;
							}
							else
							{
								relationTokensBuilder_.AddAllMessages(other.relationTokens_);
							}
						}
					}
					if (objectTokensBuilder_ == null)
					{
						if (!other.objectTokens_.IsEmpty())
						{
							if (objectTokens_.IsEmpty())
							{
								objectTokens_ = other.objectTokens_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
							}
							else
							{
								EnsureObjectTokensIsMutable();
								Sharpen.Collections.AddAll(objectTokens_, other.objectTokens_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.objectTokens_.IsEmpty())
						{
							if (objectTokensBuilder_.IsEmpty())
							{
								objectTokensBuilder_.Dispose();
								objectTokensBuilder_ = null;
								objectTokens_ = other.objectTokens_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
								objectTokensBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetObjectTokensFieldBuilder() : null;
							}
							else
							{
								objectTokensBuilder_.AddAllMessages(other.objectTokens_);
							}
						}
					}
					if (other.HasTree())
					{
						MergeTree(other.GetTree());
					}
					if (other.HasIstmod())
					{
						SetIstmod(other.GetIstmod());
					}
					if (other.HasPrefixBe())
					{
						SetPrefixBe(other.GetPrefixBe());
					}
					if (other.HasSuffixBe())
					{
						SetSuffixBe(other.GetSuffixBe());
					}
					if (other.HasSuffixOf())
					{
						SetSuffixOf(other.GetSuffixOf());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (HasTree())
					{
						if (!GetTree().IsInitialized())
						{
							return false;
						}
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.RelationTriple parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.RelationTriple)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private object subject_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The surface form of the subject
				/// </pre>
				/// <code>optional string subject = 1;</code>
				/// </summary>
				public bool HasSubject()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary>
				/// <pre>
				/// The surface form of the subject
				/// </pre>
				/// <code>optional string subject = 1;</code>
				/// </summary>
				public string GetSubject()
				{
					object @ref = subject_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							subject_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The surface form of the subject
				/// </pre>
				/// <code>optional string subject = 1;</code>
				/// </summary>
				public ByteString GetSubjectBytes()
				{
					object @ref = subject_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						subject_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The surface form of the subject
				/// </pre>
				/// <code>optional string subject = 1;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetSubject(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					subject_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The surface form of the subject
				/// </pre>
				/// <code>optional string subject = 1;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearSubject()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					subject_ = GetDefaultInstance().GetSubject();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The surface form of the subject
				/// </pre>
				/// <code>optional string subject = 1;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetSubjectBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000001));
					subject_ = value;
					OnChanged();
					return this;
				}

				private object relation_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The surface form of the relation (required)
				/// </pre>
				/// <code>optional string relation = 2;</code>
				/// </summary>
				public bool HasRelation()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary>
				/// <pre>
				/// The surface form of the relation (required)
				/// </pre>
				/// <code>optional string relation = 2;</code>
				/// </summary>
				public string GetRelation()
				{
					object @ref = relation_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							relation_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The surface form of the relation (required)
				/// </pre>
				/// <code>optional string relation = 2;</code>
				/// </summary>
				public ByteString GetRelationBytes()
				{
					object @ref = relation_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						relation_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The surface form of the relation (required)
				/// </pre>
				/// <code>optional string relation = 2;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetRelation(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					relation_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The surface form of the relation (required)
				/// </pre>
				/// <code>optional string relation = 2;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearRelation()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					relation_ = GetDefaultInstance().GetRelation();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The surface form of the relation (required)
				/// </pre>
				/// <code>optional string relation = 2;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetRelationBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000002));
					relation_ = value;
					OnChanged();
					return this;
				}

				private object object_ = string.Empty;

				/// <summary>
				/// <pre>
				/// The surface form of the object
				/// </pre>
				/// <code>optional string object = 3;</code>
				/// </summary>
				public bool HasObject()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary>
				/// <pre>
				/// The surface form of the object
				/// </pre>
				/// <code>optional string object = 3;</code>
				/// </summary>
				public string GetObject()
				{
					object @ref = object_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							object_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The surface form of the object
				/// </pre>
				/// <code>optional string object = 3;</code>
				/// </summary>
				public ByteString GetObjectBytes()
				{
					object @ref = object_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						object_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary>
				/// <pre>
				/// The surface form of the object
				/// </pre>
				/// <code>optional string object = 3;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetObject(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					object_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The surface form of the object
				/// </pre>
				/// <code>optional string object = 3;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearObject()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					object_ = GetDefaultInstance().GetObject();
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The surface form of the object
				/// </pre>
				/// <code>optional string object = 3;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetObjectBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					object_ = value;
					OnChanged();
					return this;
				}

				private double confidence_;

				/// <summary>
				/// <pre>
				/// The [optional] confidence of the extraction
				/// </pre>
				/// <code>optional double confidence = 4;</code>
				/// </summary>
				public bool HasConfidence()
				{
					return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
				}

				/// <summary>
				/// <pre>
				/// The [optional] confidence of the extraction
				/// </pre>
				/// <code>optional double confidence = 4;</code>
				/// </summary>
				public double GetConfidence()
				{
					return confidence_;
				}

				/// <summary>
				/// <pre>
				/// The [optional] confidence of the extraction
				/// </pre>
				/// <code>optional double confidence = 4;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetConfidence(double value)
				{
					bitField0_ |= unchecked((int)(0x00000008));
					confidence_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// The [optional] confidence of the extraction
				/// </pre>
				/// <code>optional double confidence = 4;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearConfidence()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					confidence_ = 0D;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.TokenLocation> subjectTokens_ = Java.Util.Collections.EmptyList();

				private void EnsureSubjectTokensIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						subjectTokens_ = new List<CoreNLPProtos.TokenLocation>(subjectTokens_);
						bitField0_ |= unchecked((int)(0x00000010));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder> subjectTokensBuilder_;

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public IList<CoreNLPProtos.TokenLocation> GetSubjectTokensList()
				{
					if (subjectTokensBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(subjectTokens_);
					}
					else
					{
						return subjectTokensBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public int GetSubjectTokensCount()
				{
					if (subjectTokensBuilder_ == null)
					{
						return subjectTokens_.Count;
					}
					else
					{
						return subjectTokensBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation GetSubjectTokens(int index)
				{
					if (subjectTokensBuilder_ == null)
					{
						return subjectTokens_[index];
					}
					else
					{
						return subjectTokensBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetSubjectTokens(int index, CoreNLPProtos.TokenLocation value)
				{
					if (subjectTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSubjectTokensIsMutable();
						subjectTokens_.Set(index, value);
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetSubjectTokens(int index, CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (subjectTokensBuilder_ == null)
					{
						EnsureSubjectTokensIsMutable();
						subjectTokens_.Set(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.SetMessage(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddSubjectTokens(CoreNLPProtos.TokenLocation value)
				{
					if (subjectTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSubjectTokensIsMutable();
						subjectTokens_.Add(value);
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddSubjectTokens(int index, CoreNLPProtos.TokenLocation value)
				{
					if (subjectTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureSubjectTokensIsMutable();
						subjectTokens_.Add(index, value);
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddSubjectTokens(CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (subjectTokensBuilder_ == null)
					{
						EnsureSubjectTokensIsMutable();
						subjectTokens_.Add(((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.AddMessage(((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddSubjectTokens(int index, CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (subjectTokensBuilder_ == null)
					{
						EnsureSubjectTokensIsMutable();
						subjectTokens_.Add(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.AddMessage(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddAllSubjectTokens<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.TokenLocation
				{
					if (subjectTokensBuilder_ == null)
					{
						EnsureSubjectTokensIsMutable();
						AbstractMessageLite.Builder.AddAll(values, subjectTokens_);
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearSubjectTokens()
				{
					if (subjectTokensBuilder_ == null)
					{
						subjectTokens_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder RemoveSubjectTokens(int index)
				{
					if (subjectTokensBuilder_ == null)
					{
						EnsureSubjectTokensIsMutable();
						subjectTokens_.Remove(index);
						OnChanged();
					}
					else
					{
						subjectTokensBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder GetSubjectTokensBuilder(int index)
				{
					return GetSubjectTokensFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.ITokenLocationOrBuilder GetSubjectTokensOrBuilder(int index)
				{
					if (subjectTokensBuilder_ == null)
					{
						return subjectTokens_[index];
					}
					else
					{
						return subjectTokensBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public IList<CoreNLPProtos.ITokenLocationOrBuilder> GetSubjectTokensOrBuilderList()
				{
					if (subjectTokensBuilder_ != null)
					{
						return subjectTokensBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(subjectTokens_);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder AddSubjectTokensBuilder()
				{
					return GetSubjectTokensFieldBuilder().AddBuilder(CoreNLPProtos.TokenLocation.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder AddSubjectTokensBuilder(int index)
				{
					return GetSubjectTokensFieldBuilder().AddBuilder(index, CoreNLPProtos.TokenLocation.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the subject of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation subjectTokens = 13;</code>
				/// </summary>
				public IList<CoreNLPProtos.TokenLocation.Builder> GetSubjectTokensBuilderList()
				{
					return GetSubjectTokensFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder> GetSubjectTokensFieldBuilder()
				{
					if (subjectTokensBuilder_ == null)
					{
						subjectTokensBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder>(subjectTokens_, ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010
							))), GetParentForChildren(), IsClean());
						subjectTokens_ = null;
					}
					return subjectTokensBuilder_;
				}

				private IList<CoreNLPProtos.TokenLocation> relationTokens_ = Java.Util.Collections.EmptyList();

				private void EnsureRelationTokensIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						relationTokens_ = new List<CoreNLPProtos.TokenLocation>(relationTokens_);
						bitField0_ |= unchecked((int)(0x00000020));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder> relationTokensBuilder_;

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.TokenLocation> GetRelationTokensList()
				{
					if (relationTokensBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(relationTokens_);
					}
					else
					{
						return relationTokensBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public int GetRelationTokensCount()
				{
					if (relationTokensBuilder_ == null)
					{
						return relationTokens_.Count;
					}
					else
					{
						return relationTokensBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation GetRelationTokens(int index)
				{
					if (relationTokensBuilder_ == null)
					{
						return relationTokens_[index];
					}
					else
					{
						return relationTokensBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetRelationTokens(int index, CoreNLPProtos.TokenLocation value)
				{
					if (relationTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureRelationTokensIsMutable();
						relationTokens_.Set(index, value);
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetRelationTokens(int index, CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (relationTokensBuilder_ == null)
					{
						EnsureRelationTokensIsMutable();
						relationTokens_.Set(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.SetMessage(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddRelationTokens(CoreNLPProtos.TokenLocation value)
				{
					if (relationTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureRelationTokensIsMutable();
						relationTokens_.Add(value);
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddRelationTokens(int index, CoreNLPProtos.TokenLocation value)
				{
					if (relationTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureRelationTokensIsMutable();
						relationTokens_.Add(index, value);
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddRelationTokens(CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (relationTokensBuilder_ == null)
					{
						EnsureRelationTokensIsMutable();
						relationTokens_.Add(((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.AddMessage(((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddRelationTokens(int index, CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (relationTokensBuilder_ == null)
					{
						EnsureRelationTokensIsMutable();
						relationTokens_.Add(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.AddMessage(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddAllRelationTokens<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.TokenLocation
				{
					if (relationTokensBuilder_ == null)
					{
						EnsureRelationTokensIsMutable();
						AbstractMessageLite.Builder.AddAll(values, relationTokens_);
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearRelationTokens()
				{
					if (relationTokensBuilder_ == null)
					{
						relationTokens_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder RemoveRelationTokens(int index)
				{
					if (relationTokensBuilder_ == null)
					{
						EnsureRelationTokensIsMutable();
						relationTokens_.Remove(index);
						OnChanged();
					}
					else
					{
						relationTokensBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder GetRelationTokensBuilder(int index)
				{
					return GetRelationTokensFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.ITokenLocationOrBuilder GetRelationTokensOrBuilder(int index)
				{
					if (relationTokensBuilder_ == null)
					{
						return relationTokens_[index];
					}
					else
					{
						return relationTokensBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.ITokenLocationOrBuilder> GetRelationTokensOrBuilderList()
				{
					if (relationTokensBuilder_ != null)
					{
						return relationTokensBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(relationTokens_);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder AddRelationTokensBuilder()
				{
					return GetRelationTokensFieldBuilder().AddBuilder(CoreNLPProtos.TokenLocation.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder AddRelationTokensBuilder(int index)
				{
					return GetRelationTokensFieldBuilder().AddBuilder(index, CoreNLPProtos.TokenLocation.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the relation of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation relationTokens = 14;</code>
				/// </summary>
				public IList<CoreNLPProtos.TokenLocation.Builder> GetRelationTokensBuilderList()
				{
					return GetRelationTokensFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder> GetRelationTokensFieldBuilder()
				{
					if (relationTokensBuilder_ == null)
					{
						relationTokensBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder>(relationTokens_, ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020
							))), GetParentForChildren(), IsClean());
						relationTokens_ = null;
					}
					return relationTokensBuilder_;
				}

				private IList<CoreNLPProtos.TokenLocation> objectTokens_ = Java.Util.Collections.EmptyList();

				private void EnsureObjectTokensIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						objectTokens_ = new List<CoreNLPProtos.TokenLocation>(objectTokens_);
						bitField0_ |= unchecked((int)(0x00000040));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder> objectTokensBuilder_;

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public IList<CoreNLPProtos.TokenLocation> GetObjectTokensList()
				{
					if (objectTokensBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(objectTokens_);
					}
					else
					{
						return objectTokensBuilder_.GetMessageList();
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public int GetObjectTokensCount()
				{
					if (objectTokensBuilder_ == null)
					{
						return objectTokens_.Count;
					}
					else
					{
						return objectTokensBuilder_.GetCount();
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation GetObjectTokens(int index)
				{
					if (objectTokensBuilder_ == null)
					{
						return objectTokens_[index];
					}
					else
					{
						return objectTokensBuilder_.GetMessage(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetObjectTokens(int index, CoreNLPProtos.TokenLocation value)
				{
					if (objectTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureObjectTokensIsMutable();
						objectTokens_.Set(index, value);
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetObjectTokens(int index, CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (objectTokensBuilder_ == null)
					{
						EnsureObjectTokensIsMutable();
						objectTokens_.Set(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.SetMessage(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddObjectTokens(CoreNLPProtos.TokenLocation value)
				{
					if (objectTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureObjectTokensIsMutable();
						objectTokens_.Add(value);
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddObjectTokens(int index, CoreNLPProtos.TokenLocation value)
				{
					if (objectTokensBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureObjectTokensIsMutable();
						objectTokens_.Add(index, value);
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddObjectTokens(CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (objectTokensBuilder_ == null)
					{
						EnsureObjectTokensIsMutable();
						objectTokens_.Add(((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.AddMessage(((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddObjectTokens(int index, CoreNLPProtos.TokenLocation.Builder builderForValue)
				{
					if (objectTokensBuilder_ == null)
					{
						EnsureObjectTokensIsMutable();
						objectTokens_.Add(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.AddMessage(index, ((CoreNLPProtos.TokenLocation)builderForValue.Build()));
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder AddAllObjectTokens<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.TokenLocation
				{
					if (objectTokensBuilder_ == null)
					{
						EnsureObjectTokensIsMutable();
						AbstractMessageLite.Builder.AddAll(values, objectTokens_);
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearObjectTokens()
				{
					if (objectTokensBuilder_ == null)
					{
						objectTokens_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.Clear();
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder RemoveObjectTokens(int index)
				{
					if (objectTokensBuilder_ == null)
					{
						EnsureObjectTokensIsMutable();
						objectTokens_.Remove(index);
						OnChanged();
					}
					else
					{
						objectTokensBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder GetObjectTokensBuilder(int index)
				{
					return GetObjectTokensFieldBuilder().GetBuilder(index);
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.ITokenLocationOrBuilder GetObjectTokensOrBuilder(int index)
				{
					if (objectTokensBuilder_ == null)
					{
						return objectTokens_[index];
					}
					else
					{
						return objectTokensBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public IList<CoreNLPProtos.ITokenLocationOrBuilder> GetObjectTokensOrBuilderList()
				{
					if (objectTokensBuilder_ != null)
					{
						return objectTokensBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(objectTokens_);
					}
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder AddObjectTokensBuilder()
				{
					return GetObjectTokensFieldBuilder().AddBuilder(CoreNLPProtos.TokenLocation.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public CoreNLPProtos.TokenLocation.Builder AddObjectTokensBuilder(int index)
				{
					return GetObjectTokensFieldBuilder().AddBuilder(index, CoreNLPProtos.TokenLocation.GetDefaultInstance());
				}

				/// <summary>
				/// <pre>
				/// The tokens comprising the object of the triple
				/// </pre>
				/// <code>repeated .edu.stanford.nlp.pipeline.TokenLocation objectTokens = 15;</code>
				/// </summary>
				public IList<CoreNLPProtos.TokenLocation.Builder> GetObjectTokensBuilderList()
				{
					return GetObjectTokensFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder> GetObjectTokensFieldBuilder()
				{
					if (objectTokensBuilder_ == null)
					{
						objectTokensBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.TokenLocation, CoreNLPProtos.TokenLocation.Builder, CoreNLPProtos.ITokenLocationOrBuilder>(objectTokens_, ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040
							))), GetParentForChildren(), IsClean());
						objectTokens_ = null;
					}
					return objectTokensBuilder_;
				}

				private CoreNLPProtos.DependencyGraph tree_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> treeBuilder_;

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public bool HasTree()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public CoreNLPProtos.DependencyGraph GetTree()
				{
					if (treeBuilder_ == null)
					{
						return tree_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : tree_;
					}
					else
					{
						return treeBuilder_.GetMessage();
					}
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetTree(CoreNLPProtos.DependencyGraph value)
				{
					if (treeBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						tree_ = value;
						OnChanged();
					}
					else
					{
						treeBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00000080));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetTree(CoreNLPProtos.DependencyGraph.Builder builderForValue)
				{
					if (treeBuilder_ == null)
					{
						tree_ = ((CoreNLPProtos.DependencyGraph)builderForValue.Build());
						OnChanged();
					}
					else
					{
						treeBuilder_.SetMessage(((CoreNLPProtos.DependencyGraph)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00000080));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder MergeTree(CoreNLPProtos.DependencyGraph value)
				{
					if (treeBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))) && tree_ != null && tree_ != CoreNLPProtos.DependencyGraph.GetDefaultInstance())
						{
							tree_ = ((CoreNLPProtos.DependencyGraph)CoreNLPProtos.DependencyGraph.NewBuilder(tree_).MergeFrom(value).BuildPartial());
						}
						else
						{
							tree_ = value;
						}
						OnChanged();
					}
					else
					{
						treeBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00000080));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearTree()
				{
					if (treeBuilder_ == null)
					{
						tree_ = null;
						OnChanged();
					}
					else
					{
						treeBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					return this;
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public CoreNLPProtos.DependencyGraph.Builder GetTreeBuilder()
				{
					bitField0_ |= unchecked((int)(0x00000080));
					OnChanged();
					return GetTreeFieldBuilder().GetBuilder();
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				public CoreNLPProtos.IDependencyGraphOrBuilder GetTreeOrBuilder()
				{
					if (treeBuilder_ != null)
					{
						return treeBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return tree_ == null ? CoreNLPProtos.DependencyGraph.GetDefaultInstance() : tree_;
					}
				}

				/// <summary>
				/// <pre>
				/// The dependency graph fragment for this triple
				/// </pre>
				/// <code>optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;</code>
				/// </summary>
				private SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder> GetTreeFieldBuilder()
				{
					if (treeBuilder_ == null)
					{
						treeBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.DependencyGraph, CoreNLPProtos.DependencyGraph.Builder, CoreNLPProtos.IDependencyGraphOrBuilder>(GetTree(), GetParentForChildren(), IsClean());
						tree_ = null;
					}
					return treeBuilder_;
				}

				private bool istmod_;

				/// <summary>
				/// <pre>
				/// If true, this expresses an implicit tmod relation
				/// </pre>
				/// <code>optional bool istmod = 9;</code>
				/// </summary>
				public bool HasIstmod()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary>
				/// <pre>
				/// If true, this expresses an implicit tmod relation
				/// </pre>
				/// <code>optional bool istmod = 9;</code>
				/// </summary>
				public bool GetIstmod()
				{
					return istmod_;
				}

				/// <summary>
				/// <pre>
				/// If true, this expresses an implicit tmod relation
				/// </pre>
				/// <code>optional bool istmod = 9;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetIstmod(bool value)
				{
					bitField0_ |= unchecked((int)(0x00000100));
					istmod_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// If true, this expresses an implicit tmod relation
				/// </pre>
				/// <code>optional bool istmod = 9;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearIstmod()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					istmod_ = false;
					OnChanged();
					return this;
				}

				private bool prefixBe_;

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' prefix
				/// </pre>
				/// <code>optional bool prefixBe = 10;</code>
				/// </summary>
				public bool HasPrefixBe()
				{
					return ((bitField0_ & unchecked((int)(0x00000200))) == unchecked((int)(0x00000200)));
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' prefix
				/// </pre>
				/// <code>optional bool prefixBe = 10;</code>
				/// </summary>
				public bool GetPrefixBe()
				{
					return prefixBe_;
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' prefix
				/// </pre>
				/// <code>optional bool prefixBe = 10;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetPrefixBe(bool value)
				{
					bitField0_ |= unchecked((int)(0x00000200));
					prefixBe_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' prefix
				/// </pre>
				/// <code>optional bool prefixBe = 10;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearPrefixBe()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000200)));
					prefixBe_ = false;
					OnChanged();
					return this;
				}

				private bool suffixBe_;

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' suffix
				/// </pre>
				/// <code>optional bool suffixBe = 11;</code>
				/// </summary>
				public bool HasSuffixBe()
				{
					return ((bitField0_ & unchecked((int)(0x00000400))) == unchecked((int)(0x00000400)));
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' suffix
				/// </pre>
				/// <code>optional bool suffixBe = 11;</code>
				/// </summary>
				public bool GetSuffixBe()
				{
					return suffixBe_;
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' suffix
				/// </pre>
				/// <code>optional bool suffixBe = 11;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetSuffixBe(bool value)
				{
					bitField0_ |= unchecked((int)(0x00000400));
					suffixBe_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'be' suffix
				/// </pre>
				/// <code>optional bool suffixBe = 11;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearSuffixBe()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000400)));
					suffixBe_ = false;
					OnChanged();
					return this;
				}

				private bool suffixOf_;

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'of' prefix
				/// </pre>
				/// <code>optional bool suffixOf = 12;</code>
				/// </summary>
				public bool HasSuffixOf()
				{
					return ((bitField0_ & unchecked((int)(0x00000800))) == unchecked((int)(0x00000800)));
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'of' prefix
				/// </pre>
				/// <code>optional bool suffixOf = 12;</code>
				/// </summary>
				public bool GetSuffixOf()
				{
					return suffixOf_;
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'of' prefix
				/// </pre>
				/// <code>optional bool suffixOf = 12;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder SetSuffixOf(bool value)
				{
					bitField0_ |= unchecked((int)(0x00000800));
					suffixOf_ = value;
					OnChanged();
					return this;
				}

				/// <summary>
				/// <pre>
				/// If true, this relation string is missing a 'of' prefix
				/// </pre>
				/// <code>optional bool suffixOf = 12;</code>
				/// </summary>
				public CoreNLPProtos.RelationTriple.Builder ClearSuffixOf()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000800)));
					suffixOf_ = false;
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.RelationTriple.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.RelationTriple)
			}

			private static readonly CoreNLPProtos.RelationTriple DefaultInstance;

			static RelationTriple()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.RelationTriple)
				DefaultInstance = new CoreNLPProtos.RelationTriple();
			}

			public static CoreNLPProtos.RelationTriple GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_57931 : AbstractParser<CoreNLPProtos.RelationTriple>
			{
				public _AbstractParser_57931()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.RelationTriple ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.RelationTriple(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.RelationTriple> Parser = new _AbstractParser_57931();

			public static IParser<CoreNLPProtos.RelationTriple> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IMapStringStringOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.MapStringString)
			/// <summary><code>repeated string key = 1;</code></summary>
			IList<string> GetKeyList();

			/// <summary><code>repeated string key = 1;</code></summary>
			int GetKeyCount();

			/// <summary><code>repeated string key = 1;</code></summary>
			string GetKey(int index);

			/// <summary><code>repeated string key = 1;</code></summary>
			ByteString GetKeyBytes(int index);

			/// <summary><code>repeated string value = 2;</code></summary>
			IList<string> GetValueList();

			/// <summary><code>repeated string value = 2;</code></summary>
			int GetValueCount();

			/// <summary><code>repeated string value = 2;</code></summary>
			string GetValue(int index);

			/// <summary><code>repeated string value = 2;</code></summary>
			ByteString GetValueBytes(int index);
		}

		/// <summary>
		/// <pre>
		/// A map from strings to strings.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A map from strings to strings.
		/// Used, minimally, in the CoNLLU featurizer
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.MapStringString</c>
		/// </remarks>
		[System.Serializable]
		public sealed class MapStringString : GeneratedMessageV3, CoreNLPProtos.IMapStringStringOrBuilder
		{
			private MapStringString(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private MapStringString()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.MapStringString)
				// Use MapStringString.newBuilder() to construct.
				key_ = LazyStringArrayList.Empty;
				value_ = LazyStringArrayList.Empty;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private MapStringString(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 10:
							{
								ByteString bs = input.ReadBytes();
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									key_ = new LazyStringArrayList();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								key_.Add(bs);
								break;
							}

							case 18:
							{
								ByteString bs = input.ReadBytes();
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									value_ = new LazyStringArrayList();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								value_.Add(bs);
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						key_ = key_.GetUnmodifiableView();
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						value_ = value_.GetUnmodifiableView();
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapStringString_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapStringString_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.MapStringString), typeof(CoreNLPProtos.MapStringString.Builder));
			}

			public const int KeyFieldNumber = 1;

			private ILazyStringList key_;

			/// <summary><code>repeated string key = 1;</code></summary>
			public IProtocolStringList GetKeyList()
			{
				return key_;
			}

			/// <summary><code>repeated string key = 1;</code></summary>
			public int GetKeyCount()
			{
				return key_.Count;
			}

			/// <summary><code>repeated string key = 1;</code></summary>
			public string GetKey(int index)
			{
				return key_[index];
			}

			/// <summary><code>repeated string key = 1;</code></summary>
			public ByteString GetKeyBytes(int index)
			{
				return key_.GetByteString(index);
			}

			public const int ValueFieldNumber = 2;

			private ILazyStringList value_;

			/// <summary><code>repeated string value = 2;</code></summary>
			public IProtocolStringList GetValueList()
			{
				return value_;
			}

			/// <summary><code>repeated string value = 2;</code></summary>
			public int GetValueCount()
			{
				return value_.Count;
			}

			/// <summary><code>repeated string value = 2;</code></summary>
			public string GetValue(int index)
			{
				return value_[index];
			}

			/// <summary><code>repeated string value = 2;</code></summary>
			public ByteString GetValueBytes(int index)
			{
				return value_.GetByteString(index);
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				for (int i = 0; i < key_.Count; i++)
				{
					GeneratedMessageV3.WriteString(output, 1, key_.GetRaw(i));
				}
				for (int i_1 = 0; i_1 < value_.Count; i_1++)
				{
					GeneratedMessageV3.WriteString(output, 2, value_.GetRaw(i_1));
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				{
					int dataSize = 0;
					for (int i = 0; i < key_.Count; i++)
					{
						dataSize += ComputeStringSizeNoTag(key_.GetRaw(i));
					}
					size += dataSize;
					size += 1 * GetKeyList().Count;
				}
				{
					int dataSize = 0;
					for (int i = 0; i < value_.Count; i++)
					{
						dataSize += ComputeStringSizeNoTag(value_.GetRaw(i));
					}
					size += dataSize;
					size += 1 * GetValueList().Count;
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.MapStringString))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.MapStringString other = (CoreNLPProtos.MapStringString)obj;
				bool result = true;
				result = result && GetKeyList().Equals(other.GetKeyList());
				result = result && GetValueList().Equals(other.GetValueList());
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (GetKeyCount() > 0)
				{
					hash = (37 * hash) + KeyFieldNumber;
					hash = (53 * hash) + GetKeyList().GetHashCode();
				}
				if (GetValueCount() > 0)
				{
					hash = (37 * hash) + ValueFieldNumber;
					hash = (53 * hash) + GetValueList().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapStringString ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapStringString ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapStringString ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.MapStringString.Builder NewBuilder()
			{
				return ((CoreNLPProtos.MapStringString.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.MapStringString.Builder NewBuilder(CoreNLPProtos.MapStringString prototype)
			{
				return ((CoreNLPProtos.MapStringString.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.MapStringString.Builder() : new CoreNLPProtos.MapStringString.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.MapStringString.Builder builder = new CoreNLPProtos.MapStringString.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A map from strings to strings.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A map from strings to strings.
			/// Used, minimally, in the CoNLLU featurizer
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.MapStringString</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.MapStringString.Builder>, CoreNLPProtos.IMapStringStringOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.MapStringString)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapStringString_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapStringString_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.MapStringString), typeof(CoreNLPProtos.MapStringString.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.MapStringString.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					key_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					value_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapStringString_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.MapStringString.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.MapStringString result = ((CoreNLPProtos.MapStringString)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.MapStringString result = new CoreNLPProtos.MapStringString(this);
					int from_bitField0_ = bitField0_;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						key_ = key_.GetUnmodifiableView();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					result.key_ = key_;
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						value_ = value_.GetUnmodifiableView();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					result.value_ = value_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.MapStringString.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.MapStringString.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.MapStringString.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.MapStringString.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.MapStringString.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.MapStringString.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.MapStringString.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.MapStringString.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.MapStringString)
					{
						return MergeFrom((CoreNLPProtos.MapStringString)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.MapStringString.Builder MergeFrom(CoreNLPProtos.MapStringString other)
				{
					if (other == CoreNLPProtos.MapStringString.GetDefaultInstance())
					{
						return this;
					}
					if (!other.key_.IsEmpty())
					{
						if (key_.IsEmpty())
						{
							key_ = other.key_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						else
						{
							EnsureKeyIsMutable();
							Sharpen.Collections.AddAll(key_, other.key_);
						}
						OnChanged();
					}
					if (!other.value_.IsEmpty())
					{
						if (value_.IsEmpty())
						{
							value_ = other.value_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						else
						{
							EnsureValueIsMutable();
							Sharpen.Collections.AddAll(value_, other.value_);
						}
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.MapStringString parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.MapStringString)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private ILazyStringList key_ = LazyStringArrayList.Empty;

				private void EnsureKeyIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						key_ = new LazyStringArrayList(key_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public IProtocolStringList GetKeyList()
				{
					return key_.GetUnmodifiableView();
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public int GetKeyCount()
				{
					return key_.Count;
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public string GetKey(int index)
				{
					return key_[index];
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public ByteString GetKeyBytes(int index)
				{
					return key_.GetByteString(index);
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public CoreNLPProtos.MapStringString.Builder SetKey(int index, string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureKeyIsMutable();
					key_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public CoreNLPProtos.MapStringString.Builder AddKey(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureKeyIsMutable();
					key_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public CoreNLPProtos.MapStringString.Builder AddAllKey(IEnumerable<string> values)
				{
					EnsureKeyIsMutable();
					AbstractMessageLite.Builder.AddAll(values, key_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public CoreNLPProtos.MapStringString.Builder ClearKey()
				{
					key_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string key = 1;</code></summary>
				public CoreNLPProtos.MapStringString.Builder AddKeyBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureKeyIsMutable();
					key_.Add(value);
					OnChanged();
					return this;
				}

				private ILazyStringList value_ = LazyStringArrayList.Empty;

				private void EnsureValueIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						value_ = new LazyStringArrayList(value_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public IProtocolStringList GetValueList()
				{
					return value_.GetUnmodifiableView();
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public int GetValueCount()
				{
					return value_.Count;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public string GetValue(int index)
				{
					return value_[index];
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public ByteString GetValueBytes(int index)
				{
					return value_.GetByteString(index);
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapStringString.Builder SetValue(int index, string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureValueIsMutable();
					value_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapStringString.Builder AddValue(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureValueIsMutable();
					value_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapStringString.Builder AddAllValue(IEnumerable<string> values)
				{
					EnsureValueIsMutable();
					AbstractMessageLite.Builder.AddAll(values, value_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapStringString.Builder ClearValue()
				{
					value_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapStringString.Builder AddValueBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureValueIsMutable();
					value_.Add(value);
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.MapStringString.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.MapStringString)
			}

			private static readonly CoreNLPProtos.MapStringString DefaultInstance;

			static MapStringString()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.MapStringString)
				DefaultInstance = new CoreNLPProtos.MapStringString();
			}

			public static CoreNLPProtos.MapStringString GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_58693 : AbstractParser<CoreNLPProtos.MapStringString>
			{
				public _AbstractParser_58693()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.MapStringString ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.MapStringString(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.MapStringString> Parser = new _AbstractParser_58693();

			public static IParser<CoreNLPProtos.MapStringString> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface IMapIntStringOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.MapIntString)
			/// <summary><code>repeated uint32 key = 1;</code></summary>
			IList<int> GetKeyList();

			/// <summary><code>repeated uint32 key = 1;</code></summary>
			int GetKeyCount();

			/// <summary><code>repeated uint32 key = 1;</code></summary>
			int GetKey(int index);

			/// <summary><code>repeated string value = 2;</code></summary>
			IList<string> GetValueList();

			/// <summary><code>repeated string value = 2;</code></summary>
			int GetValueCount();

			/// <summary><code>repeated string value = 2;</code></summary>
			string GetValue(int index);

			/// <summary><code>repeated string value = 2;</code></summary>
			ByteString GetValueBytes(int index);
		}

		/// <summary>
		/// <pre>
		/// A map from integers to strings.
		/// </summary>
		/// <remarks>
		/// <pre>
		/// A map from integers to strings.
		/// Used, minimally, in the CoNLLU featurizer
		/// </pre>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.MapIntString</c>
		/// </remarks>
		[System.Serializable]
		public sealed class MapIntString : GeneratedMessageV3, CoreNLPProtos.IMapIntStringOrBuilder
		{
			private MapIntString(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private MapIntString()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.MapIntString)
				// Use MapIntString.newBuilder() to construct.
				key_ = Java.Util.Collections.EmptyList();
				value_ = LazyStringArrayList.Empty;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private MapIntString(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
								{
									key_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								key_.Add(input.ReadUInt32());
								break;
							}

							case 10:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))) && input.GetBytesUntilLimit() > 0)
								{
									key_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000001));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									key_.Add(input.ReadUInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 18:
							{
								ByteString bs = input.ReadBytes();
								if (!((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
								{
									value_ = new LazyStringArrayList();
									mutable_bitField0_ |= unchecked((int)(0x00000002));
								}
								value_.Add(bs);
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						key_ = Java.Util.Collections.UnmodifiableList(key_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						value_ = value_.GetUnmodifiableView();
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapIntString_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapIntString_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.MapIntString), typeof(CoreNLPProtos.MapIntString.Builder));
			}

			public const int KeyFieldNumber = 1;

			private IList<int> key_;

			/// <summary><code>repeated uint32 key = 1;</code></summary>
			public IList<int> GetKeyList()
			{
				return key_;
			}

			/// <summary><code>repeated uint32 key = 1;</code></summary>
			public int GetKeyCount()
			{
				return key_.Count;
			}

			/// <summary><code>repeated uint32 key = 1;</code></summary>
			public int GetKey(int index)
			{
				return key_[index];
			}

			public const int ValueFieldNumber = 2;

			private ILazyStringList value_;

			/// <summary><code>repeated string value = 2;</code></summary>
			public IProtocolStringList GetValueList()
			{
				return value_;
			}

			/// <summary><code>repeated string value = 2;</code></summary>
			public int GetValueCount()
			{
				return value_.Count;
			}

			/// <summary><code>repeated string value = 2;</code></summary>
			public string GetValue(int index)
			{
				return value_[index];
			}

			/// <summary><code>repeated string value = 2;</code></summary>
			public ByteString GetValueBytes(int index)
			{
				return value_.GetByteString(index);
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				for (int i = 0; i < key_.Count; i++)
				{
					output.WriteUInt32(1, key_[i]);
				}
				for (int i_1 = 0; i_1 < value_.Count; i_1++)
				{
					GeneratedMessageV3.WriteString(output, 2, value_.GetRaw(i_1));
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				{
					int dataSize = 0;
					for (int i = 0; i < key_.Count; i++)
					{
						dataSize += CodedOutputStream.ComputeUInt32SizeNoTag(key_[i]);
					}
					size += dataSize;
					size += 1 * GetKeyList().Count;
				}
				{
					int dataSize = 0;
					for (int i = 0; i < value_.Count; i++)
					{
						dataSize += ComputeStringSizeNoTag(value_.GetRaw(i));
					}
					size += dataSize;
					size += 1 * GetValueList().Count;
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.MapIntString))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.MapIntString other = (CoreNLPProtos.MapIntString)obj;
				bool result = true;
				result = result && GetKeyList().Equals(other.GetKeyList());
				result = result && GetValueList().Equals(other.GetValueList());
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (GetKeyCount() > 0)
				{
					hash = (37 * hash) + KeyFieldNumber;
					hash = (53 * hash) + GetKeyList().GetHashCode();
				}
				if (GetValueCount() > 0)
				{
					hash = (37 * hash) + ValueFieldNumber;
					hash = (53 * hash) + GetValueList().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapIntString ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapIntString ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.MapIntString ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.MapIntString.Builder NewBuilder()
			{
				return ((CoreNLPProtos.MapIntString.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.MapIntString.Builder NewBuilder(CoreNLPProtos.MapIntString prototype)
			{
				return ((CoreNLPProtos.MapIntString.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.MapIntString.Builder() : new CoreNLPProtos.MapIntString.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.MapIntString.Builder builder = new CoreNLPProtos.MapIntString.Builder(parent);
				return builder;
			}

			/// <summary>
			/// <pre>
			/// A map from integers to strings.
			/// </summary>
			/// <remarks>
			/// <pre>
			/// A map from integers to strings.
			/// Used, minimally, in the CoNLLU featurizer
			/// </pre>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.MapIntString</c>
			/// </remarks>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.MapIntString.Builder>, CoreNLPProtos.IMapIntStringOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.MapIntString)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapIntString_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapIntString_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.MapIntString), typeof(CoreNLPProtos.MapIntString.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.MapIntString.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					key_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					value_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_MapIntString_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.MapIntString.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.MapIntString result = ((CoreNLPProtos.MapIntString)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.MapIntString result = new CoreNLPProtos.MapIntString(this);
					int from_bitField0_ = bitField0_;
					if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						key_ = Java.Util.Collections.UnmodifiableList(key_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					}
					result.key_ = key_;
					if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						value_ = value_.GetUnmodifiableView();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					}
					result.value_ = value_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.MapIntString.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.MapIntString.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.MapIntString.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.MapIntString.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.MapIntString.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.MapIntString.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.MapIntString.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.MapIntString.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.MapIntString)
					{
						return MergeFrom((CoreNLPProtos.MapIntString)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.MapIntString.Builder MergeFrom(CoreNLPProtos.MapIntString other)
				{
					if (other == CoreNLPProtos.MapIntString.GetDefaultInstance())
					{
						return this;
					}
					if (!other.key_.IsEmpty())
					{
						if (key_.IsEmpty())
						{
							key_ = other.key_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
						}
						else
						{
							EnsureKeyIsMutable();
							Sharpen.Collections.AddAll(key_, other.key_);
						}
						OnChanged();
					}
					if (!other.value_.IsEmpty())
					{
						if (value_.IsEmpty())
						{
							value_ = other.value_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
						}
						else
						{
							EnsureValueIsMutable();
							Sharpen.Collections.AddAll(value_, other.value_);
						}
						OnChanged();
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.MapIntString parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.MapIntString)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private IList<int> key_ = Java.Util.Collections.EmptyList();

				private void EnsureKeyIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						key_ = new List<int>(key_);
						bitField0_ |= unchecked((int)(0x00000001));
					}
				}

				/// <summary><code>repeated uint32 key = 1;</code></summary>
				public IList<int> GetKeyList()
				{
					return Java.Util.Collections.UnmodifiableList(key_);
				}

				/// <summary><code>repeated uint32 key = 1;</code></summary>
				public int GetKeyCount()
				{
					return key_.Count;
				}

				/// <summary><code>repeated uint32 key = 1;</code></summary>
				public int GetKey(int index)
				{
					return key_[index];
				}

				/// <summary><code>repeated uint32 key = 1;</code></summary>
				public CoreNLPProtos.MapIntString.Builder SetKey(int index, int value)
				{
					EnsureKeyIsMutable();
					key_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 key = 1;</code></summary>
				public CoreNLPProtos.MapIntString.Builder AddKey(int value)
				{
					EnsureKeyIsMutable();
					key_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 key = 1;</code></summary>
				public CoreNLPProtos.MapIntString.Builder AddAllKey<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureKeyIsMutable();
					AbstractMessageLite.Builder.AddAll(values, key_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 key = 1;</code></summary>
				public CoreNLPProtos.MapIntString.Builder ClearKey()
				{
					key_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					OnChanged();
					return this;
				}

				private ILazyStringList value_ = LazyStringArrayList.Empty;

				private void EnsureValueIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						value_ = new LazyStringArrayList(value_);
						bitField0_ |= unchecked((int)(0x00000002));
					}
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public IProtocolStringList GetValueList()
				{
					return value_.GetUnmodifiableView();
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public int GetValueCount()
				{
					return value_.Count;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public string GetValue(int index)
				{
					return value_[index];
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public ByteString GetValueBytes(int index)
				{
					return value_.GetByteString(index);
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapIntString.Builder SetValue(int index, string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureValueIsMutable();
					value_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapIntString.Builder AddValue(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureValueIsMutable();
					value_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapIntString.Builder AddAllValue(IEnumerable<string> values)
				{
					EnsureValueIsMutable();
					AbstractMessageLite.Builder.AddAll(values, value_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapIntString.Builder ClearValue()
				{
					value_ = LazyStringArrayList.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					OnChanged();
					return this;
				}

				/// <summary><code>repeated string value = 2;</code></summary>
				public CoreNLPProtos.MapIntString.Builder AddValueBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					EnsureValueIsMutable();
					value_.Add(value);
					OnChanged();
					return this;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.MapIntString.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.MapIntString)
			}

			private static readonly CoreNLPProtos.MapIntString DefaultInstance;

			static MapIntString()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.MapIntString)
				DefaultInstance = new CoreNLPProtos.MapIntString();
			}

			public static CoreNLPProtos.MapIntString GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_59428 : AbstractParser<CoreNLPProtos.MapIntString>
			{
				public _AbstractParser_59428()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.MapIntString ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.MapIntString(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.MapIntString> Parser = new _AbstractParser_59428();

			public static IParser<CoreNLPProtos.MapIntString> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		public interface ISectionOrBuilder : IMessageOrBuilder
		{
			// @@protoc_insertion_point(interface_extends:edu.stanford.nlp.pipeline.Section)
			/// <summary><code>required uint32 charBegin = 1;</code></summary>
			bool HasCharBegin();

			/// <summary><code>required uint32 charBegin = 1;</code></summary>
			int GetCharBegin();

			/// <summary><code>required uint32 charEnd = 2;</code></summary>
			bool HasCharEnd();

			/// <summary><code>required uint32 charEnd = 2;</code></summary>
			int GetCharEnd();

			/// <summary><code>optional string author = 3;</code></summary>
			bool HasAuthor();

			/// <summary><code>optional string author = 3;</code></summary>
			string GetAuthor();

			/// <summary><code>optional string author = 3;</code></summary>
			ByteString GetAuthorBytes();

			/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
			IList<int> GetSentenceIndexesList();

			/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
			int GetSentenceIndexesCount();

			/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
			int GetSentenceIndexes(int index);

			/// <summary><code>optional string datetime = 5;</code></summary>
			bool HasDatetime();

			/// <summary><code>optional string datetime = 5;</code></summary>
			string GetDatetime();

			/// <summary><code>optional string datetime = 5;</code></summary>
			ByteString GetDatetimeBytes();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			IList<CoreNLPProtos.Quote> GetQuotesList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			CoreNLPProtos.Quote GetQuotes(int index);

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			int GetQuotesCount();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			IList<CoreNLPProtos.IQuoteOrBuilder> GetQuotesOrBuilderList();

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			CoreNLPProtos.IQuoteOrBuilder GetQuotesOrBuilder(int index);

			/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
			bool HasAuthorCharBegin();

			/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
			int GetAuthorCharBegin();

			/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
			bool HasAuthorCharEnd();

			/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
			int GetAuthorCharEnd();

			/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
			bool HasXmlTag();

			/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
			CoreNLPProtos.Token GetXmlTag();

			/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
			CoreNLPProtos.ITokenOrBuilder GetXmlTagOrBuilder();
		}

		/// <summary>
		/// Protobuf type
		/// <c>edu.stanford.nlp.pipeline.Section</c>
		/// </summary>
		[System.Serializable]
		public sealed class Section : GeneratedMessageV3, CoreNLPProtos.ISectionOrBuilder
		{
			private Section(GeneratedMessageV3.Builder<object> builder)
				: base(builder)
			{
			}

			private Section()
			{
				// @@protoc_insertion_point(message_implements:edu.stanford.nlp.pipeline.Section)
				// Use Section.newBuilder() to construct.
				charBegin_ = 0;
				charEnd_ = 0;
				author_ = string.Empty;
				sentenceIndexes_ = Java.Util.Collections.EmptyList();
				datetime_ = string.Empty;
				quotes_ = Java.Util.Collections.EmptyList();
				authorCharBegin_ = 0;
				authorCharEnd_ = 0;
			}

			public sealed override UnknownFieldSet GetUnknownFields()
			{
				return this.unknownFields;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			private Section(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				: this()
			{
				int mutable_bitField0_ = 0;
				UnknownFieldSet.Builder unknownFields = UnknownFieldSet.NewBuilder();
				try
				{
					bool done = false;
					while (!done)
					{
						int tag = input.ReadTag();
						switch (tag)
						{
							case 0:
							{
								done = true;
								break;
							}

							default:
							{
								if (!ParseUnknownField(input, unknownFields, extensionRegistry, tag))
								{
									done = true;
								}
								break;
							}

							case 8:
							{
								bitField0_ |= unchecked((int)(0x00000001));
								charBegin_ = input.ReadUInt32();
								break;
							}

							case 16:
							{
								bitField0_ |= unchecked((int)(0x00000002));
								charEnd_ = input.ReadUInt32();
								break;
							}

							case 26:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000004));
								author_ = bs;
								break;
							}

							case 32:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
								{
									sentenceIndexes_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000008));
								}
								sentenceIndexes_.Add(input.ReadUInt32());
								break;
							}

							case 34:
							{
								int length = input.ReadRawVarint32();
								int limit = input.PushLimit(length);
								if (!((mutable_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))) && input.GetBytesUntilLimit() > 0)
								{
									sentenceIndexes_ = new List<int>();
									mutable_bitField0_ |= unchecked((int)(0x00000008));
								}
								while (input.GetBytesUntilLimit() > 0)
								{
									sentenceIndexes_.Add(input.ReadUInt32());
								}
								input.PopLimit(limit);
								break;
							}

							case 42:
							{
								ByteString bs = input.ReadBytes();
								bitField0_ |= unchecked((int)(0x00000008));
								datetime_ = bs;
								break;
							}

							case 50:
							{
								if (!((mutable_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
								{
									quotes_ = new List<CoreNLPProtos.Quote>();
									mutable_bitField0_ |= unchecked((int)(0x00000020));
								}
								quotes_.Add(input.ReadMessage(CoreNLPProtos.Quote.Parser, extensionRegistry));
								break;
							}

							case 56:
							{
								bitField0_ |= unchecked((int)(0x00000010));
								authorCharBegin_ = input.ReadUInt32();
								break;
							}

							case 64:
							{
								bitField0_ |= unchecked((int)(0x00000020));
								authorCharEnd_ = input.ReadUInt32();
								break;
							}

							case 74:
							{
								CoreNLPProtos.Token.Builder subBuilder = null;
								if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
								{
									subBuilder = ((CoreNLPProtos.Token.Builder)xmlTag_.ToBuilder());
								}
								xmlTag_ = input.ReadMessage(CoreNLPProtos.Token.Parser, extensionRegistry);
								if (subBuilder != null)
								{
									subBuilder.MergeFrom(xmlTag_);
									xmlTag_ = ((CoreNLPProtos.Token)subBuilder.BuildPartial());
								}
								bitField0_ |= unchecked((int)(0x00000040));
								break;
							}
						}
					}
				}
				catch (InvalidProtocolBufferException e)
				{
					throw e.SetUnfinishedMessage(this);
				}
				catch (IOException e)
				{
					throw new InvalidProtocolBufferException(e).SetUnfinishedMessage(this);
				}
				finally
				{
					if (((mutable_bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						sentenceIndexes_ = Java.Util.Collections.UnmodifiableList(sentenceIndexes_);
					}
					if (((mutable_bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						quotes_ = Java.Util.Collections.UnmodifiableList(quotes_);
					}
					this.unknownFields = unknownFields.Build();
					MakeExtensionsImmutable();
				}
			}

			public static Descriptors.Descriptor GetDescriptor()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Section_descriptor;
			}

			protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
			{
				return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Section_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Section), typeof(CoreNLPProtos.Section.Builder));
			}

			private int bitField0_;

			public const int CharbeginFieldNumber = 1;

			private int charBegin_;

			/// <summary><code>required uint32 charBegin = 1;</code></summary>
			public bool HasCharBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
			}

			/// <summary><code>required uint32 charBegin = 1;</code></summary>
			public int GetCharBegin()
			{
				return charBegin_;
			}

			public const int CharendFieldNumber = 2;

			private int charEnd_;

			/// <summary><code>required uint32 charEnd = 2;</code></summary>
			public bool HasCharEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
			}

			/// <summary><code>required uint32 charEnd = 2;</code></summary>
			public int GetCharEnd()
			{
				return charEnd_;
			}

			public const int AuthorFieldNumber = 3;

			private volatile object author_;

			/// <summary><code>optional string author = 3;</code></summary>
			public bool HasAuthor()
			{
				return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
			}

			/// <summary><code>optional string author = 3;</code></summary>
			public string GetAuthor()
			{
				object @ref = author_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						author_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string author = 3;</code></summary>
			public ByteString GetAuthorBytes()
			{
				object @ref = author_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					author_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int SentenceindexesFieldNumber = 4;

			private IList<int> sentenceIndexes_;

			/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
			public IList<int> GetSentenceIndexesList()
			{
				return sentenceIndexes_;
			}

			/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
			public int GetSentenceIndexesCount()
			{
				return sentenceIndexes_.Count;
			}

			/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
			public int GetSentenceIndexes(int index)
			{
				return sentenceIndexes_[index];
			}

			public const int DatetimeFieldNumber = 5;

			private volatile object datetime_;

			/// <summary><code>optional string datetime = 5;</code></summary>
			public bool HasDatetime()
			{
				return ((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008)));
			}

			/// <summary><code>optional string datetime = 5;</code></summary>
			public string GetDatetime()
			{
				object @ref = datetime_;
				if (@ref is string)
				{
					return (string)@ref;
				}
				else
				{
					ByteString bs = (ByteString)@ref;
					string s = bs.ToStringUtf8();
					if (bs.IsValidUtf8())
					{
						datetime_ = s;
					}
					return s;
				}
			}

			/// <summary><code>optional string datetime = 5;</code></summary>
			public ByteString GetDatetimeBytes()
			{
				object @ref = datetime_;
				if (@ref is string)
				{
					ByteString b = ByteString.CopyFromUtf8((string)@ref);
					datetime_ = b;
					return b;
				}
				else
				{
					return (ByteString)@ref;
				}
			}

			public const int QuotesFieldNumber = 6;

			private IList<CoreNLPProtos.Quote> quotes_;

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			public IList<CoreNLPProtos.Quote> GetQuotesList()
			{
				return quotes_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			public IList<CoreNLPProtos.IQuoteOrBuilder> GetQuotesOrBuilderList()
			{
				return quotes_;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			public int GetQuotesCount()
			{
				return quotes_.Count;
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			public CoreNLPProtos.Quote GetQuotes(int index)
			{
				return quotes_[index];
			}

			/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
			public CoreNLPProtos.IQuoteOrBuilder GetQuotesOrBuilder(int index)
			{
				return quotes_[index];
			}

			public const int AuthorcharbeginFieldNumber = 7;

			private int authorCharBegin_;

			/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
			public bool HasAuthorCharBegin()
			{
				return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
			}

			/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
			public int GetAuthorCharBegin()
			{
				return authorCharBegin_;
			}

			public const int AuthorcharendFieldNumber = 8;

			private int authorCharEnd_;

			/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
			public bool HasAuthorCharEnd()
			{
				return ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020)));
			}

			/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
			public int GetAuthorCharEnd()
			{
				return authorCharEnd_;
			}

			public const int XmltagFieldNumber = 9;

			private CoreNLPProtos.Token xmlTag_;

			/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
			public bool HasXmlTag()
			{
				return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
			public CoreNLPProtos.Token GetXmlTag()
			{
				return xmlTag_ == null ? CoreNLPProtos.Token.GetDefaultInstance() : xmlTag_;
			}

			/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
			public CoreNLPProtos.ITokenOrBuilder GetXmlTagOrBuilder()
			{
				return xmlTag_ == null ? CoreNLPProtos.Token.GetDefaultInstance() : xmlTag_;
			}

			private byte memoizedIsInitialized = unchecked((byte)(-1));

			public sealed override bool IsInitialized()
			{
				byte isInitialized = memoizedIsInitialized;
				if (isInitialized == 1)
				{
					return true;
				}
				if (isInitialized == 0)
				{
					return false;
				}
				if (!HasCharBegin())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasCharEnd())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				if (!HasXmlTag())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				for (int i = 0; i < GetQuotesCount(); i++)
				{
					if (!GetQuotes(i).IsInitialized())
					{
						memoizedIsInitialized = 0;
						return false;
					}
				}
				if (!GetXmlTag().IsInitialized())
				{
					memoizedIsInitialized = 0;
					return false;
				}
				memoizedIsInitialized = 1;
				return true;
			}

			/// <exception cref="System.IO.IOException"/>
			public override void WriteTo(CodedOutputStream output)
			{
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					output.WriteUInt32(1, charBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					output.WriteUInt32(2, charEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					GeneratedMessageV3.WriteString(output, 3, author_);
				}
				for (int i = 0; i < sentenceIndexes_.Count; i++)
				{
					output.WriteUInt32(4, sentenceIndexes_[i]);
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					GeneratedMessageV3.WriteString(output, 5, datetime_);
				}
				for (int i_1 = 0; i_1 < quotes_.Count; i_1++)
				{
					output.WriteMessage(6, quotes_[i_1]);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					output.WriteUInt32(7, authorCharBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					output.WriteUInt32(8, authorCharEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					output.WriteMessage(9, GetXmlTag());
				}
				unknownFields.WriteTo(output);
			}

			public override int GetSerializedSize()
			{
				int size = memoizedSize;
				if (size != -1)
				{
					return size;
				}
				size = 0;
				if (((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
				{
					size += CodedOutputStream.ComputeUInt32Size(1, charBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
				{
					size += CodedOutputStream.ComputeUInt32Size(2, charEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
				{
					size += GeneratedMessageV3.ComputeStringSize(3, author_);
				}
				{
					int dataSize = 0;
					for (int i = 0; i < sentenceIndexes_.Count; i++)
					{
						dataSize += CodedOutputStream.ComputeUInt32SizeNoTag(sentenceIndexes_[i]);
					}
					size += dataSize;
					size += 1 * GetSentenceIndexesList().Count;
				}
				if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
				{
					size += GeneratedMessageV3.ComputeStringSize(5, datetime_);
				}
				for (int i_1 = 0; i_1 < quotes_.Count; i_1++)
				{
					size += CodedOutputStream.ComputeMessageSize(6, quotes_[i_1]);
				}
				if (((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
				{
					size += CodedOutputStream.ComputeUInt32Size(7, authorCharBegin_);
				}
				if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
				{
					size += CodedOutputStream.ComputeUInt32Size(8, authorCharEnd_);
				}
				if (((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
				{
					size += CodedOutputStream.ComputeMessageSize(9, GetXmlTag());
				}
				size += unknownFields.GetSerializedSize();
				memoizedSize = size;
				return size;
			}

			private const long serialVersionUID = 0L;

			public override bool Equals(object obj)
			{
				if (obj == this)
				{
					return true;
				}
				if (!(obj is CoreNLPProtos.Section))
				{
					return base.Equals(obj);
				}
				CoreNLPProtos.Section other = (CoreNLPProtos.Section)obj;
				bool result = true;
				result = result && (HasCharBegin() == other.HasCharBegin());
				if (HasCharBegin())
				{
					result = result && (GetCharBegin() == other.GetCharBegin());
				}
				result = result && (HasCharEnd() == other.HasCharEnd());
				if (HasCharEnd())
				{
					result = result && (GetCharEnd() == other.GetCharEnd());
				}
				result = result && (HasAuthor() == other.HasAuthor());
				if (HasAuthor())
				{
					result = result && GetAuthor().Equals(other.GetAuthor());
				}
				result = result && GetSentenceIndexesList().Equals(other.GetSentenceIndexesList());
				result = result && (HasDatetime() == other.HasDatetime());
				if (HasDatetime())
				{
					result = result && GetDatetime().Equals(other.GetDatetime());
				}
				result = result && GetQuotesList().Equals(other.GetQuotesList());
				result = result && (HasAuthorCharBegin() == other.HasAuthorCharBegin());
				if (HasAuthorCharBegin())
				{
					result = result && (GetAuthorCharBegin() == other.GetAuthorCharBegin());
				}
				result = result && (HasAuthorCharEnd() == other.HasAuthorCharEnd());
				if (HasAuthorCharEnd())
				{
					result = result && (GetAuthorCharEnd() == other.GetAuthorCharEnd());
				}
				result = result && (HasXmlTag() == other.HasXmlTag());
				if (HasXmlTag())
				{
					result = result && GetXmlTag().Equals(other.GetXmlTag());
				}
				result = result && unknownFields.Equals(other.unknownFields);
				return result;
			}

			public override int GetHashCode()
			{
				if (memoizedHashCode != 0)
				{
					return memoizedHashCode;
				}
				int hash = 41;
				hash = (19 * hash) + GetDescriptor().GetHashCode();
				if (HasCharBegin())
				{
					hash = (37 * hash) + CharbeginFieldNumber;
					hash = (53 * hash) + GetCharBegin();
				}
				if (HasCharEnd())
				{
					hash = (37 * hash) + CharendFieldNumber;
					hash = (53 * hash) + GetCharEnd();
				}
				if (HasAuthor())
				{
					hash = (37 * hash) + AuthorFieldNumber;
					hash = (53 * hash) + GetAuthor().GetHashCode();
				}
				if (GetSentenceIndexesCount() > 0)
				{
					hash = (37 * hash) + SentenceindexesFieldNumber;
					hash = (53 * hash) + GetSentenceIndexesList().GetHashCode();
				}
				if (HasDatetime())
				{
					hash = (37 * hash) + DatetimeFieldNumber;
					hash = (53 * hash) + GetDatetime().GetHashCode();
				}
				if (GetQuotesCount() > 0)
				{
					hash = (37 * hash) + QuotesFieldNumber;
					hash = (53 * hash) + GetQuotesList().GetHashCode();
				}
				if (HasAuthorCharBegin())
				{
					hash = (37 * hash) + AuthorcharbeginFieldNumber;
					hash = (53 * hash) + GetAuthorCharBegin();
				}
				if (HasAuthorCharEnd())
				{
					hash = (37 * hash) + AuthorcharendFieldNumber;
					hash = (53 * hash) + GetAuthorCharEnd();
				}
				if (HasXmlTag())
				{
					hash = (37 * hash) + XmltagFieldNumber;
					hash = (53 * hash) + GetXmlTag().GetHashCode();
				}
				hash = (29 * hash) + unknownFields.GetHashCode();
				memoizedHashCode = hash;
				return hash;
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Section ParseFrom(ByteString data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Section ParseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Section ParseFrom(byte[] data)
			{
				return Parser.ParseFrom(data);
			}

			/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
			public static CoreNLPProtos.Section ParseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
			{
				return Parser.ParseFrom(data, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Section ParseFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Section ParseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Section ParseDelimitedFrom(InputStream input)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Section ParseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseDelimitedWithIOException(Parser, input, extensionRegistry);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Section ParseFrom(CodedInputStream input)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input);
			}

			/// <exception cref="System.IO.IOException"/>
			public static CoreNLPProtos.Section ParseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
			{
				return GeneratedMessageV3.ParseWithIOException(Parser, input, extensionRegistry);
			}

			public override MessageLite.IBuilder NewBuilderForType()
			{
				return NewBuilder();
			}

			public static CoreNLPProtos.Section.Builder NewBuilder()
			{
				return ((CoreNLPProtos.Section.Builder)DefaultInstance.ToBuilder());
			}

			public static CoreNLPProtos.Section.Builder NewBuilder(CoreNLPProtos.Section prototype)
			{
				return ((CoreNLPProtos.Section.Builder)DefaultInstance.ToBuilder()).MergeFrom(prototype);
			}

			public override MessageLite.IBuilder ToBuilder()
			{
				return this == DefaultInstance ? new CoreNLPProtos.Section.Builder() : new CoreNLPProtos.Section.Builder().MergeFrom(this);
			}

			protected override Message.IBuilder NewBuilderForType(GeneratedMessageV3.IBuilderParent parent)
			{
				CoreNLPProtos.Section.Builder builder = new CoreNLPProtos.Section.Builder(parent);
				return builder;
			}

			/// <summary>
			/// Protobuf type
			/// <c>edu.stanford.nlp.pipeline.Section</c>
			/// </summary>
			public sealed class Builder : GeneratedMessageV3.Builder<CoreNLPProtos.Section.Builder>, CoreNLPProtos.ISectionOrBuilder
			{
				// @@protoc_insertion_point(builder_implements:edu.stanford.nlp.pipeline.Section)
				public static Descriptors.Descriptor GetDescriptor()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Section_descriptor;
				}

				protected override GeneratedMessageV3.FieldAccessorTable InternalGetFieldAccessorTable()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Section_fieldAccessorTable.EnsureFieldAccessorsInitialized(typeof(CoreNLPProtos.Section), typeof(CoreNLPProtos.Section.Builder));
				}

				private Builder()
				{
					// Construct using edu.stanford.nlp.pipeline.CoreNLPProtos.Section.newBuilder()
					MaybeForceBuilderInitialization();
				}

				private Builder(GeneratedMessageV3.IBuilderParent parent)
					: base(parent)
				{
					MaybeForceBuilderInitialization();
				}

				private void MaybeForceBuilderInitialization()
				{
					if (GeneratedMessageV3.alwaysUseFieldBuilders)
					{
						GetQuotesFieldBuilder();
						GetXmlTagFieldBuilder();
					}
				}

				public override MessageLite.IBuilder Clear()
				{
					base.Clear();
					charBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					charEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					author_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					sentenceIndexes_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					datetime_ = string.Empty;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					if (quotesBuilder_ == null)
					{
						quotes_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
					}
					else
					{
						quotesBuilder_.Clear();
					}
					authorCharBegin_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					authorCharEnd_ = 0;
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					if (xmlTagBuilder_ == null)
					{
						xmlTag_ = null;
					}
					else
					{
						xmlTagBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					return this;
				}

				public override Descriptors.Descriptor GetDescriptorForType()
				{
					return CoreNLPProtos.internal_static_edu_stanford_nlp_pipeline_Section_descriptor;
				}

				public override IMessageLite GetDefaultInstanceForType()
				{
					return CoreNLPProtos.Section.GetDefaultInstance();
				}

				public override IMessageLite Build()
				{
					CoreNLPProtos.Section result = ((CoreNLPProtos.Section)BuildPartial());
					if (!result.IsInitialized())
					{
						throw NewUninitializedMessageException(result);
					}
					return result;
				}

				public override IMessageLite BuildPartial()
				{
					CoreNLPProtos.Section result = new CoreNLPProtos.Section(this);
					int from_bitField0_ = bitField0_;
					int to_bitField0_ = 0;
					if (((from_bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001))))
					{
						to_bitField0_ |= unchecked((int)(0x00000001));
					}
					result.charBegin_ = charBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002))))
					{
						to_bitField0_ |= unchecked((int)(0x00000002));
					}
					result.charEnd_ = charEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004))))
					{
						to_bitField0_ |= unchecked((int)(0x00000004));
					}
					result.author_ = author_;
					if (((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						sentenceIndexes_ = Java.Util.Collections.UnmodifiableList(sentenceIndexes_);
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					}
					result.sentenceIndexes_ = sentenceIndexes_;
					if (((from_bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010))))
					{
						to_bitField0_ |= unchecked((int)(0x00000008));
					}
					result.datetime_ = datetime_;
					if (quotesBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
						{
							quotes_ = Java.Util.Collections.UnmodifiableList(quotes_);
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						}
						result.quotes_ = quotes_;
					}
					else
					{
						result.quotes_ = quotesBuilder_.Build();
					}
					if (((from_bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040))))
					{
						to_bitField0_ |= unchecked((int)(0x00000010));
					}
					result.authorCharBegin_ = authorCharBegin_;
					if (((from_bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080))))
					{
						to_bitField0_ |= unchecked((int)(0x00000020));
					}
					result.authorCharEnd_ = authorCharEnd_;
					if (((from_bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))))
					{
						to_bitField0_ |= unchecked((int)(0x00000040));
					}
					if (xmlTagBuilder_ == null)
					{
						result.xmlTag_ = xmlTag_;
					}
					else
					{
						result.xmlTag_ = xmlTagBuilder_.Build();
					}
					result.bitField0_ = to_bitField0_;
					OnBuilt();
					return result;
				}

				public override AbstractMessageLite.Builder Clone()
				{
					return (CoreNLPProtos.Section.Builder)base.Clone();
				}

				public override Message.IBuilder SetField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Section.Builder)base.SetField(field, value);
				}

				public override Message.IBuilder ClearField(Descriptors.FieldDescriptor field)
				{
					return (CoreNLPProtos.Section.Builder)base.ClearField(field);
				}

				public override CoreNLPProtos.Section.Builder ClearOneof(Descriptors.OneofDescriptor oneof)
				{
					return (CoreNLPProtos.Section.Builder)base.ClearOneof(oneof);
				}

				public override Message.IBuilder SetRepeatedField(Descriptors.FieldDescriptor field, int index, object value)
				{
					return (CoreNLPProtos.Section.Builder)base.SetRepeatedField(field, index, value);
				}

				public override Message.IBuilder AddRepeatedField(Descriptors.FieldDescriptor field, object value)
				{
					return (CoreNLPProtos.Section.Builder)base.AddRepeatedField(field, value);
				}

				public override CoreNLPProtos.Section.Builder MergeFrom(IMessage other)
				{
					if (other is CoreNLPProtos.Section)
					{
						return MergeFrom((CoreNLPProtos.Section)other);
					}
					else
					{
						base.MergeFrom(other);
						return this;
					}
				}

				public CoreNLPProtos.Section.Builder MergeFrom(CoreNLPProtos.Section other)
				{
					if (other == CoreNLPProtos.Section.GetDefaultInstance())
					{
						return this;
					}
					if (other.HasCharBegin())
					{
						SetCharBegin(other.GetCharBegin());
					}
					if (other.HasCharEnd())
					{
						SetCharEnd(other.GetCharEnd());
					}
					if (other.HasAuthor())
					{
						bitField0_ |= unchecked((int)(0x00000004));
						author_ = other.author_;
						OnChanged();
					}
					if (!other.sentenceIndexes_.IsEmpty())
					{
						if (sentenceIndexes_.IsEmpty())
						{
							sentenceIndexes_ = other.sentenceIndexes_;
							bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
						}
						else
						{
							EnsureSentenceIndexesIsMutable();
							Sharpen.Collections.AddAll(sentenceIndexes_, other.sentenceIndexes_);
						}
						OnChanged();
					}
					if (other.HasDatetime())
					{
						bitField0_ |= unchecked((int)(0x00000010));
						datetime_ = other.datetime_;
						OnChanged();
					}
					if (quotesBuilder_ == null)
					{
						if (!other.quotes_.IsEmpty())
						{
							if (quotes_.IsEmpty())
							{
								quotes_ = other.quotes_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
							}
							else
							{
								EnsureQuotesIsMutable();
								Sharpen.Collections.AddAll(quotes_, other.quotes_);
							}
							OnChanged();
						}
					}
					else
					{
						if (!other.quotes_.IsEmpty())
						{
							if (quotesBuilder_.IsEmpty())
							{
								quotesBuilder_.Dispose();
								quotesBuilder_ = null;
								quotes_ = other.quotes_;
								bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
								quotesBuilder_ = GeneratedMessageV3.alwaysUseFieldBuilders ? GetQuotesFieldBuilder() : null;
							}
							else
							{
								quotesBuilder_.AddAllMessages(other.quotes_);
							}
						}
					}
					if (other.HasAuthorCharBegin())
					{
						SetAuthorCharBegin(other.GetAuthorCharBegin());
					}
					if (other.HasAuthorCharEnd())
					{
						SetAuthorCharEnd(other.GetAuthorCharEnd());
					}
					if (other.HasXmlTag())
					{
						MergeXmlTag(other.GetXmlTag());
					}
					this.MergeUnknownFields(other.unknownFields);
					OnChanged();
					return this;
				}

				public sealed override bool IsInitialized()
				{
					if (!HasCharBegin())
					{
						return false;
					}
					if (!HasCharEnd())
					{
						return false;
					}
					if (!HasXmlTag())
					{
						return false;
					}
					for (int i = 0; i < GetQuotesCount(); i++)
					{
						if (!GetQuotes(i).IsInitialized())
						{
							return false;
						}
					}
					if (!GetXmlTag().IsInitialized())
					{
						return false;
					}
					return true;
				}

				/// <exception cref="System.IO.IOException"/>
				public override AbstractMessageLite.Builder MergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					CoreNLPProtos.Section parsedMessage = null;
					try
					{
						parsedMessage = Parser.ParsePartialFrom(input, extensionRegistry);
					}
					catch (InvalidProtocolBufferException e)
					{
						parsedMessage = (CoreNLPProtos.Section)e.GetUnfinishedMessage();
						throw e.UnwrapIOException();
					}
					finally
					{
						if (parsedMessage != null)
						{
							MergeFrom(parsedMessage);
						}
					}
					return this;
				}

				private int bitField0_;

				private int charBegin_;

				/// <summary><code>required uint32 charBegin = 1;</code></summary>
				public bool HasCharBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000001))) == unchecked((int)(0x00000001)));
				}

				/// <summary><code>required uint32 charBegin = 1;</code></summary>
				public int GetCharBegin()
				{
					return charBegin_;
				}

				/// <summary><code>required uint32 charBegin = 1;</code></summary>
				public CoreNLPProtos.Section.Builder SetCharBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000001));
					charBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 charBegin = 1;</code></summary>
				public CoreNLPProtos.Section.Builder ClearCharBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000001)));
					charBegin_ = 0;
					OnChanged();
					return this;
				}

				private int charEnd_;

				/// <summary><code>required uint32 charEnd = 2;</code></summary>
				public bool HasCharEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000002))) == unchecked((int)(0x00000002)));
				}

				/// <summary><code>required uint32 charEnd = 2;</code></summary>
				public int GetCharEnd()
				{
					return charEnd_;
				}

				/// <summary><code>required uint32 charEnd = 2;</code></summary>
				public CoreNLPProtos.Section.Builder SetCharEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000002));
					charEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>required uint32 charEnd = 2;</code></summary>
				public CoreNLPProtos.Section.Builder ClearCharEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000002)));
					charEnd_ = 0;
					OnChanged();
					return this;
				}

				private object author_ = string.Empty;

				/// <summary><code>optional string author = 3;</code></summary>
				public bool HasAuthor()
				{
					return ((bitField0_ & unchecked((int)(0x00000004))) == unchecked((int)(0x00000004)));
				}

				/// <summary><code>optional string author = 3;</code></summary>
				public string GetAuthor()
				{
					object @ref = author_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							author_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string author = 3;</code></summary>
				public ByteString GetAuthorBytes()
				{
					object @ref = author_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						author_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string author = 3;</code></summary>
				public CoreNLPProtos.Section.Builder SetAuthor(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					author_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string author = 3;</code></summary>
				public CoreNLPProtos.Section.Builder ClearAuthor()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000004)));
					author_ = GetDefaultInstance().GetAuthor();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string author = 3;</code></summary>
				public CoreNLPProtos.Section.Builder SetAuthorBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000004));
					author_ = value;
					OnChanged();
					return this;
				}

				private IList<int> sentenceIndexes_ = Java.Util.Collections.EmptyList();

				private void EnsureSentenceIndexesIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000008))) == unchecked((int)(0x00000008))))
					{
						sentenceIndexes_ = new List<int>(sentenceIndexes_);
						bitField0_ |= unchecked((int)(0x00000008));
					}
				}

				/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
				public IList<int> GetSentenceIndexesList()
				{
					return Java.Util.Collections.UnmodifiableList(sentenceIndexes_);
				}

				/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
				public int GetSentenceIndexesCount()
				{
					return sentenceIndexes_.Count;
				}

				/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
				public int GetSentenceIndexes(int index)
				{
					return sentenceIndexes_[index];
				}

				/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
				public CoreNLPProtos.Section.Builder SetSentenceIndexes(int index, int value)
				{
					EnsureSentenceIndexesIsMutable();
					sentenceIndexes_.Set(index, value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
				public CoreNLPProtos.Section.Builder AddSentenceIndexes(int value)
				{
					EnsureSentenceIndexesIsMutable();
					sentenceIndexes_.Add(value);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
				public CoreNLPProtos.Section.Builder AddAllSentenceIndexes<_T0>(IEnumerable<_T0> values)
					where _T0 : int
				{
					EnsureSentenceIndexesIsMutable();
					AbstractMessageLite.Builder.AddAll(values, sentenceIndexes_);
					OnChanged();
					return this;
				}

				/// <summary><code>repeated uint32 sentenceIndexes = 4;</code></summary>
				public CoreNLPProtos.Section.Builder ClearSentenceIndexes()
				{
					sentenceIndexes_ = Java.Util.Collections.EmptyList();
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000008)));
					OnChanged();
					return this;
				}

				private object datetime_ = string.Empty;

				/// <summary><code>optional string datetime = 5;</code></summary>
				public bool HasDatetime()
				{
					return ((bitField0_ & unchecked((int)(0x00000010))) == unchecked((int)(0x00000010)));
				}

				/// <summary><code>optional string datetime = 5;</code></summary>
				public string GetDatetime()
				{
					object @ref = datetime_;
					if (!(@ref is string))
					{
						ByteString bs = (ByteString)@ref;
						string s = bs.ToStringUtf8();
						if (bs.IsValidUtf8())
						{
							datetime_ = s;
						}
						return s;
					}
					else
					{
						return (string)@ref;
					}
				}

				/// <summary><code>optional string datetime = 5;</code></summary>
				public ByteString GetDatetimeBytes()
				{
					object @ref = datetime_;
					if (@ref is string)
					{
						ByteString b = ByteString.CopyFromUtf8((string)@ref);
						datetime_ = b;
						return b;
					}
					else
					{
						return (ByteString)@ref;
					}
				}

				/// <summary><code>optional string datetime = 5;</code></summary>
				public CoreNLPProtos.Section.Builder SetDatetime(string value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					datetime_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional string datetime = 5;</code></summary>
				public CoreNLPProtos.Section.Builder ClearDatetime()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000010)));
					datetime_ = GetDefaultInstance().GetDatetime();
					OnChanged();
					return this;
				}

				/// <summary><code>optional string datetime = 5;</code></summary>
				public CoreNLPProtos.Section.Builder SetDatetimeBytes(ByteString value)
				{
					if (value == null)
					{
						throw new ArgumentNullException();
					}
					bitField0_ |= unchecked((int)(0x00000010));
					datetime_ = value;
					OnChanged();
					return this;
				}

				private IList<CoreNLPProtos.Quote> quotes_ = Java.Util.Collections.EmptyList();

				private void EnsureQuotesIsMutable()
				{
					if (!((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))))
					{
						quotes_ = new List<CoreNLPProtos.Quote>(quotes_);
						bitField0_ |= unchecked((int)(0x00000020));
					}
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Quote, CoreNLPProtos.Quote.Builder, CoreNLPProtos.IQuoteOrBuilder> quotesBuilder_;

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public IList<CoreNLPProtos.Quote> GetQuotesList()
				{
					if (quotesBuilder_ == null)
					{
						return Java.Util.Collections.UnmodifiableList(quotes_);
					}
					else
					{
						return quotesBuilder_.GetMessageList();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public int GetQuotesCount()
				{
					if (quotesBuilder_ == null)
					{
						return quotes_.Count;
					}
					else
					{
						return quotesBuilder_.GetCount();
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Quote GetQuotes(int index)
				{
					if (quotesBuilder_ == null)
					{
						return quotes_[index];
					}
					else
					{
						return quotesBuilder_.GetMessage(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder SetQuotes(int index, CoreNLPProtos.Quote value)
				{
					if (quotesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureQuotesIsMutable();
						quotes_.Set(index, value);
						OnChanged();
					}
					else
					{
						quotesBuilder_.SetMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder SetQuotes(int index, CoreNLPProtos.Quote.Builder builderForValue)
				{
					if (quotesBuilder_ == null)
					{
						EnsureQuotesIsMutable();
						quotes_.Set(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						quotesBuilder_.SetMessage(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder AddQuotes(CoreNLPProtos.Quote value)
				{
					if (quotesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureQuotesIsMutable();
						quotes_.Add(value);
						OnChanged();
					}
					else
					{
						quotesBuilder_.AddMessage(value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder AddQuotes(int index, CoreNLPProtos.Quote value)
				{
					if (quotesBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						EnsureQuotesIsMutable();
						quotes_.Add(index, value);
						OnChanged();
					}
					else
					{
						quotesBuilder_.AddMessage(index, value);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder AddQuotes(CoreNLPProtos.Quote.Builder builderForValue)
				{
					if (quotesBuilder_ == null)
					{
						EnsureQuotesIsMutable();
						quotes_.Add(((CoreNLPProtos.Quote)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						quotesBuilder_.AddMessage(((CoreNLPProtos.Quote)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder AddQuotes(int index, CoreNLPProtos.Quote.Builder builderForValue)
				{
					if (quotesBuilder_ == null)
					{
						EnsureQuotesIsMutable();
						quotes_.Add(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
						OnChanged();
					}
					else
					{
						quotesBuilder_.AddMessage(index, ((CoreNLPProtos.Quote)builderForValue.Build()));
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder AddAllQuotes<_T0>(IEnumerable<_T0> values)
					where _T0 : CoreNLPProtos.Quote
				{
					if (quotesBuilder_ == null)
					{
						EnsureQuotesIsMutable();
						AbstractMessageLite.Builder.AddAll(values, quotes_);
						OnChanged();
					}
					else
					{
						quotesBuilder_.AddAllMessages(values);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder ClearQuotes()
				{
					if (quotesBuilder_ == null)
					{
						quotes_ = Java.Util.Collections.EmptyList();
						bitField0_ = (bitField0_ & ~unchecked((int)(0x00000020)));
						OnChanged();
					}
					else
					{
						quotesBuilder_.Clear();
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Section.Builder RemoveQuotes(int index)
				{
					if (quotesBuilder_ == null)
					{
						EnsureQuotesIsMutable();
						quotes_.Remove(index);
						OnChanged();
					}
					else
					{
						quotesBuilder_.Remove(index);
					}
					return this;
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder GetQuotesBuilder(int index)
				{
					return GetQuotesFieldBuilder().GetBuilder(index);
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.IQuoteOrBuilder GetQuotesOrBuilder(int index)
				{
					if (quotesBuilder_ == null)
					{
						return quotes_[index];
					}
					else
					{
						return quotesBuilder_.GetMessageOrBuilder(index);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public IList<CoreNLPProtos.IQuoteOrBuilder> GetQuotesOrBuilderList()
				{
					if (quotesBuilder_ != null)
					{
						return quotesBuilder_.GetMessageOrBuilderList();
					}
					else
					{
						return Java.Util.Collections.UnmodifiableList(quotes_);
					}
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder AddQuotesBuilder()
				{
					return GetQuotesFieldBuilder().AddBuilder(CoreNLPProtos.Quote.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public CoreNLPProtos.Quote.Builder AddQuotesBuilder(int index)
				{
					return GetQuotesFieldBuilder().AddBuilder(index, CoreNLPProtos.Quote.GetDefaultInstance());
				}

				/// <summary><code>repeated .edu.stanford.nlp.pipeline.Quote quotes = 6;</code></summary>
				public IList<CoreNLPProtos.Quote.Builder> GetQuotesBuilderList()
				{
					return GetQuotesFieldBuilder().GetBuilderList();
				}

				private RepeatedFieldBuilderV3<CoreNLPProtos.Quote, CoreNLPProtos.Quote.Builder, CoreNLPProtos.IQuoteOrBuilder> GetQuotesFieldBuilder()
				{
					if (quotesBuilder_ == null)
					{
						quotesBuilder_ = new RepeatedFieldBuilderV3<CoreNLPProtos.Quote, CoreNLPProtos.Quote.Builder, CoreNLPProtos.IQuoteOrBuilder>(quotes_, ((bitField0_ & unchecked((int)(0x00000020))) == unchecked((int)(0x00000020))), GetParentForChildren(), IsClean
							());
						quotes_ = null;
					}
					return quotesBuilder_;
				}

				private int authorCharBegin_;

				/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
				public bool HasAuthorCharBegin()
				{
					return ((bitField0_ & unchecked((int)(0x00000040))) == unchecked((int)(0x00000040)));
				}

				/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
				public int GetAuthorCharBegin()
				{
					return authorCharBegin_;
				}

				/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
				public CoreNLPProtos.Section.Builder SetAuthorCharBegin(int value)
				{
					bitField0_ |= unchecked((int)(0x00000040));
					authorCharBegin_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 authorCharBegin = 7;</code></summary>
				public CoreNLPProtos.Section.Builder ClearAuthorCharBegin()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000040)));
					authorCharBegin_ = 0;
					OnChanged();
					return this;
				}

				private int authorCharEnd_;

				/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
				public bool HasAuthorCharEnd()
				{
					return ((bitField0_ & unchecked((int)(0x00000080))) == unchecked((int)(0x00000080)));
				}

				/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
				public int GetAuthorCharEnd()
				{
					return authorCharEnd_;
				}

				/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
				public CoreNLPProtos.Section.Builder SetAuthorCharEnd(int value)
				{
					bitField0_ |= unchecked((int)(0x00000080));
					authorCharEnd_ = value;
					OnChanged();
					return this;
				}

				/// <summary><code>optional uint32 authorCharEnd = 8;</code></summary>
				public CoreNLPProtos.Section.Builder ClearAuthorCharEnd()
				{
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000080)));
					authorCharEnd_ = 0;
					OnChanged();
					return this;
				}

				private CoreNLPProtos.Token xmlTag_ = null;

				private SingleFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> xmlTagBuilder_;

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public bool HasXmlTag()
				{
					return ((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100)));
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public CoreNLPProtos.Token GetXmlTag()
				{
					if (xmlTagBuilder_ == null)
					{
						return xmlTag_ == null ? CoreNLPProtos.Token.GetDefaultInstance() : xmlTag_;
					}
					else
					{
						return xmlTagBuilder_.GetMessage();
					}
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public CoreNLPProtos.Section.Builder SetXmlTag(CoreNLPProtos.Token value)
				{
					if (xmlTagBuilder_ == null)
					{
						if (value == null)
						{
							throw new ArgumentNullException();
						}
						xmlTag_ = value;
						OnChanged();
					}
					else
					{
						xmlTagBuilder_.SetMessage(value);
					}
					bitField0_ |= unchecked((int)(0x00000100));
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public CoreNLPProtos.Section.Builder SetXmlTag(CoreNLPProtos.Token.Builder builderForValue)
				{
					if (xmlTagBuilder_ == null)
					{
						xmlTag_ = ((CoreNLPProtos.Token)builderForValue.Build());
						OnChanged();
					}
					else
					{
						xmlTagBuilder_.SetMessage(((CoreNLPProtos.Token)builderForValue.Build()));
					}
					bitField0_ |= unchecked((int)(0x00000100));
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public CoreNLPProtos.Section.Builder MergeXmlTag(CoreNLPProtos.Token value)
				{
					if (xmlTagBuilder_ == null)
					{
						if (((bitField0_ & unchecked((int)(0x00000100))) == unchecked((int)(0x00000100))) && xmlTag_ != null && xmlTag_ != CoreNLPProtos.Token.GetDefaultInstance())
						{
							xmlTag_ = ((CoreNLPProtos.Token)CoreNLPProtos.Token.NewBuilder(xmlTag_).MergeFrom(value).BuildPartial());
						}
						else
						{
							xmlTag_ = value;
						}
						OnChanged();
					}
					else
					{
						xmlTagBuilder_.MergeFrom(value);
					}
					bitField0_ |= unchecked((int)(0x00000100));
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public CoreNLPProtos.Section.Builder ClearXmlTag()
				{
					if (xmlTagBuilder_ == null)
					{
						xmlTag_ = null;
						OnChanged();
					}
					else
					{
						xmlTagBuilder_.Clear();
					}
					bitField0_ = (bitField0_ & ~unchecked((int)(0x00000100)));
					return this;
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public CoreNLPProtos.Token.Builder GetXmlTagBuilder()
				{
					bitField0_ |= unchecked((int)(0x00000100));
					OnChanged();
					return GetXmlTagFieldBuilder().GetBuilder();
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				public CoreNLPProtos.ITokenOrBuilder GetXmlTagOrBuilder()
				{
					if (xmlTagBuilder_ != null)
					{
						return xmlTagBuilder_.GetMessageOrBuilder();
					}
					else
					{
						return xmlTag_ == null ? CoreNLPProtos.Token.GetDefaultInstance() : xmlTag_;
					}
				}

				/// <summary><code>required .edu.stanford.nlp.pipeline.Token xmlTag = 9;</code></summary>
				private SingleFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder> GetXmlTagFieldBuilder()
				{
					if (xmlTagBuilder_ == null)
					{
						xmlTagBuilder_ = new SingleFieldBuilderV3<CoreNLPProtos.Token, CoreNLPProtos.Token.Builder, CoreNLPProtos.ITokenOrBuilder>(GetXmlTag(), GetParentForChildren(), IsClean());
						xmlTag_ = null;
					}
					return xmlTagBuilder_;
				}

				public sealed override Message.IBuilder SetUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.SetUnknownFields(unknownFields);
				}

				public sealed override CoreNLPProtos.Section.Builder MergeUnknownFields(UnknownFieldSet unknownFields)
				{
					return base.MergeUnknownFields(unknownFields);
				}
				// @@protoc_insertion_point(builder_scope:edu.stanford.nlp.pipeline.Section)
			}

			private static readonly CoreNLPProtos.Section DefaultInstance;

			static Section()
			{
				// @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Section)
				DefaultInstance = new CoreNLPProtos.Section();
			}

			public static CoreNLPProtos.Section GetDefaultInstance()
			{
				return DefaultInstance;
			}

			private sealed class _AbstractParser_61251 : AbstractParser<CoreNLPProtos.Section>
			{
				public _AbstractParser_61251()
				{
				}

				/// <exception cref="Com.Google.Protobuf.InvalidProtocolBufferException"/>
				public override CoreNLPProtos.Section ParsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
				{
					return new CoreNLPProtos.Section(input, extensionRegistry);
				}
			}

			[Obsolete]
			public static readonly IParser<CoreNLPProtos.Section> Parser = new _AbstractParser_61251();

			public static IParser<CoreNLPProtos.Section> Parser()
			{
				return Parser;
			}

			public override IParser<IMessageLite> GetParserForType()
			{
				return Parser;
			}

			public override IMessageLite GetDefaultInstanceForType()
			{
				return DefaultInstance;
			}
		}

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Document_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Document_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Sentence_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Sentence_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Token_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Token_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Quote_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Quote_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_ParseTree_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_ParseTree_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_DependencyGraph_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_CorefChain_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_CorefChain_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Mention_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Mention_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_IndexedWord_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_IndexedWord_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Span_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Span_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Timex_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Timex_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Entity_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Entity_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Relation_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Relation_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Operator_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Operator_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Polarity_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Polarity_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_NERMention_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_NERMention_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_SentenceFragment_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_SentenceFragment_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_TokenLocation_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_TokenLocation_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_RelationTriple_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_RelationTriple_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_MapStringString_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_MapStringString_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_MapIntString_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_MapIntString_fieldAccessorTable;

		private static readonly Descriptors.Descriptor internal_static_edu_stanford_nlp_pipeline_Section_descriptor;

		private static readonly GeneratedMessageV3.FieldAccessorTable internal_static_edu_stanford_nlp_pipeline_Section_fieldAccessorTable;

		public static Descriptors.FileDescriptor GetDescriptor()
		{
			return descriptor;
		}

		private static Descriptors.FileDescriptor descriptor;

		static CoreNLPProtos()
		{
			string[] descriptorData = new string[] { "\n\rCoreNLP.proto\x16\x1fedu.stanford.nlp.pipeli" + "ne\"\x155\x5\n\xaDocument\x16\xe\n\x4text\x1e\x1 \x2(\t\xe1\n\xasentenc" + "e\x1e\x2 \x3(\x84#.edu.stanford.nlp.pipeline.Sent" + "ence\xe5\n\ncorefChain\x1e\x3 \x3(\x84%.edu.stanford."
				 + "nlp.pipeline.CorefChain\x16\r\n\x5docID\x1e\x4 \x1(\t\x16\x11" + "\n\x7docDate\x1e\x7 \x1(\t\x16\x14\n\xacalendar\x1e\xa \x1(\x4\x16;\n\x15sen" + "tencelessToken\x1e\x5 \x3(\x84 .edu.stanford.nlp." + "pipeline.Token\xdf\n\tcharacter\x1e\n \x3(\x84 .edu."
				 + "stanford.nlp.pipeline.Token\x16/\n\x5quote\x1e\x6 \x3" + "(\x84 .edu.stanford.nlp.pipeline.Quote\xe3\n\xa", "mentions\x1e\t \x3(\x84%.edu.stanford.nlp.pipeli" + "ne.NERMention\x16#\n\x21hasEntityMentionsAnnota" + "tion\x1e\r \x1(\xa\x16\x10\n\x6xmlDoc\x1e\xd \x1(\xa\xe0\n\xasections\x1e\xe"
				 + " \x3(\x84\".edu.stanford.nlp.pipeline.Section" + "\x16<\n\x14mentionsForCoref\x1e\x10 \x3(\x84\".edu.stanfor" + "d.nlp.pipeline.Mention\x16!\n\x1fhasCorefMentio" + "nAnnotation\x1e\x11 \x1(\xa\x16\x20\n\x16hasCorefAnnotation\x1e" + "\x14 \x1(\xa\x16+\n#corefMentionToEntityMentionMapp"
				 + "ings\x1e\x15 \x3(\r\x16+\n#entityMentionToCorefMentio" + "nMappings\x1e\x16 \x3(\r*\x5\xad\x14\xc8\x2\"\xd8\x11\n\xaSentence\x16/\n\x5t", "oken\x1e\x1 \x3(\x84 .edu.stanford.nlp.pipeline.T" + "oken\x16\x1e\n\x14tokenOffsetBegin\x1e\x2 \x2(\r\x16\x1a\n\x10tokenO"
				 + "ffsetEnd\x1e\x3 \x2(\r\x16\x19\n\rsentenceIndex\x1e\x4 \x1(\r\x16\x22\n" + "\x18characterOffsetBegin\x1e\x5 \x1(\r\x16\x20\n\x16character" + "OffsetEnd\x1e\x6 \x1(\r\xe3\n\tparseTree\x1e\x7 \x1(\x84$.edu" + ".stanford.nlp.pipeline.ParseTree\x16@\n\x16bina"
				 + "rizedParseTree\x1e\x25 \x1(\x84$.edu.stanford.nlp." + "pipeline.ParseTree\x16@\n\x16annotatedParseTree" + "\x1e  \x1(\x84$.edu.stanford.nlp.pipeline.Parse" + "Tree\x16\x15\n\tsentiment\x1e! \x1(\t\x16=\n\x11kBestParseTre", "es\x1e\" \x3(\x84$.edu.stanford.nlp.pipeline.Par"
				 + "seTree\x16E\n\x15basicDependencies\x1e\xa \x1(\x84*.edu." + "stanford.nlp.pipeline.DependencyGraph\x16I\n" + "\x19collapsedDependencies\x1e\t \x1(\x84*.edu.stanf" + "ord.nlp.pipeline.DependencyGraph\x16T\n coll" + "apsedCCProcessedDependencies\x1e\n \x1(\x84*.edu"
				 + ".stanford.nlp.pipeline.DependencyGraph\x16K" + "\n\x1balternativeDependencies\x1e\r \x1(\x84*.edu.st" + "anford.nlp.pipeline.DependencyGraph\x16?\n\xeo" + "penieTriple\x1e\x10 \x3(\x84).edu.stanford.nlp.pip", "eline.RelationTriple\x16<\n\tkbpTriple\x1e\x14 \x3(\x84"
				 + ").edu.stanford.nlp.pipeline.RelationTrip" + "le\x16E\n\x14entailedSentence\x1e\x11 \x3(\x84+.edu.stanf" + "ord.nlp.pipeline.SentenceFragment\x16C\n\x10ent" + "ailedClause\x1e# \x3(\x84+.edu.stanford.nlp.pip" + "eline.SentenceFragment\x16H\n\x18enhancedDepend"
				 + "encies\x1e\x15 \x1(\x84*.edu.stanford.nlp.pipeline" + ".DependencyGraph\x16P\n\x22enhancedPlusPlusDepe" + "ndencies\x1e\x16 \x1(\x84*.edu.stanford.nlp.pipeli" + "ne.DependencyGraph\xdf\n\tcharacter\x1e\x17 \x3(\x84 .", "edu.stanford.nlp.pipeline.Token\x16\x15\n\tparag"
				 + "raph\x1e\xd \x1(\r\x16\xe\n\x4text\x1e\xe \x1(\t\x16\x16\n\nlineNumber\x1e\x18" + " \x1(\r\x16\x24\n\x1ahasRelationAnnotations\x12f \x1(\xa\xdd\n\x6" + "entity\x130 \x3(\x84!.edu.stanford.nlp.pipeline" + ".Entity\xe1\n\xarelation\x131 \x3(\x84#.edu.stanford"
				 + ".nlp.pipeline.Relation\x16$\n\x22hasNumerizedTo" + "kensAnnotation\x132 \x1(\xa\xe3\n\xamentions\x133 \x3(\x84%" + ".edu.stanford.nlp.pipeline.NERMention\x16<\n" + "\x14mentionsForCoref\x134 \x3(\x84\".edu.stanford.n" + "lp.pipeline.Mention\x16\"\n\x20hasCorefMentionsA"
				, "nnotation\x135 \x1(\xa\x16\x16\n\nsentenceID\x1e: \x1(\t\x16\x17\n\xds" + "ectionDate\x1e; \x1(\t\x16\x18\n\xesectionIndex\x1e< \x1(\r\x16\x17" + "\n\xdsectionName\x1e= \x1(\t\x16\x19\n\rsectionAuthor\x1e> \x1" + "(\t\x16\r\n\x5docID\x1e? \x1(\t\x16\x19\n\rsectionQuoted\x1e@ \x1(\xa"
				 + "\x16#\n\x21hasEntityMentionsAnnotation\x1eA \x1(\xa\x16\x25\n" + "\x1bhasKBPTriplesAnnotation\x1eD \x1(\xa\x16\"\n\x20hasOpe" + "nieTriplesAnnotation\x1eE \x1(\xa\x16\x18\n\xechapterInd" + "ex\x1eB \x1(\r\x16\x1a\n\x10paragraphIndex\x1eC \x1(\r*\x5\xad\x14\xc8\x2\""
				 + "\xff\n\n\x5Token\x16\xe\n\x4word\x1e\x1 \x1(\t\x16\xd\n\x3pos\x1e\x2 \x1(\t\x16\r\n\x5" + "value\x1e\x3 \x1(\t\x16\x14\n\xacategory\x1e\x4 \x1(\t\x16\x10\n\x6before\x1e", "\x5 \x1(\t\x16\r\n\x5after\x1e\x6 \x1(\t\x16\x18\n\xeoriginalText\x1e\x7 \x1"
				 + "(\t\x16\xd\n\x3ner\x1e\xa \x1(\t\x16\x15\n\tcoarseNER\x1e> \x1(\t\x16\x1a\n\x10fi" + "neGrainedNER\x1e? \x1(\t\x16\x19\n\rnormalizedNER\x1e\t \x1(" + "\t\x16\r\n\x5lemma\x1e\n \x1(\t\x16\x15\n\tbeginChar\x1e\xd \x1(\r\x16\x11\n\x7e" + "ndChar\x1e\xe \x1(\r\x16\x15\n\tutterance\x1e\r \x1(\r\x16\x11\n\x7speak"
				 + "er\x1e\x10 \x1(\t\x16\x16\n\nbeginIndex\x1e\x11 \x1(\r\x16\x14\n\xaendIndex" + "\x1e\x14 \x1(\r\x16\x1b\n\x11tokenBeginIndex\x1e\x15 \x1(\r\x16\x19\n\rtoken" + "EndIndex\x1e\x16 \x1(\r\xe0\n\ntimexValue\x1e\x17 \x1(\x84 .edu" + ".stanford.nlp.pipeline.Timex\x16\x19\n\rhasXmlCo"
				 + "ntext\x1e\x19 \x1(\xa\x16\x16\n\nxmlContext\x1e\x1a \x3(\t\x16\x1a\n\x10coref", "ClusterID\x1e\x1b \x1(\r\x16\x10\n\x6answer\x1e\x1e \x1(\t\x16\x19\n\rheadW" + "ordIndex\x1e\x20 \x1(\r\xe1\n\xaoperator\x1e\x21 \x1(\x84#.edu.s" + "tanford.nlp.pipeline.Operator\xe1\n\xapolarit"
				 + "y\x1e\x22 \x1(\x84#.edu.stanford.nlp.pipeline.Pola" + "rity\x16\x18\n\xepolarity_dir\x1e\' \x1(\t\x16-\n\x4span\x1e\x23 \x1(\xd" + "2\x25.edu.stanford.nlp.pipeline.Span\x16\x15\n\tsen" + "timent\x1e\x24 \x1(\t\x16\x1a\n\x10quotationIndex\x1e\x25 \x1(\x5\x16B\n\x10"
				 + "conllUFeatures\x1e  \x1(\x84*.edu.stanford.nlp." + "pipeline.MapStringString\x16\x15\n\tcoarseTag\x1e! " + "\x1(\t\xe4\n\x11conllUTokenSpan\x1e\" \x1(\x84\x25.edu.stanf", "ord.nlp.pipeline.Span\x16\x16\n\nconllUMisc\x1e# \x1(" + "\t\x16G\n\x17conllUSecondaryDeps\x1e$ \x1(\x84*.edu.sta"
				 + "nford.nlp.pipeline.MapStringString\x16\x1b\n\x11wi" + "kipediaEntity\x1e% \x1(\t\x16\x15\n\tisNewline\x1e& \x1(\xa\x16\x10" + "\n\x6gender\x12f \x1(\t\x16\x14\n\xatrueCase\x130 \x1(\t\x16\x18\n\xetrue" + "CaseText\x131 \x1(\t\x16\x17\n\xdchineseChar\x132 \x1(\t\x16\x16\n\nc"
				 + "hineseSeg\x133 \x1(\t\x16\x1a\n\x10chineseXMLChar\x1e< \x1(\t\x16" + "\x17\n\xdsectionName\x134 \x1(\t\x16\x19\n\rsectionAuthor\x135 " + "\x1(\t\x16\x17\n\xdsectionDate\x1e: \x1(\t\x16\x1b\n\x11sectionEndLa" + "bel\x1e; \x1(\t\x16\x10\n\x6parent\x1e= \x1(\t\x16\x1f\n\x15corefMentio"
				, "nIndex\x1e@ \x3(\r\x16\x20\n\x16entityMentionIndex\x1eA \x1(\r" + "*\x5\xad\x14\xc8\x2\"\x158\x3\n\x5Quote\x16\xe\n\x4text\x1e\x1 \x1(\t\x16\r\n\x5begin" + "\x1e\x2 \x1(\r\x16\xd\n\x3end\x1e\x3 \x1(\r\x16\x19\n\rsentenceBegin\x1e\x5 \x1"
				 + "(\r\x16\x17\n\xdsentenceEnd\x1e\x6 \x1(\r\x16\x16\n\ntokenBegin\x1e\x7 " + "\x1(\r\x16\x14\n\xatokenEnd\x1e\xa \x1(\r\x16\r\n\x5docid\x1e\t \x1(\t\x16\r\n\x5" + "index\x1e\n \x1(\r\x16\x10\n\x6author\x1e\xd \x1(\t\x16\x11\n\x7mention\x1e\xe"
				 + " \x1(\t\x16\x18\n\xementionBegin\x1e\r \x1(\r\x16\x16\n\nmentionEnd" + "\x1e\x10 \x1(\r\x16\x17\n\xdmentionType\x1e\x11 \x1(\t\x16\x18\n\xementionSi" + "eve\x1e\x14 \x1(\t\x16\x11\n\x7speaker\x1e\x15 \x1(\t\x16\x18\n\xespeakerSie" + "ve\x1e\x16 \x1(\t\x16\x1e\n\x14canonicalMention\x1e\x17 \x1(\t\x16\x23\n\x19ca"
				, "nonicalMentionBegin\x1e\x18 \x1(\r\x16\x21\n\x17canonicalMe" + "ntionEnd\x1e\x19 \x1(\r\x16N\n\x20attributionDependencyG" + "raph\x1e\x1a \x1(\x84*.edu.stanford.nlp.pipeline.D" + "ependencyGraph\"\x133\x1\n\tParseTree\xdf\n\x5child\x1e\x1 "
				 + "\x3(\x84$.edu.stanford.nlp.pipeline.ParseTre" + "e\x16\r\n\x5value\x1e\x2 \x1(\t\x16\x1b\n\x11yieldBeginIndex\x1e\x3 \x1(" + "\r\x16\x19\n\ryieldEndIndex\x1e\x4 \x1(\r\x16\r\n\x5score\x1e\x5 \x1(\x1\x16" + "7\n\tsentiment\x1e\x6 \x1(\xa2$.edu.stanford.nlp.pi"
				 + "peline.Sentiment\"\xe2\x3\n\x11DependencyGraph\x16=\n\x4" + "node\x1e\x1 \x3(\x84/.edu.stanford.nlp.pipeline.D", "ependencyGraph.Node\x16=\n\x4edge\x1e\x2 \x3(\x84/.edu." + "stanford.nlp.pipeline.DependencyGraph.Ed" + "ge\x16\x14\n\x4root\x1e\x3 \x3(\rB\x2\x14\x1\x20D\n\x4Node\x16\x19\n\rsentence"
				 + "Index\x1e\x1 \x2(\r\x16\r\n\x5index\x1e\x2 \x2(\r\x16\x1a\n\x10copyAnnota" + "tion\x1e\x3 \x1(\r\x20\xfe\x1\n\x4Edge\x16\x10\n\x6source\x1e\x1 \x2(\r\x16\x10\n\x6t" + "arget\x1e\x2 \x2(\r\x16\xd\n\x3dep\x1e\x3 \x1(\t\x16\x11\n\x7isExtra\x1e\x4 \x1("
				 + "\xa\x16\x16\n\nsourceCopy\x1e\x5 \x1(\r\x16\x16\n\ntargetCopy\x1e\x6 \x1(" + "\r\x16>\n\xalanguage\x1e\x7 \x1(\xa2#.edu.stanford.nlp.p" + "ipeline.Language:\x7Unknown\"\x132\x2\n\nCorefChain" + "\x16\x11\n\x7chainID\x1e\x1 \x2(\x5\x16C\n\x7mention\x1e\x2 \x3(\x52a.edu"
				, ".stanford.nlp.pipeline.CorefChain.CorefM" + "ention\x16\x1a\n\x10representative\x1e\x3 \x2(\r\x20\x137\x1\n\xeCoref" + "Mention\x16\x15\n\tmentionID\x1e\x1 \x1(\x5\x16\x17\n\xdmentionTyp" + "e\x1e\x2 \x1(\t\x16\x10\n\x6number\x1e\x3 \x1(\t\x16\x10\n\x6gender\x1e\x4 \x1(\t\x16"
				 + "\x11\n\x7animacy\x1e\x5 \x1(\t\x16\x16\n\nbeginIndex\x1e\x6 \x1(\r\x16\x14\n\xa" + "endIndex\x1e\x7 \x1(\r\x16\x15\n\theadIndex\x1e\t \x1(\r\x16\x19\n\rsen" + "tenceIndex\x1e\n \x1(\r\x16\x14\n\xaposition\x1e\xd \x1(\r\"\x165\xa\n\x7M" 
				+ "ention\x16\x15\n\tmentionID\x1e\x1 \x1(\x5\x16\x17\n\xdmentionType" + "\x1e\x2 \x1(\t\x16\x10\n\x6number\x1e\x3 \x1(\t\x16\x10\n\x6gender\x1e\x4 \x1(\t\x16\x11" + "\n\x7animacy\x1e\x5 \x1(\t\x16\x10\n\x6person\x1e\x6 \x1(\t\x16\x16\n\nstart"
				, "Index\x1e\x7 \x1(\r\x16\x14\n\xaendIndex\x1e\t \x1(\r\x16\x15\n\theadInd" + "ex\x1e\n \x1(\r\x16\x16\n\nheadString\x1e\xd \x1(\t\x16\x15\n\tnerStrin" + "g\x1e\xe \x1(\t\x16\x17\n\xdoriginalRef\x1e\r \x1(\r\x16\x20\n\x16goldCore" + "fClusterID\x1e\x10 \x1(\x5\x16\x1a\n\x10corefClusterID\x1e\x11 \x1(\x5"
				 + "\x16\x16\n\nmentionNum\x1e\x14 \x1(\r\x16\x11\n\x7sentNum\x1e\x15 \x1(\r\x16\r\n" + "\x5utter\x1e\x16 \x1(\r\x16\x15\n\tparagraph\x1e\x17 \x1(\r\x16\x15\n\tisSub" + "ject\x1e\x18 \x1(\xa\x16\x1a\n\x10isDirectObject\x1e\x19 \x1(\xa\x16\x1e\n\x14is"
				 + "IndirectObject\x1e\x1a \x1(\xa\x16\x21\n\x17isPrepositionObj" + "ect\x1e\x1b \x1(\xa\x16\x11\n\x7hasTwin\x1e\x1e \x1(\xa\x16\x11\n\x7generic\x1e\x1f " + "\x1(\xa\x16\x17\n\xdisSingleton\x1e\x20 \x1(\xa\x16\x20\n\x16hasBasicDepe", "ndency\x1e\x21 \x1(\xa\x16\x23\n\x19hasEnhancedDepenedncy\x1e\x22 "
				 + "\x1(\xa\x16\x21\n\x17hasContextParseTree\x1e\x23 \x1(\xa\x16?\n\x11head" + "IndexedWord\x1e\x24 \x1(\x84&.edu.stanford.nlp.pip" + "eline.IndexedWord\x16=\n\rdependingVerb\x1e\x25 \x1(\xd" + "2&.edu.stanford.nlp.pipeline.IndexedWord" + "\xe4\n\xaheadWord\x1e  \x1(\x84&.edu.stanford.nlp.pi"
				 + "peline.IndexedWord\x16;\n\xdspeakerInfo\x1e! \x1(\x84" + "&.edu.stanford.nlp.pipeline.SpeakerInfo\x16" + "=\n\rsentenceWords\x12e \x3(\x84&.edu.stanford.nl" + "p.pipeline.IndexedWord\x16<\n\xeoriginalSpan\x12f", " \x3(\x84&.edu.stanford.nlp.pipeline.Indexed"
				 + "Word\x16\x16\n\ndependents\x130 \x3(\t\x16\x1f\n\x15preprocessed" + "Terms\x131 \x3(\t\x16\x17\n\xdappositions\x132 \x3(\x5\x16\x22\n\x18pred" + "icateNominatives\x133 \x3(\x5\x16\x1e\n\x14relativePronou" + "ns\x134 \x3(\x5\x16\x17\n\xdlistMembers\x135 \x3(\x5\x16\x19\n\rbelongT"
				 + "oLists\x1e: \x3(\x5\"X\n\xdIndexedWord\x16\x17\n\xdsentenceN" + "um\x1e\x1 \x1(\r\x16\x16\n\ntokenIndex\x1e\x2 \x1(\r\x16\r\n\x5docID\x1e\x3 " + "\x1(\r\x16\x15\n\tcopyCount\x1e\x4 \x1(\r\"4\n\xdSpeakerInfo\x16\x17\n" + "\xdspeakerName\x1e\x1 \x1(\t\x16\x14\n\xamentions\x1e\x2 \x3(\x5\"\"\n\x4"
				 + "Span\x16\r\n\x5begin\x1e\x1 \x2(\r\x16\xd\n\x3end\x1e\x2 \x2(\r\"w\n\x5Time", "x\x16\r\n\x5value\x1e\x1 \x1(\t\x16\x14\n\xaaltValue\x1e\x2 \x1(\t\x16\xe\n\x4te" + "xt\x1e\x3 \x1(\t\x16\xe\n\x4type\x1e\x4 \x1(\t\x16\xd\n\x3tid\x1e\x5 \x1(\t\x16\x16\n\nb"
				 + "eginPoint\x1e\x6 \x1(\r\x16\x14\n\xaendPoint\x1e\x7 \x1(\r\"\x14d\x1\n\x6En" + "tity\x16\x15\n\theadStart\x1e\x6 \x1(\r\x16\x11\n\x7headEnd\x1e\x7 \x1(\r" + "\x16\x17\n\xdmentionType\x1e\xa \x1(\t\x16\x1a\n\x10normalizedName\x1e" + "\t \x1(\t\x16\x1a\n\x10headTokenIndex\x1e\n \x1(\r\x16\x11\n\x7corefID"
				 + "\x1e\xd \x1(\t\x16\x14\n\xaobjectID\x1e\x1 \x1(\t\x16\x17\n\xdextentStart\x1e" + "\x2 \x1(\r\x16\x15\n\textentEnd\x1e\x3 \x1(\r\x16\xe\n\x4type\x1e\x4 \x1(\t\x16\x11" + "\n\x7subtype\x1e\x5 \x1(\t\"\x10b\x1\n\xaRelation\x16\x11\n\x7argName\x1e"
				 + "\x6 \x3(\t\x16.\n\x3arg\x1e\x7 \x3(\x84!.edu.stanford.nlp.pi", "peline.Entity\x16\x15\n\tsignature\x1e\xa \x1(\t\x16\x14\n\xaobje" + "ctID\x1e\x1 \x1(\t\x16\x17\n\xdextentStart\x1e\x2 \x1(\r\x16\x15\n\texten" + "tEnd\x1e\x3 \x1(\r\x16\xe\n\x4type\x1e\x4 \x1(\t\x16\x11\n\x7subtype\x1e\x5 \x1("
				 + "\t\"\x106\x1\n\xaOperator\x16\xe\n\x4name\x1e\x1 \x2(\t\x16\x21\n\x17quantifi" + "erSpanBegin\x1e\x2 \x2(\x5\x16\x1f\n\x15quantifierSpanEnd\x1e\x3" + " \x2(\x5\x16\x1e\n\x14subjectSpanBegin\x1e\x4 \x2(\x5\x16\x1a\n\x10subjec" + "tSpanEnd\x1e\x5 \x2(\x5\x16\x1b\n\x11objectSpanBegin\x1e\x6 \x2(\x5\x16"
				 + "\x19\n\robjectSpanEnd\x1e\x7 \x2(\x5\"\xfb\x4\n\xaPolarity\x16K\n\x16p" + "rojectEquivalence\x1e\x1 \x2(\xa2/.edu.stanford.n" + "lp.pipeline.NaturalLogicRelation\x16Q\n\x1eproj", "ectForwardEntailment\x1e\x2 \x2(\xa2/.edu.stanfor" + "d.nlp.pipeline.NaturalLogicRelation\x16Q\n\x1ep"
				 + "rojectReverseEntailment\x1e\x3 \x2(\xa2/.edu.stan" + "ford.nlp.pipeline.NaturalLogicRelation\x16H" + "\n\x11projectNegation\x1e\x4 \x2(\xa2/.edu.stanford.n" + "lp.pipeline.NaturalLogicRelation\x16K\n\x16proj" + "ectAlternation\x1e\x5 \x2(\xa2/.edu.stanford.nlp."
				 + "pipeline.NaturalLogicRelation\x16E\n\xeproject" + "Cover\x1e\x6 \x2(\xa2/.edu.stanford.nlp.pipeline." + "NaturalLogicRelation\x16L\n\x17projectIndepende", "nce\x1e\x7 \x2(\xa2/.edu.stanford.nlp.pipeline.Na" + "turalLogicRelation\"\x14f\x2\n\nNERMention\x16\x19\n\rsen"
				 + "tenceIndex\x1e\x1 \x1(\r\x16%\n\x23tokenStartInSentence" + "Inclusive\x1e\x2 \x2(\r\x16#\n\x21tokenEndInSentenceExc" + "lusive\x1e\x3 \x2(\r\x16\xd\n\x3ner\x1e\x4 \x2(\t\x16\x19\n\rnormalizedN" + "ER\x1e\x5 \x1(\t\x16\x16\n\nentityType\x1e\x6 \x1(\t\x16/\n\x5timex\x1e\x7 "
				 + "\x1(\x84 .edu.stanford.nlp.pipeline.Timex\x16\x1b\n" + "\x11wikipediaEntity\x1e\xa \x1(\t\x16\x10\n\x6gender\x1e\t \x1(\t\x16\x20" + "\n\x16entityMentionIndex\x1e\n \x1(\r\x16#\n\x21canonicalE" + "ntityMentionIndex\x1e\xd \x1(\r\x16\x1f\n\x15entityMention"
				, "Text\x1e\xe \x1(\t\"Y\n\x14SentenceFragment\x16\x16\n\ntokenI" + "ndex\x1e\x1 \x3(\r\x16\xe\n\x4root\x1e\x2 \x1(\r\x16\x18\n\xeassumedTruth" + "\x1e\x3 \x1(\xa\x16\r\n\x5score\x1e\x4 \x1(\x1\":\n\rTokenLocation\x16\x19" + "\n\rsentenceIndex\x1e\x1 \x1(\r\x16\x16\n\ntokenIndex\x1e\x2 \x1("
				 + "\r\"\xe8\x3\n\x10RelationTriple\x16\x11\n\x7subject\x1e\x1 \x1(\t\x16\x14\n" + "\xarelation\x1e\x2 \x1(\t\x16\x10\n\x6object\x1e\x3 \x1(\t\x16\x16\n\nconfi" + "dence\x1e\x4 \x1(\x1\x16?\n\rsubjectTokens\x1e\r \x3(\x84(.edu" + ".stanford.nlp.pipeline.TokenLocation\x16@\n\x10"
				 + "relationTokens\x1e\x10 \x3(\x84(.edu.stanford.nlp." + "pipeline.TokenLocation\x16>\n\xeobjectTokens\x1e\x11", " \x3(\x84(.edu.stanford.nlp.pipeline.TokenLo" + "cation\xe4\n\x4tree\x1e\xa \x1(\x84*.edu.stanford.nlp." + "pipeline.DependencyGraph\x16\x10\n\x6istmod\x1e\t \x1(\xa"
				 + "\x16\x14\n\xaprefixBe\x1e\n \x1(\xa\x16\x14\n\xasuffixBe\x1e\xd \x1(\xa\x16\x14\n\xa" + "suffixOf\x1e\xe \x1(\xa\"-\n\x11MapStringString\x16\xd\n\x3key" + "\x1e\x1 \x3(\t\x16\r\n\x5value\x1e\x2 \x3(\t\"*\n\xeMapIntString\x16\xd\n" + "\x3key\x1e\x1 \x3(\r\x16\r\n\x5value\x1e\x2 \x3(\t\"\x176\x1\n\x7Section\x16\x15\n"
				 + "\tcharBegin\x1e\x1 \x2(\r\x16\x11\n\x7charEnd\x1e\x2 \x2(\r\x16\x10\n\x6aut" + "hor\x1e\x3 \x1(\t\x16\x1b\n\x11sentenceIndexes\x1e\x4 \x3(\r\x16\x14\n\xada" + "tetime\x1e\x5 \x1(\t\xdc\n\x6quotes\x1e\x6 \x3(\x84 .edu.stanf", "ord.nlp.pipeline.Quote\x16\x1b\n\x11authorCharBegi"
				 + "n\x1e\x7 \x1(\r\x16\x19\n\rauthorCharEnd\x1e\xa \x1(\r\xdc\n\x6xmlTag" + "\x1e\t \x2(\x84 .edu.stanford.nlp.pipeline.Token" + "*\xf3\x1\n\xaLanguage\x16\xd\n\x7Unknown\x14\x0\x16\x7\n\x3Any\x14\x1\x16\n\n\x6A" + "rabic\x14\x2\x16\xd\n\x7Chinese\x14\x3\x16\xd\n\x7English\x14\x4\x16\n\n\x6Ger"
				 + "man\x14\x5\x16\n\n\x6French\x14\x6\x16\n\n\x6Hebrew\x14\x7\x16\xd\n\x7Spanish" + "\x14\xa\x16\x18\n\x14UniversalEnglish\x14\t\x16\x18\n\x14UniversalChi" + "nese\x14\n*h\n\tSentiment\x16\x17\n\x11STRONG_NEGATIVE\x14\x0" + "\x16\x15\n\rWEAK_NEGATIVE\x14\x1\x16\xd\n\x7NEUTRAL\x14\x2\x16\x15\n\rWEAK"
				 + "_POSITIVE\x14\x3\x16\x17\n\x11STRONG_POSITIVE\x14\x4*\xdf\x1\n\x18Nat", "uralLogicRelation\x16\x11\n\xdEQUIVALENCE\x14\x0\x16\x1a\n\x16FO" + "RWARD_ENTAILMENT\x14\x1\x16\x1a\n\x16REVERSE_ENTAILMENT" + "\x14\x2\x16\xe\n\xaNEGATION\x14\x3\x16\x11\n\xdALTERNATION\x14\x4\x16\t\n\x5COV"
				 + "ER\x14\x5\x16\x14\n\xeINDEPENDENCE\x14\x6B*\n\x1fedu.stanford.n" + "lp.pipelineB\rCoreNLPProtos" };
			Descriptors.FileDescriptor.IInternalDescriptorAssigner assigner = new _IInternalDescriptorAssigner_61661();
			Descriptors.FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData, new Descriptors.FileDescriptor[] {  }, assigner);
			internal_static_edu_stanford_nlp_pipeline_Document_descriptor = GetDescriptor().GetMessageTypes()[0];
			internal_static_edu_stanford_nlp_pipeline_Document_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Document_descriptor, new string[] { "Text", "Sentence", "CorefChain", "DocID", "DocDate"
				, "Calendar", "SentencelessToken", "Character", "Quote", "Mentions", "HasEntityMentionsAnnotation", "XmlDoc", "Sections", "MentionsForCoref", "HasCorefMentionAnnotation", "HasCorefAnnotation", "CorefMentionToEntityMentionMappings", "EntityMentionToCorefMentionMappings"
				 });
			internal_static_edu_stanford_nlp_pipeline_Sentence_descriptor = GetDescriptor().GetMessageTypes()[1];
			internal_static_edu_stanford_nlp_pipeline_Sentence_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Sentence_descriptor, new string[] { "Token", "TokenOffsetBegin", "TokenOffsetEnd", "SentenceIndex"
				, "CharacterOffsetBegin", "CharacterOffsetEnd", "ParseTree", "BinarizedParseTree", "AnnotatedParseTree", "Sentiment", "KBestParseTrees", "BasicDependencies", "CollapsedDependencies", "CollapsedCCProcessedDependencies", "AlternativeDependencies"
				, "OpenieTriple", "KbpTriple", "EntailedSentence", "EntailedClause", "EnhancedDependencies", "EnhancedPlusPlusDependencies", "Character", "Paragraph", "Text", "LineNumber", "HasRelationAnnotations", "Entity", "Relation", "HasNumerizedTokensAnnotation"
				, "Mentions", "MentionsForCoref", "HasCorefMentionsAnnotation", "SentenceID", "SectionDate", "SectionIndex", "SectionName", "SectionAuthor", "DocID", "SectionQuoted", "HasEntityMentionsAnnotation", "HasKBPTriplesAnnotation", "HasOpenieTriplesAnnotation"
				, "ChapterIndex", "ParagraphIndex" });
			internal_static_edu_stanford_nlp_pipeline_Token_descriptor = GetDescriptor().GetMessageTypes()[2];
			internal_static_edu_stanford_nlp_pipeline_Token_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Token_descriptor, new string[] { "Word", "Pos", "Value", "Category", "Before", "After", 
				"OriginalText", "Ner", "CoarseNER", "FineGrainedNER", "NormalizedNER", "Lemma", "BeginChar", "EndChar", "Utterance", "Speaker", "BeginIndex", "EndIndex", "TokenBeginIndex", "TokenEndIndex", "TimexValue", "HasXmlContext", "XmlContext", "CorefClusterID"
				, "Answer", "HeadWordIndex", "Operator", "Polarity", "PolarityDir", "Span", "Sentiment", "QuotationIndex", "ConllUFeatures", "CoarseTag", "ConllUTokenSpan", "ConllUMisc", "ConllUSecondaryDeps", "WikipediaEntity", "IsNewline", "Gender", "TrueCase"
				, "TrueCaseText", "ChineseChar", "ChineseSeg", "ChineseXMLChar", "SectionName", "SectionAuthor", "SectionDate", "SectionEndLabel", "Parent", "CorefMentionIndex", "EntityMentionIndex" });
			internal_static_edu_stanford_nlp_pipeline_Quote_descriptor = GetDescriptor().GetMessageTypes()[3];
			internal_static_edu_stanford_nlp_pipeline_Quote_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Quote_descriptor, new string[] { "Text", "Begin", "End", "SentenceBegin", "SentenceEnd", 
				"TokenBegin", "TokenEnd", "Docid", "Index", "Author", "Mention", "MentionBegin", "MentionEnd", "MentionType", "MentionSieve", "Speaker", "SpeakerSieve", "CanonicalMention", "CanonicalMentionBegin", "CanonicalMentionEnd", "AttributionDependencyGraph"
				 });
			internal_static_edu_stanford_nlp_pipeline_ParseTree_descriptor = GetDescriptor().GetMessageTypes()[4];
			internal_static_edu_stanford_nlp_pipeline_ParseTree_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_ParseTree_descriptor, new string[] { "Child", "Value", "YieldBeginIndex", "YieldEndIndex"
				, "Score", "Sentiment" });
			internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor = GetDescriptor().GetMessageTypes()[5];
			internal_static_edu_stanford_nlp_pipeline_DependencyGraph_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor, new string[] { "Node", "Edge", "Root" });
			internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_descriptor = internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor.GetNestedTypes()[0];
			internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Node_descriptor, new string[] { "SentenceIndex", "Index", 
				"CopyAnnotation" });
			internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_descriptor = internal_static_edu_stanford_nlp_pipeline_DependencyGraph_descriptor.GetNestedTypes()[1];
			internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_DependencyGraph_Edge_descriptor, new string[] { "Source", "Target", "Dep"
				, "IsExtra", "SourceCopy", "TargetCopy", "Language" });
			internal_static_edu_stanford_nlp_pipeline_CorefChain_descriptor = GetDescriptor().GetMessageTypes()[6];
			internal_static_edu_stanford_nlp_pipeline_CorefChain_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_CorefChain_descriptor, new string[] { "ChainID", "Mention", "Representative" });
			internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_descriptor = internal_static_edu_stanford_nlp_pipeline_CorefChain_descriptor.GetNestedTypes()[0];
			internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_CorefChain_CorefMention_descriptor, new string[] { "MentionID", "MentionType"
				, "Number", "Gender", "Animacy", "BeginIndex", "EndIndex", "HeadIndex", "SentenceIndex", "Position" });
			internal_static_edu_stanford_nlp_pipeline_Mention_descriptor = GetDescriptor().GetMessageTypes()[7];
			internal_static_edu_stanford_nlp_pipeline_Mention_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Mention_descriptor, new string[] { "MentionID", "MentionType", "Number", "Gender", "Animacy"
				, "Person", "StartIndex", "EndIndex", "HeadIndex", "HeadString", "NerString", "OriginalRef", "GoldCorefClusterID", "CorefClusterID", "MentionNum", "SentNum", "Utter", "Paragraph", "IsSubject", "IsDirectObject", "IsIndirectObject", "IsPrepositionObject"
				, "HasTwin", "Generic", "IsSingleton", "HasBasicDependency", "HasEnhancedDepenedncy", "HasContextParseTree", "HeadIndexedWord", "DependingVerb", "HeadWord", "SpeakerInfo", "SentenceWords", "OriginalSpan", "Dependents", "PreprocessedTerms", 
				"Appositions", "PredicateNominatives", "RelativePronouns", "ListMembers", "BelongToLists" });
			internal_static_edu_stanford_nlp_pipeline_IndexedWord_descriptor = GetDescriptor().GetMessageTypes()[8];
			internal_static_edu_stanford_nlp_pipeline_IndexedWord_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_IndexedWord_descriptor, new string[] { "SentenceNum", "TokenIndex", "DocID", "CopyCount"
				 });
			internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_descriptor = GetDescriptor().GetMessageTypes()[9];
			internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_SpeakerInfo_descriptor, new string[] { "SpeakerName", "Mentions" });
			internal_static_edu_stanford_nlp_pipeline_Span_descriptor = GetDescriptor().GetMessageTypes()[10];
			internal_static_edu_stanford_nlp_pipeline_Span_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Span_descriptor, new string[] { "Begin", "End" });
			internal_static_edu_stanford_nlp_pipeline_Timex_descriptor = GetDescriptor().GetMessageTypes()[11];
			internal_static_edu_stanford_nlp_pipeline_Timex_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Timex_descriptor, new string[] { "Value", "AltValue", "Text", "Type", "Tid", "BeginPoint"
				, "EndPoint" });
			internal_static_edu_stanford_nlp_pipeline_Entity_descriptor = GetDescriptor().GetMessageTypes()[12];
			internal_static_edu_stanford_nlp_pipeline_Entity_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Entity_descriptor, new string[] { "HeadStart", "HeadEnd", "MentionType", "NormalizedName"
				, "HeadTokenIndex", "CorefID", "ObjectID", "ExtentStart", "ExtentEnd", "Type", "Subtype" });
			internal_static_edu_stanford_nlp_pipeline_Relation_descriptor = GetDescriptor().GetMessageTypes()[13];
			internal_static_edu_stanford_nlp_pipeline_Relation_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Relation_descriptor, new string[] { "ArgName", "Arg", "Signature", "ObjectID", "ExtentStart"
				, "ExtentEnd", "Type", "Subtype" });
			internal_static_edu_stanford_nlp_pipeline_Operator_descriptor = GetDescriptor().GetMessageTypes()[14];
			internal_static_edu_stanford_nlp_pipeline_Operator_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Operator_descriptor, new string[] { "Name", "QuantifierSpanBegin", "QuantifierSpanEnd"
				, "SubjectSpanBegin", "SubjectSpanEnd", "ObjectSpanBegin", "ObjectSpanEnd" });
			internal_static_edu_stanford_nlp_pipeline_Polarity_descriptor = GetDescriptor().GetMessageTypes()[15];
			internal_static_edu_stanford_nlp_pipeline_Polarity_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Polarity_descriptor, new string[] { "ProjectEquivalence", "ProjectForwardEntailment", 
				"ProjectReverseEntailment", "ProjectNegation", "ProjectAlternation", "ProjectCover", "ProjectIndependence" });
			internal_static_edu_stanford_nlp_pipeline_NERMention_descriptor = GetDescriptor().GetMessageTypes()[16];
			internal_static_edu_stanford_nlp_pipeline_NERMention_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_NERMention_descriptor, new string[] { "SentenceIndex", "TokenStartInSentenceInclusive"
				, "TokenEndInSentenceExclusive", "Ner", "NormalizedNER", "EntityType", "Timex", "WikipediaEntity", "Gender", "EntityMentionIndex", "CanonicalEntityMentionIndex", "EntityMentionText" });
			internal_static_edu_stanford_nlp_pipeline_SentenceFragment_descriptor = GetDescriptor().GetMessageTypes()[17];
			internal_static_edu_stanford_nlp_pipeline_SentenceFragment_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_SentenceFragment_descriptor, new string[] { "TokenIndex", "Root", "AssumedTruth"
				, "Score" });
			internal_static_edu_stanford_nlp_pipeline_TokenLocation_descriptor = GetDescriptor().GetMessageTypes()[18];
			internal_static_edu_stanford_nlp_pipeline_TokenLocation_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_TokenLocation_descriptor, new string[] { "SentenceIndex", "TokenIndex" });
			internal_static_edu_stanford_nlp_pipeline_RelationTriple_descriptor = GetDescriptor().GetMessageTypes()[19];
			internal_static_edu_stanford_nlp_pipeline_RelationTriple_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_RelationTriple_descriptor, new string[] { "Subject", "Relation", "Object", "Confidence"
				, "SubjectTokens", "RelationTokens", "ObjectTokens", "Tree", "Istmod", "PrefixBe", "SuffixBe", "SuffixOf" });
			internal_static_edu_stanford_nlp_pipeline_MapStringString_descriptor = GetDescriptor().GetMessageTypes()[20];
			internal_static_edu_stanford_nlp_pipeline_MapStringString_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_MapStringString_descriptor, new string[] { "Key", "Value" });
			internal_static_edu_stanford_nlp_pipeline_MapIntString_descriptor = GetDescriptor().GetMessageTypes()[21];
			internal_static_edu_stanford_nlp_pipeline_MapIntString_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_MapIntString_descriptor, new string[] { "Key", "Value" });
			internal_static_edu_stanford_nlp_pipeline_Section_descriptor = GetDescriptor().GetMessageTypes()[22];
			internal_static_edu_stanford_nlp_pipeline_Section_fieldAccessorTable = new GeneratedMessageV3.FieldAccessorTable(internal_static_edu_stanford_nlp_pipeline_Section_descriptor, new string[] { "CharBegin", "CharEnd", "Author", "SentenceIndexes"
				, "Datetime", "Quotes", "AuthorCharBegin", "AuthorCharEnd", "XmlTag" });
		}

		private sealed class _IInternalDescriptorAssigner_61661 : Descriptors.FileDescriptor.IInternalDescriptorAssigner
		{
			public _IInternalDescriptorAssigner_61661()
			{
			}

			public ExtensionRegistry AssignDescriptors(Descriptors.FileDescriptor root)
			{
				CoreNLPProtos.descriptor = root;
				return null;
			}
		}
		// @@protoc_insertion_point(outer_class_scope)
	}
}
