using System.Collections.Generic;






namespace Edu.Stanford.Nlp.Util
{
	/// <summary>
	/// Static class with some useful
	/// <see cref="Java.Util.Function.IPredicate{T}"/>
	/// implementations and utility methods for working
	/// with
	/// <c>Predicates</c>
	/// .
	/// <p>
	/// Contains filters that always accept or reject, filters that accept or reject an Object if it's in a given
	/// Collection, as well as several composite filters. Contains methods for creating a new Filter that is the AND/OR of
	/// two Filters, or the NOT of a Filter. Finally, you can filter an Object[] through a Filter to return a new
	/// <c>Object[]</c>
	/// with only the accepted values, or
	/// <see cref="RetainAll{E}(System.Collections.Generic.ICollection{E}, Java.Util.Function.IPredicate{T})"/>
	/// elements in a Collection that pass a filter.
	/// </summary>
	/// <author>Christopher Manning</author>
	/// <version>1.0</version>
	public class Filters
	{
		/// <summary>Nothing to instantiate</summary>
		private Filters()
		{
		}

		/// <summary>The acceptFilter accepts everything.</summary>
		public static IPredicate<T> AcceptFilter<T>()
		{
			return new Filters.CategoricalFilter<T>(true);
		}

		/// <summary>The rejectFilter accepts nothing.</summary>
		public static IPredicate<T> RejectFilter<T>()
		{
			return new Filters.CategoricalFilter<T>(false);
		}

		[System.Serializable]
		private sealed class CategoricalFilter<T> : IPredicate<T>
		{
			private readonly bool judgment;

			protected internal CategoricalFilter(bool judgment)
			{
				this.judgment = judgment;
			}

			/// <summary>Checks if the given object passes the filter.</summary>
			/// <param name="obj">an object to test</param>
			public bool Test(T obj)
			{
				return judgment;
			}

			public override string ToString()
			{
				return "CategoricalFilter(" + judgment + ')';
			}

			public override int GetHashCode()
			{
				return ToString().GetHashCode();
			}

			public override bool Equals(object other)
			{
				if (other == this)
				{
					return true;
				}
				if (!(other is Filters.CategoricalFilter))
				{
					return false;
				}
				return ((Filters.CategoricalFilter)other).judgment == this.judgment;
			}

			private const long serialVersionUID = 7501774666726883656L;
			// Automatically generated by Eclipse
		}

		/// <summary>The collectionAcceptFilter accepts a certain collection.</summary>
		public static IPredicate<E> CollectionAcceptFilter<E>(E[] objs)
		{
			return new Filters.CollectionAcceptFilter<E>(Arrays.AsList(objs), true);
		}

		/// <summary>The collectionAcceptFilter accepts a certain collection.</summary>
		public static IPredicate<E> CollectionAcceptFilter<E>(ICollection<E> objs)
		{
			return new Filters.CollectionAcceptFilter<E>(objs, true);
		}

		/// <summary>The collectionRejectFilter rejects a certain collection.</summary>
		public static IPredicate<E> CollectionRejectFilter<E>(E[] objs)
		{
			return new Filters.CollectionAcceptFilter<E>(Arrays.AsList(objs), false);
		}

		/// <summary>The collectionRejectFilter rejects a certain collection.</summary>
		public static IPredicate<E> CollectionRejectFilter<E>(ICollection<E> objs)
		{
			return new Filters.CollectionAcceptFilter<E>(objs, false);
		}

		[System.Serializable]
		private sealed class CollectionAcceptFilter<E> : IPredicate<E>
		{
			private readonly ICollection<E> args;

			private readonly bool judgment;

			protected internal CollectionAcceptFilter(ICollection<E> c, bool judgment)
			{
				this.args = Generics.NewHashSet(c);
				this.judgment = judgment;
			}

			/// <summary>Checks if the given object passes the filter.</summary>
			/// <param name="obj">an object to test</param>
			public bool Test(E obj)
			{
				if (args.Contains(obj))
				{
					return judgment;
				}
				return !judgment;
			}

			public override string ToString()
			{
				return "(" + judgment + ':' + args + ')';
			}

			private const long serialVersionUID = -8870550963937943540L;
		}

		// end class CollectionAcceptFilter
		/// <summary>Filter that accepts only when both filters accept (AND).</summary>
		public static IPredicate<E> AndFilter<E>(IPredicate<E> f1, IPredicate<E> f2)
		{
			return (new Filters.CombinedFilter<E>(f1, f2, true));
		}

		/// <summary>Filter that accepts when either filter accepts (OR).</summary>
		public static IPredicate<E> OrFilter<E>(IPredicate<E> f1, IPredicate<E> f2)
		{
			return (new Filters.CombinedFilter<E>(f1, f2, false));
		}

		/// <summary>Conjunction or disjunction of two filters.</summary>
		[System.Serializable]
		private class CombinedFilter<E> : IPredicate<E>
		{
			private readonly IPredicate<E> f1;

			private readonly IPredicate<E> f2;

			private readonly bool conjunction;

			public CombinedFilter(IPredicate<E> f1, IPredicate<E> f2, bool conjunction)
			{
				// and vs. or
				this.f1 = f1;
				this.f2 = f2;
				this.conjunction = conjunction;
			}

			public virtual bool Test(E o)
			{
				if (conjunction)
				{
					return (f1.Test(o) && f2.Test(o));
				}
				return (f1.Test(o) || f2.Test(o));
			}

			private const long serialVersionUID = -2988241258905198687L;
			// Automatically generated by Eclipse
		}

		/// <summary>Disjunction of a list of filters.</summary>
		[System.Serializable]
		public class DisjFilter<T> : IPredicate<T>
		{
			private readonly IList<IPredicate<T>> filters;

			public DisjFilter(IList<IPredicate<T>> filters)
			{
				this.filters = filters;
			}

			[SafeVarargs]
			public DisjFilter(params IPredicate<T>[] filters)
			{
				this.filters = new List<IPredicate<T>>();
				Sharpen.Collections.AddAll(this.filters, Arrays.AsList(filters));
			}

			public virtual void AddFilter(IPredicate<T> filter)
			{
				filters.Add(filter);
			}

			public virtual bool Test(T obj)
			{
				foreach (IPredicate<T> f in filters)
				{
					if (f.Test(obj))
					{
						return true;
					}
				}
				return false;
			}

			private const long serialVersionUID = 1L;
		}

		/// <summary>Conjunction of a list of filters.</summary>
		[System.Serializable]
		public class ConjFilter<T> : IPredicate<T>
		{
			private readonly IList<IPredicate<T>> filters;

			public ConjFilter(IList<IPredicate<T>> filters)
			{
				this.filters = filters;
			}

			[SafeVarargs]
			public ConjFilter(params IPredicate<T>[] filters)
			{
				this.filters = new List<IPredicate<T>>();
				Sharpen.Collections.AddAll(this.filters, Arrays.AsList(filters));
			}

			public virtual void AddFilter(IPredicate<T> filter)
			{
				filters.Add(filter);
			}

			public virtual bool Test(T obj)
			{
				foreach (IPredicate<T> f in filters)
				{
					if (!f.Test(obj))
					{
						return false;
					}
				}
				return true;
			}

			private const long serialVersionUID = 1L;
		}

		/// <summary>Filter that does the opposite of given filter (NOT).</summary>
		public static IPredicate<E> NotFilter<E>(IPredicate<E> filter)
		{
			return (new Filters.NegatedFilter<E>(filter));
		}

		/// <summary>Filter that's either negated or normal as specified.</summary>
		public static IPredicate<E> SwitchedFilter<E>(IPredicate<E> filter, bool negated)
		{
			return new Filters.NegatedFilter<E>(filter, negated);
		}

		/// <summary>Negation of a filter.</summary>
		[System.Serializable]
		private class NegatedFilter<E> : IPredicate<E>
		{
			private readonly IPredicate<E> filter;

			private readonly bool negated;

			public NegatedFilter(IPredicate<E> filter, bool negated)
			{
				this.filter = filter;
				this.negated = negated;
			}

			public NegatedFilter(IPredicate<E> filter)
				: this(filter, true)
			{
			}

			public virtual bool Test(E o)
			{
				return (negated ^ filter.Test(o));
			}

			// xor
			public override string ToString()
			{
				return "NOT(" + filter.ToString() + ')';
			}

			private const long serialVersionUID = -1599556783677718177L;
			// Automatically generated by Eclipse
		}

		/// <summary>A filter that accepts a random fraction of the input it sees.</summary>
		[System.Serializable]
		public class RandomFilter<E> : IPredicate<E>
		{
			private const long serialVersionUID = -4885773582960355425L;

			private readonly Random random;

			private readonly double fraction;

			public RandomFilter()
				: this(0.1, new Random())
			{
			}

			public RandomFilter(double fraction)
				: this(fraction, new Random())
			{
			}

			public RandomFilter(double fraction, Random random)
			{
				this.fraction = fraction;
				this.random = random;
			}

			public virtual bool Test(E o)
			{
				return (random.NextDouble() < fraction);
			}
		}

		/// <summary>
		/// Applies the given filter to each of the given elements, and returns the
		/// array of elements that were accepted.
		/// </summary>
		/// <remarks>
		/// Applies the given filter to each of the given elements, and returns the
		/// array of elements that were accepted. The runtime type of the returned
		/// array is the same as the passed in array.
		/// </remarks>
		public static E[] Filter<E>(E[] elems, IPredicate<E> filter)
		{
			IList<E> filtered = new List<E>();
			foreach (E elem in elems)
			{
				if (filter.Test(elem))
				{
					filtered.Add(elem);
				}
			}
			return (Sharpen.Collections.ToArray(filtered, (E[])System.Array.CreateInstance(elems.GetType().GetElementType(), filtered.Count)));
		}

		/// <summary>Removes all elements in the given Collection that aren't accepted by the given Filter.</summary>
		public static void RetainAll<E, _T1>(ICollection<E> elems, IPredicate<_T1> filter)
		{
			for (IEnumerator<E> iter = elems.GetEnumerator(); iter.MoveNext(); )
			{
				E elem = iter.Current;
				if (!filter.Test(elem))
				{
					iter.Remove();
				}
			}
		}
	}
}
