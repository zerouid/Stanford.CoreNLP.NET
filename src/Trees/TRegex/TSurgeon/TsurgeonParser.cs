/* TsurgeonParser.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. TsurgeonParser.java */
using System;
using System.Collections.Generic;
using Edu.Stanford.Nlp.Trees;
using Edu.Stanford.Nlp.Util;



namespace Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon
{
	internal class TsurgeonParser : ITsurgeonParserTreeConstants, ITsurgeonParserConstants
	{
		protected internal JJTTsurgeonParserState jjtree = new JJTTsurgeonParserState();

		private ITreeFactory treeFactory = new LabeledScoredTreeFactory();

		/*@bgen(jjtree)*/
		/*@bgen(jjtree)*/
		public static void Main(string[] args)
		{
			System.Console.Out.WriteLine("Reading from standard input...");
			Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.TsurgeonParser t = new Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.TsurgeonParser(Runtime.@in);
			try
			{
				TsurgeonPattern n = t.Root();
				System.Console.Out.WriteLine(n.ToString());
				System.Console.Out.WriteLine("Thank you.");
			}
			catch (Exception e)
			{
				System.Console.Out.WriteLine("Oops.");
				System.Console.Out.WriteLine(e.Message);
				Sharpen.Runtime.PrintStackTrace(e);
			}
		}

		// TODO: this is wasteful in terms of creating TsurgeonPatternRoot.
		// Should separate that out into another production
		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public TsurgeonPatternRoot Root()
		{
			/*@bgen(jjtree) Root */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjtroot);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			Token name;
			TsurgeonPattern result;
			IList<TsurgeonPattern> results = null;
			try
			{
				switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
				{
					case TsurgeonParserConstantsConstants.Delete:
					case TsurgeonParserConstantsConstants.Prune:
					case TsurgeonParserConstantsConstants.Relabel:
					case TsurgeonParserConstantsConstants.Excise:
					case TsurgeonParserConstantsConstants.Insert:
					case TsurgeonParserConstantsConstants.Move:
					case TsurgeonParserConstantsConstants.Replace:
					case TsurgeonParserConstantsConstants.CreateSubtree:
					case TsurgeonParserConstantsConstants.Adjoin:
					case TsurgeonParserConstantsConstants.AdjoinToHead:
					case TsurgeonParserConstantsConstants.AdjoinToFoot:
					case TsurgeonParserConstantsConstants.Coindex:
					{
						result = Operation();
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return new TsurgeonPatternRoot(result);
							}
						}
						break;
					}

					default:
					{
						jj_la1[1] = jj_gen;
						if (Jj_2_1(2))
						{
							Jj_consume_token(TsurgeonParserConstantsConstants.If);
							Jj_consume_token(TsurgeonParserConstantsConstants.Exists);
							name = Jj_consume_token(TsurgeonParserConstantsConstants.Name);
							result = Root();
							jjtree.CloseNodeScope(jjtn000, true);
							jjtc000 = false;
							{
								if (string.Empty != null)
								{
									return new TsurgeonPatternRoot(new IfExistsNode(name.image, false, result.children));
								}
							}
						}
						else
						{
							if (Jj_2_2(2))
							{
								Jj_consume_token(TsurgeonParserConstantsConstants.If);
								Jj_consume_token(TsurgeonParserConstantsConstants.Not);
								Jj_consume_token(TsurgeonParserConstantsConstants.Exists);
								name = Jj_consume_token(TsurgeonParserConstantsConstants.Name);
								result = Root();
								jjtree.CloseNodeScope(jjtn000, true);
								jjtc000 = false;
								{
									if (string.Empty != null)
									{
										return new TsurgeonPatternRoot(new IfExistsNode(name.image, true, result.children));
									}
								}
							}
							else
							{
								switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
								{
									case TsurgeonParserConstantsConstants.OpenBracket:
									{
										while (true)
										{
											Jj_consume_token(TsurgeonParserConstantsConstants.OpenBracket);
											result = Root();
											Jj_consume_token(TsurgeonParserConstantsConstants.CloseBracket);
											if (results == null)
											{
												results = Generics.NewArrayList();
											}
											foreach (TsurgeonPattern child in result.children)
											{
												results.Add(child);
											}
											switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
											{
												case TsurgeonParserConstantsConstants.OpenBracket:
												{
													break;
												}

												default:
												{
													jj_la1[0] = jj_gen;
													goto label_1_break;
												}
											}
label_1_continue: ;
										}
label_1_break: ;
										jjtree.CloseNodeScope(jjtn000, true);
										jjtc000 = false;
										TsurgeonPattern[] array = new TsurgeonPattern[results.Count];
										{
											if (string.Empty != null)
											{
												return new TsurgeonPatternRoot(Sharpen.Collections.ToArray(results, array));
											}
										}
										break;
									}

									default:
									{
										jj_la1[2] = jj_gen;
										Jj_consume_token(-1);
										throw new ParseException();
									}
								}
							}
						}
						break;
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public TsurgeonPattern Operation()
		{
			/*@bgen(jjtree) Operation */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjtoperation);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			TsurgeonPattern child1;
			TsurgeonPattern child2 = null;
			Token newLabel = null;
			TreeLocation loc = null;
			Token @operator;
			AuxiliaryTree tree = null;
			IList<AuxiliaryTree> treeList = null;
			IList<TsurgeonPattern> nodeSelections = null;
			Token regex;
			Token hash_int;
			try
			{
				switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
				{
					case TsurgeonParserConstantsConstants.Delete:
					{
						@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Delete);
						nodeSelections = NodeSelectionList(new List<TsurgeonPattern>());
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return new DeleteNode(nodeSelections);
							}
						}
						break;
					}

					case TsurgeonParserConstantsConstants.Prune:
					{
						@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Prune);
						nodeSelections = NodeSelectionList(new List<TsurgeonPattern>());
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return new PruneNode(nodeSelections);
							}
						}
						break;
					}

					case TsurgeonParserConstantsConstants.Excise:
					{
						@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Excise);
						child1 = NodeSelection();
						child2 = NodeSelection();
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return new ExciseNode(child1, child2);
							}
						}
						break;
					}

					default:
					{
						jj_la1[3] = jj_gen;
						if (Jj_2_3(3))
						{
							@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Relabel);
							child1 = NodeSelection();
							newLabel = Jj_consume_token(TsurgeonParserConstantsConstants.Identifier);
							jjtree.CloseNodeScope(jjtn000, true);
							jjtc000 = false;
							{
								if (string.Empty != null)
								{
									return new RelabelNode(child1, newLabel.image);
								}
							}
						}
						else
						{
							if (Jj_2_4(3))
							{
								@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Relabel);
								child1 = NodeSelection();
								newLabel = Jj_consume_token(TsurgeonParserConstantsConstants.Quotex);
								jjtree.CloseNodeScope(jjtn000, true);
								jjtc000 = false;
								{
									if (string.Empty != null)
									{
										return new RelabelNode(child1, newLabel.image);
									}
								}
							}
							else
							{
								if (Jj_2_5(3))
								{
									@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Relabel);
									child1 = NodeSelection();
									regex = Jj_consume_token(TsurgeonParserConstantsConstants.Regex);
									jjtree.CloseNodeScope(jjtn000, true);
									jjtc000 = false;
									{
										if (string.Empty != null)
										{
											return new RelabelNode(child1, regex.image);
										}
									}
								}
								else
								{
									if (Jj_2_6(3))
									{
										@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Relabel);
										child1 = NodeSelection();
										newLabel = Jj_consume_token(TsurgeonParserConstantsConstants.GeneralRelabel);
										jjtree.CloseNodeScope(jjtn000, true);
										jjtc000 = false;
										{
											if (string.Empty != null)
											{
												return new RelabelNode(child1, newLabel.image);
											}
										}
									}
									else
									{
										if (Jj_2_7(3))
										{
											@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Replace);
											child1 = NodeSelection();
											child2 = NodeSelection();
											jjtree.CloseNodeScope(jjtn000, true);
											jjtc000 = false;
											{
												if (string.Empty != null)
												{
													return new ReplaceNode(child1, child2);
												}
											}
										}
										else
										{
											if (Jj_2_8(3))
											{
												@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Replace);
												child1 = NodeSelection();
												treeList = TreeList(false);
												jjtree.CloseNodeScope(jjtn000, true);
												jjtc000 = false;
												{
													if (string.Empty != null)
													{
														return new ReplaceNode(child1, treeList);
													}
												}
											}
											else
											{
												switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
												{
													case TsurgeonParserConstantsConstants.Move:
													{
														@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Move);
														child1 = NodeSelection();
														loc = Location();
														jjtree.CloseNodeScope(jjtn000, true);
														jjtc000 = false;
														{
															if (string.Empty != null)
															{
																return new MoveNode(child1, loc);
															}
														}
														break;
													}

													default:
													{
														jj_la1[4] = jj_gen;
														if (Jj_2_9(3))
														{
															@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Insert);
															child1 = NodeSelection();
															loc = Location();
															jjtree.CloseNodeScope(jjtn000, true);
															jjtc000 = false;
															{
																if (string.Empty != null)
																{
																	return new InsertNode(child1, loc);
																}
															}
														}
														else
														{
															if (Jj_2_10(3))
															{
																@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Insert);
																tree = TreeRoot(false);
																loc = Location();
																jjtree.CloseNodeScope(jjtn000, true);
																jjtc000 = false;
																{
																	if (string.Empty != null)
																	{
																		return new InsertNode(tree, loc);
																	}
																}
															}
															else
															{
																switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
																{
																	case TsurgeonParserConstantsConstants.CreateSubtree:
																	{
																		@operator = Jj_consume_token(TsurgeonParserConstantsConstants.CreateSubtree);
																		tree = TreeRoot(false);
																		nodeSelections = NodeSelectionList(new List<TsurgeonPattern>());
																		jjtree.CloseNodeScope(jjtn000, true);
																		jjtc000 = false;
																		if (nodeSelections.Count == 1)
																		{
																			{
																				if (string.Empty != null)
																				{
																					return new CreateSubtreeNode(nodeSelections[0], tree);
																				}
																			}
																		}
																		else
																		{
																			if (nodeSelections.Count == 2)
																			{
																				{
																					if (string.Empty != null)
																					{
																						return new CreateSubtreeNode(nodeSelections[0], nodeSelections[1], tree);
																					}
																				}
																			}
																			else
																			{
																				{
																					if (true)
																					{
																						throw new ParseException("Illegal number of nodes given to createSubtree (" + nodeSelections.Count + ")");
																					}
																				}
																			}
																		}
																		break;
																	}

																	case TsurgeonParserConstantsConstants.Adjoin:
																	{
																		@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Adjoin);
																		tree = TreeRoot(true);
																		child1 = NodeSelection();
																		jjtree.CloseNodeScope(jjtn000, true);
																		jjtc000 = false;
																		{
																			if (string.Empty != null)
																			{
																				return new AdjoinNode(tree, child1);
																			}
																		}
																		break;
																	}

																	case TsurgeonParserConstantsConstants.AdjoinToHead:
																	{
																		@operator = Jj_consume_token(TsurgeonParserConstantsConstants.AdjoinToHead);
																		tree = TreeRoot(true);
																		child1 = NodeSelection();
																		jjtree.CloseNodeScope(jjtn000, true);
																		jjtc000 = false;
																		{
																			if (string.Empty != null)
																			{
																				return new AdjoinToHeadNode(tree, child1);
																			}
																		}
																		break;
																	}

																	case TsurgeonParserConstantsConstants.AdjoinToFoot:
																	{
																		@operator = Jj_consume_token(TsurgeonParserConstantsConstants.AdjoinToFoot);
																		tree = TreeRoot(true);
																		child1 = NodeSelection();
																		jjtree.CloseNodeScope(jjtn000, true);
																		jjtc000 = false;
																		{
																			if (string.Empty != null)
																			{
																				return new AdjoinToFootNode(tree, child1);
																			}
																		}
																		break;
																	}

																	case TsurgeonParserConstantsConstants.Coindex:
																	{
																		@operator = Jj_consume_token(TsurgeonParserConstantsConstants.Coindex);
																		nodeSelections = NodeSelectionList(new List<TsurgeonPattern>());
																		jjtree.CloseNodeScope(jjtn000, true);
																		jjtc000 = false;
																		{
																			if (string.Empty != null)
																			{
																				return new CoindexNodes(Sharpen.Collections.ToArray(nodeSelections, new TsurgeonPattern[] {  }));
																			}
																		}
																		break;
																	}

																	default:
																	{
																		jj_la1[5] = jj_gen;
																		Jj_consume_token(-1);
																		throw new ParseException();
																	}
																}
															}
														}
														break;
													}
												}
											}
										}
									}
								}
							}
						}
						break;
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public TreeLocation Location()
		{
			/*@bgen(jjtree) Location */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjtlocation);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			Token rel;
			TsurgeonPattern child;
			try
			{
				rel = Jj_consume_token(TsurgeonParserConstantsConstants.LocationRelation);
				child = NodeSelection();
				jjtree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				{
					if (string.Empty != null)
					{
						return new TreeLocation(rel.image, child);
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public IList<TsurgeonPattern> NodeSelectionList(IList<TsurgeonPattern> l)
		{
			/*@bgen(jjtree) NodeSelectionList */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjtnodeselectionlist);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			TsurgeonPattern result;
			try
			{
				result = NodeSelection();
				l.Add(result);
				while (true)
				{
					switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
					{
						case TsurgeonParserConstantsConstants.Identifier:
						{
							break;
						}

						default:
						{
							jj_la1[6] = jj_gen;
							goto label_2_break;
						}
					}
					result = NodeSelection();
					l.Add(result);
label_2_continue: ;
				}
label_2_break: ;
				jjtree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				{
					if (string.Empty != null)
					{
						return l;
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		// TODO: what does this next comment mean?
		// we'll also put in a way to use a SELECTION with a list of nodes.
		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public TsurgeonPattern NodeSelection()
		{
			/*@bgen(jjtree) NodeSelection */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjtnodeselection);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			TsurgeonPattern result;
			try
			{
				result = NodeName();
				jjtree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				{
					if (string.Empty != null)
					{
						return result;
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public TsurgeonPattern NodeName()
		{
			/*@bgen(jjtree) NodeName */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjtnodename);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			Token t;
			try
			{
				t = Jj_consume_token(TsurgeonParserConstantsConstants.Identifier);
				jjtree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				{
					if (string.Empty != null)
					{
						return new FetchNode(t.image);
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public IList<AuxiliaryTree> TreeList(bool requiresFoot)
		{
			/*@bgen(jjtree) TreeList */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjttreelist);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			IList<AuxiliaryTree> trees = Generics.NewArrayList();
			AuxiliaryTree tree;
			try
			{
				tree = TreeRoot(requiresFoot);
				trees.Add(tree);
				while (true)
				{
					switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
					{
						case TsurgeonParserConstantsConstants.Identifier:
						case TsurgeonParserConstantsConstants.TreeNodeTerminalLabel:
						case TsurgeonParserConstantsConstants.TreeNodeNonterminalLabel:
						{
							break;
						}

						default:
						{
							jj_la1[7] = jj_gen;
							goto label_3_break;
						}
					}
					tree = TreeRoot(requiresFoot);
					trees.Add(tree);
label_3_continue: ;
				}
label_3_break: ;
				jjtree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				{
					if (string.Empty != null)
					{
						return trees;
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		// the argument says whether there must be a foot node on the aux tree.
		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public AuxiliaryTree TreeRoot(bool requiresFoot)
		{
			/*@bgen(jjtree) TreeRoot */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjttreeroot);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			Tree t;
			try
			{
				t = TreeNode();
				jjtree.CloseNodeScope(jjtn000, true);
				jjtc000 = false;
				{
					if (string.Empty != null)
					{
						return new AuxiliaryTree(t, requiresFoot);
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public Tree TreeNode()
		{
			/*@bgen(jjtree) TreeNode */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjttreenode);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			Token label;
			IList<Tree> dtrs = null;
			try
			{
				switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
				{
					case TsurgeonParserConstantsConstants.TreeNodeNonterminalLabel:
					{
						label = Jj_consume_token(TsurgeonParserConstantsConstants.TreeNodeNonterminalLabel);
						dtrs = TreeDtrs(new List<Tree>());
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return treeFactory.NewTreeNode(Sharpen.Runtime.Substring(label.image, 1), dtrs);
							}
						}
						break;
					}

					case TsurgeonParserConstantsConstants.TreeNodeTerminalLabel:
					{
						label = Jj_consume_token(TsurgeonParserConstantsConstants.TreeNodeTerminalLabel);
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return treeFactory.NewTreeNode(label.image, new List<Tree>());
							}
						}
						break;
					}

					case TsurgeonParserConstantsConstants.Identifier:
					{
						label = Jj_consume_token(TsurgeonParserConstantsConstants.Identifier);
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return treeFactory.NewTreeNode(label.image, new List<Tree>());
							}
						}
						break;
					}

					default:
					{
						jj_la1[8] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		public IList<Tree> TreeDtrs(IList<Tree> dtrs)
		{
			/*@bgen(jjtree) TreeDtrs */
			SimpleNode jjtn000 = new SimpleNode(TsurgeonParserTreeConstantsConstants.Jjttreedtrs);
			bool jjtc000 = true;
			jjtree.OpenNodeScope(jjtn000);
			Tree tree;
			try
			{
				switch ((jj_ntk == -1) ? Jj_ntk_f() : jj_ntk)
				{
					case TsurgeonParserConstantsConstants.Identifier:
					case TsurgeonParserConstantsConstants.TreeNodeTerminalLabel:
					case TsurgeonParserConstantsConstants.TreeNodeNonterminalLabel:
					{
						tree = TreeNode();
						TreeDtrs(dtrs);
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						dtrs.Add(0, tree);
						{
							if (string.Empty != null)
							{
								return dtrs;
							}
						}
						break;
					}

					case TsurgeonParserConstantsConstants.CloseParen:
					{
						Jj_consume_token(TsurgeonParserConstantsConstants.CloseParen);
						jjtree.CloseNodeScope(jjtn000, true);
						jjtc000 = false;
						{
							if (string.Empty != null)
							{
								return dtrs;
							}
						}
						break;
					}

					default:
					{
						jj_la1[9] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
			}
			catch (Exception jjte000)
			{
				if (jjtc000)
				{
					jjtree.ClearNodeScope(jjtn000);
					jjtc000 = false;
				}
				else
				{
					jjtree.PopNode();
				}
				if (jjte000 is Exception)
				{
					{
						if (true)
						{
							throw (Exception)jjte000;
						}
					}
				}
				if (jjte000 is ParseException)
				{
					{
						if (true)
						{
							throw (ParseException)jjte000;
						}
					}
				}
				{
					if (true)
					{
						throw (Exception)jjte000;
					}
				}
			}
			finally
			{
				if (jjtc000)
				{
					jjtree.CloseNodeScope(jjtn000, true);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		private bool Jj_2_1(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_1();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(0, xla);
			}
		}

		private bool Jj_2_2(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_2();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(1, xla);
			}
		}

		private bool Jj_2_3(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_3();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(2, xla);
			}
		}

		private bool Jj_2_4(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_4();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(3, xla);
			}
		}

		private bool Jj_2_5(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_5();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(4, xla);
			}
		}

		private bool Jj_2_6(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_6();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(5, xla);
			}
		}

		private bool Jj_2_7(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_7();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(6, xla);
			}
		}

		private bool Jj_2_8(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_8();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(7, xla);
			}
		}

		private bool Jj_2_9(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_9();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(8, xla);
			}
		}

		private bool Jj_2_10(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_10();
			}
			catch (TsurgeonParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(9, xla);
			}
		}

		private bool Jj_3R_15()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.CloseParen))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_8()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Identifier))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_14()
		{
			if (Jj_3R_9())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_13()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_14())
			{
				jj_scanpos = xsp;
				if (Jj_3R_15())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_4()
		{
			if (Jj_3R_8())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_12()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Identifier))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_10()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Insert))
			{
				return true;
			}
			if (Jj_3R_7())
			{
				return true;
			}
			if (Jj_3R_6())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_11()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.TreeNodeTerminalLabel))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_9()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Insert))
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			if (Jj_3R_6())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_9()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_10())
			{
				jj_scanpos = xsp;
				if (Jj_3R_11())
				{
					jj_scanpos = xsp;
					if (Jj_3R_12())
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3R_10()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.TreeNodeNonterminalLabel))
			{
				return true;
			}
			if (Jj_3R_13())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_8()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Replace))
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			if (Jj_3R_5())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_7()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Replace))
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_7()
		{
			if (Jj_3R_9())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_2()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.If))
			{
				return true;
			}
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Not))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_6()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Relabel))
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			if (Jj_scan_token(TsurgeonParserConstantsConstants.GeneralRelabel))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_1()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.If))
			{
				return true;
			}
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Exists))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_5()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Relabel))
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Regex))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_4()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Relabel))
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Quotex))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_6()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.LocationRelation))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_3()
		{
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Relabel))
			{
				return true;
			}
			if (Jj_3R_4())
			{
				return true;
			}
			if (Jj_scan_token(TsurgeonParserConstantsConstants.Identifier))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_5()
		{
			if (Jj_3R_7())
			{
				return true;
			}
			return false;
		}

		/// <summary>Generated Token Manager.</summary>
		public TsurgeonParserTokenManager token_source;

		internal SimpleCharStream jj_input_stream;

		/// <summary>Current token.</summary>
		public Token token;

		/// <summary>Next token.</summary>
		public Token jj_nt;

		private int jj_ntk;

		private Token jj_scanpos;

		private Token jj_lastpos;

		private int jj_la;

		private int jj_gen;

		private readonly int[] jj_la1 = new int[10];

		private static int[] jj_la1_0;

		private static int[] jj_la1_1;

		static TsurgeonParser()
		{
			Jj_la1_init_0();
			Jj_la1_init_1();
		}

		private static void Jj_la1_init_0()
		{
			jj_la1_0 = new int[] { unchecked((int)(0x20)), unchecked((int)(0x1ffe00)), unchecked((int)(0x20)), unchecked((int)(0x1600)), unchecked((int)(0x4000)), unchecked((int)(0x1f0000)), unchecked((int)(0x2000000)), unchecked((int)(0xc2000000)), unchecked(
				(int)(0xc2000000)), unchecked((int)(0xc2000000)) };
		}

		private static void Jj_la1_init_1()
		{
			jj_la1_1 = new int[] { unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((
				int)(0x1)) };
		}

		private readonly TsurgeonParser.JJCalls[] jj_2_rtns = new TsurgeonParser.JJCalls[10];

		private bool jj_rescan = false;

		private int jj_gc = 0;

		/// <summary>Constructor with InputStream.</summary>
		public TsurgeonParser(InputStream stream)
			: this(stream, null)
		{
		}

		/// <summary>Constructor with InputStream and supplied encoding</summary>
		public TsurgeonParser(InputStream stream, string encoding)
		{
			try
			{
				jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
			}
			catch (UnsupportedEncodingException e)
			{
				throw new Exception(e);
			}
			token_source = new TsurgeonParserTokenManager(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 10; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TsurgeonParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(InputStream stream)
		{
			ReInit(stream, null);
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(InputStream stream, string encoding)
		{
			try
			{
				jj_input_stream.ReInit(stream, encoding, 1, 1);
			}
			catch (UnsupportedEncodingException e)
			{
				throw new Exception(e);
			}
			token_source.ReInit(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jjtree.Reset();
			jj_gen = 0;
			for (int i = 0; i < 10; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TsurgeonParser.JJCalls();
			}
		}

		/// <summary>Constructor.</summary>
		public TsurgeonParser(Reader stream)
		{
			jj_input_stream = new SimpleCharStream(stream, 1, 1);
			token_source = new TsurgeonParserTokenManager(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 10; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TsurgeonParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(Reader stream)
		{
			jj_input_stream.ReInit(stream, 1, 1);
			token_source.ReInit(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jjtree.Reset();
			jj_gen = 0;
			for (int i = 0; i < 10; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TsurgeonParser.JJCalls();
			}
		}

		/// <summary>Constructor with generated Token Manager.</summary>
		public TsurgeonParser(TsurgeonParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 10; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TsurgeonParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(TsurgeonParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk = -1;
			jjtree.Reset();
			jj_gen = 0;
			for (int i = 0; i < 10; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TsurgeonParser.JJCalls();
			}
		}

		/// <exception cref="Edu.Stanford.Nlp.Trees.Tregex.Tsurgeon.ParseException"/>
		private Token Jj_consume_token(int kind)
		{
			Token oldToken;
			if ((oldToken = token).next != null)
			{
				token = token.next;
			}
			else
			{
				token = token.next = token_source.GetNextToken();
			}
			jj_ntk = -1;
			if (token.kind == kind)
			{
				jj_gen++;
				if (++jj_gc > 100)
				{
					jj_gc = 0;
					foreach (TsurgeonParser.JJCalls jj_2_rtn in jj_2_rtns)
					{
						TsurgeonParser.JJCalls c = jj_2_rtn;
						while (c != null)
						{
							if (c.gen < jj_gen)
							{
								c.first = null;
							}
							c = c.next;
						}
					}
				}
				return token;
			}
			token = oldToken;
			jj_kind = kind;
			throw GenerateParseException();
		}

		[System.Serializable]
		private sealed class LookaheadSuccess : Exception
		{
		}

		private readonly TsurgeonParser.LookaheadSuccess jj_ls = new TsurgeonParser.LookaheadSuccess();

		private bool Jj_scan_token(int kind)
		{
			if (jj_scanpos == jj_lastpos)
			{
				jj_la--;
				if (jj_scanpos.next == null)
				{
					jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.GetNextToken();
				}
				else
				{
					jj_lastpos = jj_scanpos = jj_scanpos.next;
				}
			}
			else
			{
				jj_scanpos = jj_scanpos.next;
			}
			if (jj_rescan)
			{
				int i = 0;
				Token tok = token;
				while (tok != null && tok != jj_scanpos)
				{
					i++;
					tok = tok.next;
				}
				if (tok != null)
				{
					Jj_add_error_token(kind, i);
				}
			}
			if (jj_scanpos.kind != kind)
			{
				return true;
			}
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
			{
				throw jj_ls;
			}
			return false;
		}

		/// <summary>Get the next Token.</summary>
		public Token GetNextToken()
		{
			if (token.next != null)
			{
				token = token.next;
			}
			else
			{
				token = token.next = token_source.GetNextToken();
			}
			jj_ntk = -1;
			jj_gen++;
			return token;
		}

		/// <summary>Get the specific Token.</summary>
		public Token GetToken(int index)
		{
			Token t = token;
			for (int i = 0; i < index; i++)
			{
				if (t.next != null)
				{
					t = t.next;
				}
				else
				{
					t = t.next = token_source.GetNextToken();
				}
			}
			return t;
		}

		private int Jj_ntk_f()
		{
			if ((jj_nt = token.next) == null)
			{
				return (jj_ntk = (token.next = token_source.GetNextToken()).kind);
			}
			else
			{
				return (jj_ntk = jj_nt.kind);
			}
		}

		private IList<int[]> jj_expentries = new List<int[]>();

		private int[] jj_expentry;

		private int jj_kind = -1;

		private int[] jj_lasttokens = new int[100];

		private int jj_endpos;

		private void Jj_add_error_token(int kind, int pos)
		{
			if (pos >= 100)
			{
				return;
			}
			if (pos == jj_endpos + 1)
			{
				jj_lasttokens[jj_endpos++] = kind;
			}
			else
			{
				if (jj_endpos != 0)
				{
					jj_expentry = new int[jj_endpos];
					for (int i = 0; i < jj_endpos; i++)
					{
						jj_expentry[i] = jj_lasttokens[i];
					}
					foreach (int[] jj_expentry1 in jj_expentries)
					{
						int[] oldentry = (int[])(jj_expentry1);
						if (oldentry.Length == jj_expentry.Length)
						{
							for (int i_1 = 0; i_1 < jj_expentry.Length; i_1++)
							{
								if (oldentry[i_1] != jj_expentry[i_1])
								{
									goto jj_entries_loop_continue;
								}
							}
							jj_expentries.Add(jj_expentry);
							goto jj_entries_loop_break;
						}
					}
jj_entries_loop_break: ;
					if (pos != 0)
					{
						jj_lasttokens[(jj_endpos = pos) - 1] = kind;
					}
				}
			}
		}

		/// <summary>Generate ParseException.</summary>
		public virtual ParseException GenerateParseException()
		{
			jj_expentries.Clear();
			bool[] la1tokens = new bool[33];
			if (jj_kind >= 0)
			{
				la1tokens[jj_kind] = true;
				jj_kind = -1;
			}
			for (int i = 0; i < 10; i++)
			{
				if (jj_la1[i] == jj_gen)
				{
					for (int j = 0; j < 32; j++)
					{
						if ((jj_la1_0[i] & (1 << j)) != 0)
						{
							la1tokens[j] = true;
						}
						if ((jj_la1_1[i] & (1 << j)) != 0)
						{
							la1tokens[32 + j] = true;
						}
					}
				}
			}
			for (int i_1 = 0; i_1 < 33; i_1++)
			{
				if (la1tokens[i_1])
				{
					jj_expentry = new int[1];
					jj_expentry[0] = i_1;
					jj_expentries.Add(jj_expentry);
				}
			}
			jj_endpos = 0;
			Jj_rescan_token();
			Jj_add_error_token(0, 0);
			int[][] exptokseq = new int[jj_expentries.Count][];
			for (int i_2 = 0; i_2 < jj_expentries.Count; i_2++)
			{
				exptokseq[i_2] = jj_expentries[i_2];
			}
			return new ParseException(token, exptokseq, TsurgeonParserConstantsConstants.tokenImage);
		}

		/// <summary>Enable tracing.</summary>
		public void Enable_tracing()
		{
		}

		/// <summary>Disable tracing.</summary>
		public void Disable_tracing()
		{
		}

		private void Jj_rescan_token()
		{
			jj_rescan = true;
			for (int i = 0; i < 10; i++)
			{
				try
				{
					TsurgeonParser.JJCalls p = jj_2_rtns[i];
					do
					{
						if (p.gen > jj_gen)
						{
							jj_la = p.arg;
							jj_lastpos = jj_scanpos = p.first;
							switch (i)
							{
								case 0:
								{
									Jj_3_1();
									break;
								}

								case 1:
								{
									Jj_3_2();
									break;
								}

								case 2:
								{
									Jj_3_3();
									break;
								}

								case 3:
								{
									Jj_3_4();
									break;
								}

								case 4:
								{
									Jj_3_5();
									break;
								}

								case 5:
								{
									Jj_3_6();
									break;
								}

								case 6:
								{
									Jj_3_7();
									break;
								}

								case 7:
								{
									Jj_3_8();
									break;
								}

								case 8:
								{
									Jj_3_9();
									break;
								}

								case 9:
								{
									Jj_3_10();
									break;
								}
							}
						}
						p = p.next;
					}
					while (p != null);
				}
				catch (TsurgeonParser.LookaheadSuccess)
				{
				}
			}
			jj_rescan = false;
		}

		private void Jj_save(int index, int xla)
		{
			TsurgeonParser.JJCalls p = jj_2_rtns[index];
			while (p.gen > jj_gen)
			{
				if (p.next == null)
				{
					p = p.next = new TsurgeonParser.JJCalls();
					break;
				}
				p = p.next;
			}
			p.gen = jj_gen + xla - jj_la;
			p.first = token;
			p.arg = xla;
		}

		internal sealed class JJCalls
		{
			internal int gen;

			internal Token first;

			internal int arg;

			internal TsurgeonParser.JJCalls next;
		}
	}
}
