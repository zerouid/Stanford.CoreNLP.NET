/* The following code was generated by JFlex 1.5.1 */
using System;



namespace Edu.Stanford.Nlp.Trees.International.Pennchinese
{
	/// <summary>A lexer for the Penn Chinese Treebank.</summary>
	/// <remarks>A lexer for the Penn Chinese Treebank.  Supports Chinese characters.</remarks>
	/// <author>Roger Levy</author>
	/// <author>Christopher Manning (fully redid to accept most stuff, add CTB 4-9 XML entities)</author>
	internal class CHTBLexer
	{
		/// <summary>This character denotes the end of file</summary>
		public const int Yyeof = -1;

		/// <summary>initial size of the lookahead buffer</summary>
		private const int ZzBuffersize = 16384;

		/// <summary>lexical states</summary>
		public const int Yyinitial = 0;

		/// <summary>
		/// ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
		/// ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
		/// at the beginning of a line
		/// l is of the form l = 2*k, k a non negative integer
		/// </summary>
		private static readonly int[] ZzLexstate = new int[] { 0, 0 };

		/// <summary>Translates characters to character classes</summary>
		private const string ZzCmapPacked = "\xb\x0\x1\x7\x1\x2\x1\x6\x1\x6\x1\x5\x16\x0\x1\x7\x7\x0\x1\x4" + "\x1\x4\x5\x0\x1\x18\xe\x0\x1\x1\x1\x0\x1\x3\x2\x0\x1\x15\x1\x1b" + "\x1\xc\x1\xa\x1\x10\x3\x0\x1\x14\x3\x0\x1\x16\x1\x11\x1\xb\x1\xf" + "\x1\x0\x1\x1a\x1\x19\x1\xd\x4\x0\x1\xe\x5\x0\x1\x17\x2d\x0\x1\x6"
			 + "\u1fa2\x0\x1\x6\x1\x6\udfd6\x0";

		/// <summary>Translates characters to character classes</summary>
		private static readonly char[] ZzCmap = ZzUnpackCMap(ZzCmapPacked);

		/// <summary>Translates DFA states to action switch labels.</summary>
		private static readonly int[] ZzAction = ZzUnpackAction();

		private const string ZzActionPacked0 = "\x1\x0\x2\x1\x1\x2\x1\x1\x2\x2\x1\x1\x1\x0\x4\x1" + "\x2\x3\x15\x1\x1\x3\x1\x0\x3\x1\x3\x0\x1\x1\x1\x0" + "\x1\x3\x1\x0\x1\x1\x1\x0\x4\x1\x4\x0\x5\x1\x5\x0" + "\x4\x1\x4\x0\x6\x1\x6\x0\x3\x1\x3\x0\x1\x1\x1\x0";

		private static int[] ZzUnpackAction()
		{
			int[] result = new int[92];
			int offset = 0;
			offset = ZzUnpackAction(ZzActionPacked0, offset, result);
			return result;
		}

		private static int ZzUnpackAction(string packed, int offset, int[] result)
		{
			int i = 0;
			/* index in packed string  */
			int j = offset;
			/* index in unpacked array */
			int l = packed.Length;
			while (i < l)
			{
				int count = packed[i++];
				int value = packed[i++];
				do
				{
					result[j++] = value;
				}
				while (--count > 0);
			}
			return j;
		}

		/// <summary>Translates a state to a row index in the transition table</summary>
		private static readonly int[] ZzRowmap = ZzUnpackRowMap();

		private const string ZzRowmapPacked0 = "\x0\x0\x0\x1e\x0\x3c\x0\x6e\x0\x6e\x0\x8c\x0\xaa\x0\xdc" + "\x0\xfa\x0\x12c\x0\x14a\x0\x168\x0\u0108\x0\x1e\x0\x6e\x0\u0120" + "\x0\u0138\x0\u0150\x0\u0168\x0\u0180\x0\u0198\x0\u01b0\x0\u01c8\x0\u01e0"
			 + "\x0\u01f8\x0\u0210\x0\u0228\x0\u0240\x0\u0258\x0\u0270\x0\u0288\x0\u02a0" + "\x0\u02b8\x0\u02d0\x0\u02e8\x0\u0300\x0\u0318\x0\u0330\x0\u0348\x0\u0360" + "\x0\u0378\x0\u0390\x0\u03a8\x0\u03a8\x0\u03c0\x0\u03d8\x0\u03f0\x0\u0408" + "\x0\u0420\x0\u0438\x0\u0450\x0\u0468\x0\u0480\x0\u0498\x0\u04b0\x0\u04c8"
			 + "\x0\u04e0\x0\u04f8\x0\u0510\x0\u0528\x0\u0540\x0\u0558\x0\u0570\x0\u0588" + "\x0\u05a0\x0\u05b8\x0\u05d0\x0\u05e8\x0\u0600\x0\u0618\x0\u0630\x0\u0648" + "\x0\u0660\x0\u0678\x0\u0690\x0\u06a8\x0\u06c0\x0\u06d8\x0\u06f0\x0\u0708" + "\x0\u0720\x0\u0738\x0\u0750\x0\u0768\x0\u0780\x0\u0798\x0\u07b0\x0\u07c8"
			 + "\x0\u07e0\x0\u07f8\x0\u0810\x0\u0828";

		private static int[] ZzUnpackRowMap()
		{
			int[] result = new int[92];
			int offset = 0;
			offset = ZzUnpackRowMap(ZzRowmapPacked0, offset, result);
			return result;
		}

		private static int ZzUnpackRowMap(string packed, int offset, int[] result)
		{
			int i = 0;
			/* index in packed string  */
			int j = offset;
			/* index in unpacked array */
			int l = packed.Length;
			while (i < l)
			{
				int high = packed[i++] << 16;
				result[j++] = high | packed[i++];
			}
			return j;
		}

		/// <summary>The transition table of the DFA</summary>
		private static readonly int[] ZzTrans = ZzUnpackTrans();

		private const string ZzTransPacked0 = "\x1\x2\x1\x3\x1\x4\x1\x2\x1\x5\x1\x6\x1\x4\x1\x7" + "\x16\x2\x1\x0\x1\x2\x4\x0\x14\x2\x2\xa\x1\x0\x1\x2" + "\x1\xb\x1\x0\x2\xb\x1\xc\x1\xa\x1\xd\x3\xa\x1\xe" + "\x6\xa\x1\xf\x2\xa\x20\x0\x1\x4\x22\x0\x1\x7\x14\x0"
			 + "\x2\xa\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x14\xa\x2\xb" + "\x1\x0\x1\x11\x1\xb\x1\x0\x16\xb\x2\xa\x1\x0\x1\x10" + "\x1\xb\x1\x0\x2\xb\x1\xa\x1\x14\x7\xa\x1\x15\xa\xa" + "\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x3\xa\x1\x16\x10\xa" + "\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x7\xa\x1\x17\xc\xa"
			 + "\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x10\xa\x1\x18\x3\xa" + "\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x2\xa\x1\x19\x11\xa" + "\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x3\xa\x1\x1a\x10\xa" + "\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x11\xa\x1\x1b\x2\xa" + "\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x1\x1e\x15\xa\x1\x0"
			 + "\x1\x10\x1\xb\x1\x0\x2\xb\x2\xa\x1\x1b\x11\xa\x1\x0" + "\x1\x10\x1\xb\x1\x0\x2\xb\x3\xa\x1\x1f\x3\xa\x1\x20" + "\x1\x21\xb\xa\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x6\xa" + "\x1\x22\xd\xa\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\xa\xa" + "\x1\x21\xb\xa\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x3\xa"
			 + "\x1\x23\x7\xa\x1\x24\x6\xa\x1\x0\x1\x10\x1\xb\x1\x0" + "\x2\xb\x4\xa\x1\x25\xf\xa\x1\x0\x1\x10\x1\xb\x1\x0" + "\x2\xb\x1\xa\x1\x28\x14\xa\x1\x0\x1\x10\x1\xb\x1\x0" + "\x2\xb\x1\x28\x15\xa\x1\x0\x1\x29\x1\xb\x1\x0\x1\xb" + "\x1\x2a\x3\xa\x1\x23\x7\xa\x2\x24\x5\xa\x1\x0\x1\x10"
			 + "\x1\xb\x1\x0\x2\xb\xa\xa\x1\x2b\xb\xa\x1\x0\x1\x10" + "\x1\xb\x1\x0\x2\xb\x3\xa\x1\x23\x10\xa\x1\x0\x1\x10" + "\x1\xb\x1\x0\x2\xb\x5\xa\x1\x2c\xe\xa\x1\x0\x1\x29" + "\x1\xb\x1\x0\x1\xb\x1\x2a\x14\xa\x1\x2d\x1\x2\x1\x2e" + "\x1\x2d\x4\x2e\x14\x2d\x2\x2f\x1\x32\x1\x11\x1\x2f\x1\x32"
			 + "\x16\x2f\x2\xa\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\xc\xa" + "\x1\x2c\x7\xa\x1\x0\x1\x10\x1\xb\x1\x0\x2\xb\x6\xa" + "\x1\x28\xb\xa\x1\x2d\x1\x33\x1\x2e\x1\x2d\x4\x2e\x14\x2d" + "\x1\x2e\x1\x34\x1a\x2e\x2\x2f\x1\x32\x1\x35\x1\x2f\x1\x32" + "\x16\x2f\x3\x32\x1\x36\x18\x32\x2\x2\x1\x0\x1\x2\x4\x0"
			 + "\xe\x2\x1\x37\x3\x2\x18\x0\x1\x38\x3\x0\x1\x2e\x1\x0" + "\x1a\x2e\x2\x2\x1\x0\x1\x2\x4\x0\x1\x39\x1\x2\x1\x3c" + "\x3\x2\x1\x3d\x6\x2\x1\x3e\x2\x2\xa\x0\x1\x3f\x1\x0" + "\x1\x40\x3\x0\x1\x41\x6\x0\x1\x42\x2\x0\x2\x2\x1\x0" + "\x1\x2\x4\x0\x1\x2\x1\x43\x7\x2\x1\x46\xa\x2\x1\x0"
			 + "\x1\x2\x4\x0\x3\x2\x1\x47\x10\x2\x1\x0\x1\x2\x4\x0" + "\x7\x2\x1\x48\xc\x2\x1\x0\x1\x2\x4\x0\x10\x2\x1\x49" + "\x1\x2\xb\x0\x1\x4a\x7\x0\x1\x4b\x15\x0\x1\x4c\x21\x0" + "\x1\x4d\x24\x0\x1\x64\x1\x0\x2\x2\x1\x0\x1\x2\x4\x0" + "\x2\x2\x1\x65\x11\x2\x1\x0\x1\x2\x4\x0\x3\x2\x1\x66"
			 + "\x10\x2\x1\x0\x1\x2\x4\x0\x11\x2\x1\x67\x2\x2\x1\x0" + "\x1\x2\x4\x0\x1\x68\x15\x2\x1\x0\x1\x2\x4\x0\x2\x2" + "\x1\x67\xf\x2\xc\x0\x1\x69\x1e\x0\x1\x6a\x2b\x0\x1\x6b" + "\xa\x0\x1\x6e\x1f\x0\x1\x6b\xf\x0\x2\x2\x1\x0\x1\x2" + "\x4\x0\x3\x2\x1\x6f\x3\x2\x1\x70\x1\x71\xb\x2\x1\x0"
			 + "\x1\x2\x4\x0\x6\x2\x1\x72\xd\x2\x1\x0\x1\x2\x4\x0" + "\xa\x2\x1\x71\xb\x2\x1\x0\x1\x2\x4\x0\x3\x2\x1\x73" + "\x7\x2\x1\x74\x4\x2\xd\x0\x1\x75\x3\x0\x1\x78\x1\x79" + "\x19\x0\x1\x7a\x1f\x0\x1\x79\x16\x0\x1\x7b\x7\x0\x1\x7c" + "\x4\x0\x2\x2\x1\x0\x1\x2\x4\x0\x4\x2\x1\x7d\xf\x2"
			 + "\x1\x0\x1\x2\x4\x0\x1\x2\x1\x7e\x14\x2\x1\x0\x1\x2" + "\x4\x0\x1\x7e\x15\x2\x1\x0\x1\x10\x4\x0\x3\x2\x1\x73" + "\x7\x2\x2\x74\x5\x2\x1\x0\x1\x2\x4\x0\xa\x2\x1\x7f" + "\xb\x2\x1\x0\x1\x2\x4\x0\x3\x2\x1\x73\xe\x2\xe\x0" + "\x1\x82\x18\x0\x1\x83\x1a\x0\x1\x83\x16\x0\x1\x11\x7\x0"
			 + "\x1\x7b\x7\x0\x2\x7c\x17\x0\x1\x84\x16\x0\x1\x7b\xe\x0" + "\x2\x2\x1\x0\x1\x2\x4\x0\x5\x2\x1\x85\xe\x2\x1\x0" + "\x1\x10\x4\x0\x16\x2\x1\x0\x1\x2\x4\x0\xc\x2\x1\x85" + "\x5\x2\xf\x0\x1\x86\xf\x0\x1\x11\x2e\x0\x1\x86\x5\x0" + "\x2\x2\x1\x0\x1\x2\x4\x0\x6\x2\x1\x7e\xb\x2\x10\x0"
			 + "\x1\x83\xb\x0";

		private static int[] ZzUnpackTrans()
		{
			int[] result = new int[2112];
			int offset = 0;
			offset = ZzUnpackTrans(ZzTransPacked0, offset, result);
			return result;
		}

		private static int ZzUnpackTrans(string packed, int offset, int[] result)
		{
			int i = 0;
			/* index in packed string  */
			int j = offset;
			/* index in unpacked array */
			int l = packed.Length;
			while (i < l)
			{
				int count = packed[i++];
				int value = packed[i++];
				value--;
				do
				{
					result[j++] = value;
				}
				while (--count > 0);
			}
			return j;
		}

		private const int ZzUnknownError = 0;

		private const int ZzNoMatch = 1;

		private const int ZzPushback2big = 2;

		private static readonly string[] ZzErrorMsg = new string[] { "Unkown internal scanner error", "Error: could not match input", "Error: pushback value was too large" };

		/// <summary>ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code></summary>
		private static readonly int[] ZzAttribute = ZzUnpackAttribute();

		private const string ZzAttributePacked0 = "\x1\x0\x2\x1\x2\xb\x3\x1\x1\x0\x5\x1\x1\xb\x16\x1" + "\x1\x0\x3\x1\x3\x0\x1\x1\x1\x0\x1\x1\x1\x0\x1\x1" + "\x1\x0\x4\x1\x4\x0\x5\x1\x5\x0\x4\x1\x4\x0\x6\x1" + "\x6\x0\x3\x1\x3\x0\x1\x1\x1\x0";

		/* error codes */
		/* error messages for the codes above */
		private static int[] ZzUnpackAttribute()
		{
			int[] result = new int[92];
			int offset = 0;
			offset = ZzUnpackAttribute(ZzAttributePacked0, offset, result);
			return result;
		}

		private static int ZzUnpackAttribute(string packed, int offset, int[] result)
		{
			int i = 0;
			/* index in packed string  */
			int j = offset;
			/* index in unpacked array */
			int l = packed.Length;
			while (i < l)
			{
				int count = packed[i++];
				int value = packed[i++];
				do
				{
					result[j++] = value;
				}
				while (--count > 0);
			}
			return j;
		}

		/// <summary>the input device</summary>
		private Reader zzReader;

		/// <summary>the current state of the DFA</summary>
		private int zzState;

		/// <summary>the current lexical state</summary>
		private int zzLexicalState = Yyinitial;

		/// <summary>
		/// this buffer contains the current text to be matched and is
		/// the source of the yytext() string
		/// </summary>
		private char[] zzBuffer = new char[ZzBuffersize];

		/// <summary>the textposition at the last accepting state</summary>
		private int zzMarkedPos;

		/// <summary>the current text position in the buffer</summary>
		private int zzCurrentPos;

		/// <summary>startRead marks the beginning of the yytext() string in the buffer</summary>
		private int zzStartRead;

		/// <summary>
		/// endRead marks the last character in the buffer, that has been read
		/// from input
		/// </summary>
		private int zzEndRead;

		/// <summary>number of newlines encountered up to the start of the matched text</summary>
		private int yyline;

		/// <summary>the number of characters up to the start of the matched text</summary>
		private int yychar;

		/// <summary>
		/// the number of characters from the last newline up to the start of the
		/// matched text
		/// </summary>
		private int yycolumn;

		/// <summary>zzAtBOL == true <=> the scanner is currently at the beginning of a line</summary>
		private bool zzAtBOL = true;

		/// <summary>zzAtEOF == true <=> the scanner is at the EOF</summary>
		private bool zzAtEOF;

		/// <summary>denotes if the user-EOF-code has already been executed</summary>
		private bool zzEOFDone;

		private const bool Dbg = false;

		public const int Ignore = 0;

		public const int Accept = 1;

		/* user code: */
		public virtual string Match()
		{
			return Yytext();
		}

		private static void ReportError(string yytext)
		{
			try
			{
				PrintWriter p = new PrintWriter(new OutputStreamWriter(System.Console.Error, "utf-8"), true);
				p.Println("chtbl.flex tokenization error: \"" + yytext + "\"");
				if (yytext.Length >= 1)
				{
					p.Println("First character is: " + yytext[0]);
					if (yytext.Length >= 2)
					{
						p.Println("Second character is: " + yytext[1]);
					}
				}
			}
			catch (UnsupportedEncodingException)
			{
				System.Console.Error.WriteLine("chtbl.flex tokenization and encoding present error");
			}
		}

		/// <summary>
		/// Creates a new scanner
		/// There is also a java.io.InputStream version of this constructor.
		/// </summary>
		/// <param name="in">the java.io.Reader to read input from.</param>
		internal CHTBLexer(Reader @in)
		{
			this.zzReader = @in;
		}

		/// <summary>Creates a new scanner.</summary>
		/// <remarks>
		/// Creates a new scanner.
		/// There is also java.io.Reader version of this constructor.
		/// </remarks>
		/// <param name="in">the java.io.Inputstream to read input from.</param>
		internal CHTBLexer(InputStream @in)
			: this(new InputStreamReader(@in, Java.Nio.Charset.Charset.ForName("UTF-8")))
		{
		}

		/// <summary>Unpacks the compressed character translation table.</summary>
		/// <param name="packed">the packed character translation table</param>
		/// <returns>the unpacked character translation table</returns>
		private static char[] ZzUnpackCMap(string packed)
		{
			char[] map = new char[unchecked((int)(0x10000))];
			int i = 0;
			/* index in packed string  */
			int j = 0;
			/* index in unpacked array */
			while (i < 88)
			{
				int count = packed[i++];
				char value = packed[i++];
				do
				{
					map[j++] = value;
				}
				while (--count > 0);
			}
			return map;
		}

		/// <summary>Refills the input buffer.</summary>
		/// <returns><code>false</code>, iff there was new input.</returns>
		/// <exception>
		/// java.io.IOException
		/// if any I/O-Error occurs
		/// </exception>
		/// <exception cref="System.IO.IOException"/>
		private bool ZzRefill()
		{
			/* first: make room (if you can) */
			if (zzStartRead > 0)
			{
				System.Array.Copy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead - zzStartRead);
				/* translate stored positions */
				zzEndRead -= zzStartRead;
				zzCurrentPos -= zzStartRead;
				zzMarkedPos -= zzStartRead;
				zzStartRead = 0;
			}
			/* is the buffer big enough? */
			if (zzCurrentPos >= zzBuffer.Length)
			{
				/* if not: blow it up */
				char[] newBuffer = new char[zzCurrentPos * 2];
				System.Array.Copy(zzBuffer, 0, newBuffer, 0, zzBuffer.Length);
				zzBuffer = newBuffer;
			}
			/* finally: fill the buffer with new input */
			int numRead = zzReader.Read(zzBuffer, zzEndRead, zzBuffer.Length - zzEndRead);
			if (numRead > 0)
			{
				zzEndRead += numRead;
				return false;
			}
			// unlikely but not impossible: read 0 characters, but not at end of stream    
			if (numRead == 0)
			{
				int c = zzReader.Read();
				if (c == -1)
				{
					return true;
				}
				else
				{
					zzBuffer[zzEndRead++] = (char)c;
					return false;
				}
			}
			// numRead < 0
			return true;
		}

		/// <summary>Closes the input stream.</summary>
		/// <exception cref="System.IO.IOException"/>
		public void Yyclose()
		{
			zzAtEOF = true;
			/* indicate end of file */
			zzEndRead = zzStartRead;
			/* invalidate buffer    */
			if (zzReader != null)
			{
				zzReader.Close();
			}
		}

		/// <summary>Resets the scanner to read from a new input stream.</summary>
		/// <remarks>
		/// Resets the scanner to read from a new input stream.
		/// Does not close the old reader.
		/// All internal variables are reset, the old input stream
		/// <b>cannot</b> be reused (internal buffer is discarded and lost).
		/// Lexical state is set to <tt>ZZ_INITIAL</tt>.
		/// Internal scan buffer is resized down to its initial length, if it has grown.
		/// </remarks>
		/// <param name="reader">the new input stream</param>
		public void Yyreset(Reader reader)
		{
			zzReader = reader;
			zzAtBOL = true;
			zzAtEOF = false;
			zzEOFDone = false;
			zzEndRead = zzStartRead = 0;
			zzCurrentPos = zzMarkedPos = 0;
			yyline = yychar = yycolumn = 0;
			zzLexicalState = Yyinitial;
			if (zzBuffer.Length > ZzBuffersize)
			{
				zzBuffer = new char[ZzBuffersize];
			}
		}

		/// <summary>Returns the current lexical state.</summary>
		public int Yystate()
		{
			return zzLexicalState;
		}

		/// <summary>Enters a new lexical state</summary>
		/// <param name="newState">the new lexical state</param>
		public void Yybegin(int newState)
		{
			zzLexicalState = newState;
		}

		/// <summary>Returns the text matched by the current regular expression.</summary>
		public string Yytext()
		{
			return new string(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
		}

		/// <summary>
		/// Returns the character at position <tt>pos</tt> from the
		/// matched text.
		/// </summary>
		/// <remarks>
		/// Returns the character at position <tt>pos</tt> from the
		/// matched text.
		/// It is equivalent to yytext().charAt(pos), but faster
		/// </remarks>
		/// <param name="pos">
		/// the position of the character to fetch.
		/// A value from 0 to yylength()-1.
		/// </param>
		/// <returns>the character at position pos</returns>
		public char Yycharat(int pos)
		{
			return zzBuffer[zzStartRead + pos];
		}

		/// <summary>Returns the length of the matched text region.</summary>
		public int Yylength()
		{
			return zzMarkedPos - zzStartRead;
		}

		/// <summary>Reports an error that occured while scanning.</summary>
		/// <remarks>
		/// Reports an error that occured while scanning.
		/// In a wellformed scanner (no or only correct usage of
		/// yypushback(int) and a match-all fallback rule) this method
		/// will only be called with things that "Can't Possibly Happen".
		/// If this method is called, something is seriously wrong
		/// (e.g. a JFlex bug producing a faulty scanner etc.).
		/// Usual syntax/scanner level error handling should be done
		/// in error fallback rules.
		/// </remarks>
		/// <param name="errorCode">the code of the errormessage to display</param>
		private void ZzScanError(int errorCode)
		{
			string message;
			try
			{
				message = ZzErrorMsg[errorCode];
			}
			catch (IndexOutOfRangeException)
			{
				message = ZzErrorMsg[ZzUnknownError];
			}
			throw new Exception(message);
		}

		/// <summary>Pushes the specified amount of characters back into the input stream.</summary>
		/// <remarks>
		/// Pushes the specified amount of characters back into the input stream.
		/// They will be read again by then next call of the scanning method
		/// </remarks>
		/// <param name="number">
		/// the number of characters to be read again.
		/// This number must not be greater than yylength()!
		/// </param>
		public virtual void Yypushback(int number)
		{
			if (number > Yylength())
			{
				ZzScanError(ZzPushback2big);
			}
			zzMarkedPos -= number;
		}

		/// <summary>
		/// Resumes scanning until the next regular expression is matched,
		/// the end of input is encountered or an I/O-Error occurs.
		/// </summary>
		/// <returns>the next token</returns>
		/// <exception>
		/// java.io.IOException
		/// if any I/O-Error occurs
		/// </exception>
		/// <exception cref="System.IO.IOException"/>
		public virtual int Yylex()
		{
			int zzInput;
			int zzAction;
			// cached fields:
			int zzCurrentPosL;
			int zzMarkedPosL;
			int zzEndReadL = zzEndRead;
			char[] zzBufferL = zzBuffer;
			char[] zzCMapL = ZzCmap;
			int[] zzTransL = ZzTrans;
			int[] zzRowMapL = ZzRowmap;
			int[] zzAttrL = ZzAttribute;
			while (true)
			{
				zzMarkedPosL = zzMarkedPos;
				zzAction = -1;
				zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
				zzState = ZzLexstate[zzLexicalState];
				// set up zzAction for empty match case:
				int zzAttributes = zzAttrL[zzState];
				if ((zzAttributes & 1) == 1)
				{
					zzAction = zzState;
				}
				while (true)
				{
					if (zzCurrentPosL < zzEndReadL)
					{
						zzInput = zzBufferL[zzCurrentPosL++];
					}
					else
					{
						if (zzAtEOF)
						{
							zzInput = Yyeof;
							goto zzForAction_break;
						}
						else
						{
							// store back cached positions
							zzCurrentPos = zzCurrentPosL;
							zzMarkedPos = zzMarkedPosL;
							bool eof = ZzRefill();
							// get translated positions and possibly new buffer
							zzCurrentPosL = zzCurrentPos;
							zzMarkedPosL = zzMarkedPos;
							zzBufferL = zzBuffer;
							zzEndReadL = zzEndRead;
							if (eof)
							{
								zzInput = Yyeof;
								goto zzForAction_break;
							}
							else
							{
								zzInput = zzBufferL[zzCurrentPosL++];
							}
						}
					}
					int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
					if (zzNext == -1)
					{
						goto zzForAction_break;
					}
					zzState = zzNext;
					zzAttributes = zzAttrL[zzState];
					if ((zzAttributes & 1) == 1)
					{
						zzAction = zzState;
						zzMarkedPosL = zzCurrentPosL;
						if ((zzAttributes & 8) == 8)
						{
							goto zzForAction_break;
						}
					}
				}
zzForAction_break: ;
				// store back cached position
				zzMarkedPos = zzMarkedPosL;
				switch (zzAction < 0 ? zzAction : ZzAction[zzAction])
				{
					case 1:
					{
						return Accept;
					}

					case 4:
					{
						break;
					}

					case 2:
					{
						return Ignore;
					}

					case 5:
					{
						break;
					}

					case 3:
					{
						return Ignore;
					}

					case 6:
					{
						break;
					}

					default:
					{
						if (zzInput == Yyeof && zzStartRead == zzCurrentPos)
						{
							zzAtEOF = true;
							return Yyeof;
						}
						else
						{
							ZzScanError(ZzNoMatch);
						}
						break;
					}
				}
			}
		}
	}
}
