/* Generated By:JavaCC: Do not edit this line. TokenSequenceParser.java */
using System;
using System.Collections;
using System.Collections.Generic;
using Edu.Stanford.Nlp.Ling.Tokensregex;
using Edu.Stanford.Nlp.Ling.Tokensregex.Types;
using Edu.Stanford.Nlp.Util;




namespace Edu.Stanford.Nlp.Ling.Tokensregex.Parser
{
	public class TokenSequenceParser : SequencePattern.IParser<ICoreMap>, ITokenSequenceParserConstants
	{
		public TokenSequenceParser()
		{
		}

		// all generated classes are in this package
		//imports
		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParseException"/>
		public virtual CoreMapExpressionExtractor GetExpressionExtractor(Env env, Reader r)
		{
			try
			{
				Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser p = new Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser(r);
				IList<SequenceMatchRules.IRule> rules = p.RuleList(env);
				return new CoreMapExpressionExtractor(env, rules);
			}
			catch (TokenMgrError error)
			{
				throw new TokenSequenceParseException("Parsing failed. Error: " + error);
			}
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParseException"/>
		public virtual void UpdateExpressionExtractor(CoreMapExpressionExtractor extractor, Reader r)
		{
			try
			{
				Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser p = new Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser(r);
				IList<SequenceMatchRules.IRule> rules = p.RuleList(extractor.GetEnv());
				extractor.AppendRules(rules);
			}
			catch (TokenMgrError error)
			{
				throw new TokenSequenceParseException("Parsing failed. Error: " + error);
			}
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParseException"/>
		public virtual SequencePattern.PatternExpr ParseSequence(Env env, string s)
		{
			try
			{
				Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser p = new Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser(new StringReader(s));
				return p.SeqRegex(env);
			}
			catch (TokenMgrError error)
			{
				throw new TokenSequenceParseException("Parsing failed. Error: " + error);
			}
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParseException"/>
		public virtual Pair<SequencePattern.PatternExpr, ISequenceMatchAction<ICoreMap>> ParseSequenceWithAction(Env env, string s)
		{
			try
			{
				Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser p = new Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser(new StringReader(s));
				return p.SeqRegexWithAction(env);
			}
			catch (TokenMgrError error)
			{
				throw new TokenSequenceParseException("Parsing failed. Error: " + error);
			}
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParseException"/>
		public virtual SequencePattern.PatternExpr ParseNode(Env env, string s)
		{
			try
			{
				Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser p = new Edu.Stanford.Nlp.Ling.Tokensregex.Parser.TokenSequenceParser(new StringReader(s));
				NodePattern n = p.Node(env);
				return new SequencePattern.NodePatternExpr(n);
			}
			catch (TokenMgrError error)
			{
				throw new TokenSequenceParseException("Parsing failed. Error: " + error);
			}
		}

		private static int ParseInteger(string str)
		{
			if (str.StartsWith("+"))
			{
				return int.Parse(Sharpen.Runtime.Substring(str, 1));
			}
			else
			{
				return int.Parse(str);
			}
		}

		private static long ParseLongInteger(string str)
		{
			if (str.EndsWith("L"))
			{
				str = Sharpen.Runtime.Substring(str, 0, str.Length - 1);
			}
			if (str.StartsWith("+"))
			{
				return long.ValueOf(Sharpen.Runtime.Substring(str, 1));
			}
			else
			{
				return long.ValueOf(str);
			}
		}

		private string ParseQuotedString(string str)
		{
			// todo [cdm 2014]: I suspect this doesn't work because of how JavaCC escapes \
			// Trim start/end quote and unescape \"
			return Sharpen.Runtime.Substring(str, 1, str.Length - 1).ReplaceAll("\u005c\u005c\u005c\u005c\u005c\"", "\u005c\"");
		}

		private void AppendSpecialTokens(StringBuilder sb, Token st)
		{
			if (st != null)
			{
				AppendSpecialTokens(sb, st.specialToken);
				sb.Append(st.image);
			}
		}

		private string GetStringFromTokens(Token head, Token tail, bool includeSpecial)
		{
			StringBuilder sb = new StringBuilder();
			for (Token p = head; p != tail; p = p.next)
			{
				if (includeSpecial)
				{
					AppendSpecialTokens(sb, p.specialToken);
				}
				sb.Append(p.image);
			}
			return sb.ToString();
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IList<SequenceMatchRules.IRule> RuleList(Env env)
		{
			IList<SequenceMatchRules.IRule> rules = new List<SequenceMatchRules.IRule>();
			SequenceMatchRules.IRule rule;
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case TokenSequenceParserConstantsConstants.Identifier:
					case TokenSequenceParserConstantsConstants.Regexvar:
					case 22:
					{
						break;
					}

					default:
					{
						jj_la1[0] = jj_gen;
						goto label_1_break;
					}
				}
				rule = Rule(env);
				rules.Add(rule);
label_1_continue: ;
			}
label_1_break: ;
			{
				if (true)
				{
					return rules;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequenceMatchRules.IRule Rule(Env env)
		{
			SequenceMatchRules.IRule rule;
			Expressions.CompositeValue cv;
			if (Jj_2_1(3))
			{
				rule = ExpressionExtractorRule(env);
			}
			else
			{
				if (Jj_2_2(3))
				{
					rule = AssignmentRule(env);
				}
				else
				{
					if (Jj_2_3(3))
					{
						cv = CompositeFieldValue(env);
						rule = SequenceMatchRules.CreateRule(env, cv);
					}
					else
					{
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
			}
			{
				if (true)
				{
					return rule;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequenceMatchRules.IRule ExpressionExtractorRule(Env env)
		{
			SequencePattern.PatternExpr expr;
			string stringRegex;
			IExpression result;
			Token ruleTypeToken;
			if (Jj_2_4(2))
			{
				Jj_consume_token(22);
				stringRegex = StringRegex(env);
				Jj_consume_token(23);
				result = Expression(env);
				Jj_consume_token(24);
				{
					if (true)
					{
						return SequenceMatchRules.CreateExtractionRule(env, null, stringRegex, result);
					}
				}
			}
			else
			{
				if (Jj_2_5(2))
				{
					Jj_consume_token(22);
					Jj_consume_token(25);
					expr = SeqRegex(env);
					Jj_consume_token(26);
					Jj_consume_token(23);
					result = Expression(env);
					Jj_consume_token(24);
					{
						if (true)
						{
							return SequenceMatchRules.CreateExtractionRule(env, null, ((TokenSequencePattern)TokenSequencePattern.Compile(expr)), result);
						}
					}
				}
				else
				{
					if (Jj_2_6(2))
					{
						Jj_consume_token(22);
						Jj_consume_token(27);
						Jj_consume_token(25);
						expr = SeqRegex(env);
						Jj_consume_token(26);
						Jj_consume_token(23);
						result = Expression(env);
						Jj_consume_token(24);
						{
							if (true)
							{
								return SequenceMatchRules.CreateTokenPatternRule(env, expr, result);
							}
						}
					}
					else
					{
						if (Jj_2_7(2))
						{
							Jj_consume_token(22);
							Jj_consume_token(28);
							stringRegex = StringRegex(env);
							Jj_consume_token(23);
							result = Expression(env);
							Jj_consume_token(24);
							{
								if (true)
								{
									return SequenceMatchRules.CreateTextPatternRule(env, stringRegex, result);
								}
							}
						}
						else
						{
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequenceMatchRules.IRule AssignmentRule(Env env)
		{
			IAssignableExpression var;
			IExpression result;
			var = AssignableExpression(env);
			Jj_consume_token(29);
			result = Expression(env);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 30:
				{
					Jj_consume_token(30);
					break;
				}

				default:
				{
					jj_la1[1] = jj_gen;
					break;
				}
			}
			{
				if (true)
				{
					return SequenceMatchRules.CreateAssignmentRule(env, var, result);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IAssignableExpression AssignableExpression(Env env)
		{
			IAssignableExpression expr;
			expr = AssignableNestedVarExpression(env);
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression Expression(Env env)
		{
			IExpression expr;
			if (Jj_2_8(5))
			{
				expr = NestedFunctionCallExpression(env);
			}
			else
			{
				if (Jj_2_9(5))
				{
					expr = NestedVarExpression(env);
				}
				else
				{
					if (Jj_2_10(5))
					{
						expr = ValueExpression(env);
					}
					else
					{
						if (Jj_2_11(5))
						{
							expr = ListExpression(env);
						}
						else
						{
							if (Jj_2_12(5))
							{
								expr = ListExpression2(env);
							}
							else
							{
								if (Jj_2_13(5))
								{
									expr = CaseExpression(env);
								}
								else
								{
									Jj_consume_token(-1);
									throw new ParseException();
								}
							}
						}
					}
				}
			}
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public int Index()
		{
			Token t;
			Jj_consume_token(31);
			t = IntegerToken();
			Jj_consume_token(32);
			{
				if (true)
				{
					return System.Convert.ToInt32(t.image);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression FunctionCallExpression(Env env)
		{
			Token typeToken;
			IExpression param;
			IList<IExpression> @params = new List<IExpression>();
			typeToken = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
			Jj_consume_token(25);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Identifier:
				case TokenSequenceParserConstantsConstants.Regexvar:
				case TokenSequenceParserConstantsConstants.Regexgroup:
				case TokenSequenceParserConstantsConstants.Regexmrvar:
				case TokenSequenceParserConstantsConstants.Regexmrgroup:
				case TokenSequenceParserConstantsConstants.Nonnegint:
				case TokenSequenceParserConstantsConstants.Int:
				case TokenSequenceParserConstantsConstants.Longint:
				case TokenSequenceParserConstantsConstants.Real:
				case TokenSequenceParserConstantsConstants.Regex:
				case TokenSequenceParserConstantsConstants.Str:
				case 22:
				case 25:
				case 31:
				case 38:
				{
					param = Expression(env);
					@params.Add(param);
					while (true)
					{
						switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
						{
							case 33:
							{
								break;
							}

							default:
							{
								jj_la1[2] = jj_gen;
								goto label_2_break;
							}
						}
						Jj_consume_token(33);
						param = Expression(env);
						@params.Add(param);
label_2_continue: ;
					}
label_2_break: ;
					break;
				}

				default:
				{
					jj_la1[3] = jj_gen;
					break;
				}
			}
			Jj_consume_token(26);
			{
				if (true)
				{
					return new Expressions.FunctionCallExpression(typeToken.image, @params);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IValue ValueExpression(Env env)
		{
			IValue expr;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Nonnegint:
				case TokenSequenceParserConstantsConstants.Int:
				case TokenSequenceParserConstantsConstants.Longint:
				case TokenSequenceParserConstantsConstants.Real:
				case TokenSequenceParserConstantsConstants.Regex:
				case TokenSequenceParserConstantsConstants.Str:
				case 25:
				{
					expr = BasicValue(env);
					break;
				}

				case 22:
				{
					expr = CompositeFieldValue(env);
					break;
				}

				default:
				{
					jj_la1[4] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public Expressions.CompositeValue CompositeFieldValue(Env env)
		{
			IDictionary<string, IExpression> attributes = new ArrayMap<string, IExpression>();
			Jj_consume_token(22);
			FieldValue(env, attributes);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 30:
					case 33:
					{
						break;
					}

					default:
					{
						jj_la1[5] = jj_gen;
						goto label_3_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 33:
					{
						Jj_consume_token(33);
						break;
					}

					case 30:
					{
						Jj_consume_token(30);
						break;
					}

					default:
					{
						jj_la1[6] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				FieldValue(env, attributes);
label_3_continue: ;
			}
label_3_break: ;
			Jj_consume_token(24);
			{
				if (true)
				{
					return new Expressions.CompositeValue(attributes, false);
				}
			}
			/*"COMPOSITE", */
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IDictionary<string, IExpression> FieldValue(Env env, IDictionary<string, IExpression> attributes)
		{
			string fieldname = null;
			IExpression expr = null;
			fieldname = RelaxedString();
			Jj_consume_token(34);
			expr = Expression(env);
			if (fieldname != null && expr != null)
			{
				if (attributes.Contains(fieldname))
				{
					{
						if (true)
						{
							throw new Exception("Field already defined: " + fieldname);
						}
					}
				}
				attributes[fieldname] = expr;
			}
			{
				if (true)
				{
					return attributes;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IValue BasicValue(Env env)
		{
			Token tok = null;
			Token head = null;
			Token tail = null;
			SequencePattern.PatternExpr seqRegex = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Regex:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Regex);
					if (true)
					{
						return new Expressions.RegexValue(Sharpen.Runtime.Substring(tok.image, 1, tok.image.Length - 1));
					}
					/*"REGEX",*/
					break;
				}

				case TokenSequenceParserConstantsConstants.Str:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Str);
					if (true)
					{
						return new Expressions.PrimitiveValue<string>("STRING", ParseQuotedString(tok.image));
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Nonnegint:
				case TokenSequenceParserConstantsConstants.Int:
				{
					tok = IntegerToken();
					if (true)
					{
						return new Expressions.PrimitiveValue<Number>("INTEGER", ParseInteger(tok.image));
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Longint:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Longint);
					if (true)
					{
						return new Expressions.PrimitiveValue<Number>("INTEGER", ParseLongInteger(tok.image));
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Real:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Real);
					if (true)
					{
						return new Expressions.PrimitiveValue<Number>("REAL", double.ValueOf(tok.image));
					}
					break;
				}

				case 25:
				{
					head = Jj_consume_token(25);
					seqRegex = SeqRegex(env);
					tail = Jj_consume_token(26);
					string str = GetStringFromTokens(head, tail, true);
					TokenSequencePattern seqPattern = new TokenSequencePattern(str, seqRegex);
					if (true)
					{
						return new Expressions.PrimitiveValue<TokenSequencePattern>("TOKEN_REGEX", seqPattern);
					}
					break;
				}

				default:
				{
					jj_la1[7] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IAssignableExpression AssignableVar(Env env)
		{
			Token tok = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Identifier:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
					if (true)
					{
						return new Expressions.VarExpression(tok.image);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Regexvar:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexvar);
					if (true)
					{
						return new Expressions.RegexMatchVarExpression(tok.image);
					}
					break;
				}

				default:
				{
					jj_la1[8] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression VarOrRegexVar(Env env)
		{
			Token tok = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Identifier:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
					if (true)
					{
						return new Expressions.VarExpression(tok.image);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Regexvar:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexvar);
					if (true)
					{
						return new Expressions.RegexMatchVarExpression(tok.image);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Regexgroup:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexgroup);
					if (true)
					{
						return new Expressions.RegexMatchVarExpression(int.Parse(Sharpen.Runtime.Substring(tok.image, 1)));
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Regexmrvar:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexmrvar);
					if (true)
					{
						return new Expressions.RegexMatchResultVarExpression(Sharpen.Runtime.Substring(tok.image, 1));
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Regexmrgroup:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexmrgroup);
					if (true)
					{
						return new Expressions.RegexMatchResultVarExpression(int.Parse(Sharpen.Runtime.Substring(tok.image, 2)));
					}
					break;
				}

				default:
				{
					jj_la1[9] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression MethodCallExpression(Env env, IExpression parent)
		{
			Token typeToken;
			IExpression param;
			IList<IExpression> @params = new List<IExpression>();
			typeToken = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
			Jj_consume_token(25);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Identifier:
				case TokenSequenceParserConstantsConstants.Regexvar:
				case TokenSequenceParserConstantsConstants.Regexgroup:
				case TokenSequenceParserConstantsConstants.Regexmrvar:
				case TokenSequenceParserConstantsConstants.Regexmrgroup:
				case TokenSequenceParserConstantsConstants.Nonnegint:
				case TokenSequenceParserConstantsConstants.Int:
				case TokenSequenceParserConstantsConstants.Longint:
				case TokenSequenceParserConstantsConstants.Real:
				case TokenSequenceParserConstantsConstants.Regex:
				case TokenSequenceParserConstantsConstants.Str:
				case 22:
				case 25:
				case 31:
				case 38:
				{
					param = Expression(env);
					@params.Add(param);
					while (true)
					{
						switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
						{
							case 33:
							{
								break;
							}

							default:
							{
								jj_la1[10] = jj_gen;
								goto label_4_break;
							}
						}
						Jj_consume_token(33);
						param = Expression(env);
						@params.Add(param);
label_4_continue: ;
					}
label_4_break: ;
					break;
				}

				default:
				{
					jj_la1[11] = jj_gen;
					break;
				}
			}
			Jj_consume_token(26);
			{
				if (true)
				{
					return new Expressions.MethodCallExpression(typeToken.image, parent, @params);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IAssignableExpression AssignableNestedVarExpression(Env env)
		{
			IAssignableExpression expr;
			IExpression fieldExpr;
			string s;
			Token tok;
			int i;
			expr = AssignableVar(env);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 31:
					case 35:
					{
						break;
					}

					default:
					{
						jj_la1[12] = jj_gen;
						goto label_5_break;
					}
				}
				if (Jj_2_14(2))
				{
					i = Index();
					expr = new Expressions.IndexedExpression(expr, i);
				}
				else
				{
					if (Jj_2_15(2))
					{
						Jj_consume_token(31);
						fieldExpr = Expression(env);
						expr = new Expressions.FieldExpression(expr, fieldExpr);
						Jj_consume_token(32);
					}
					else
					{
						if (Jj_2_16(2))
						{
							Jj_consume_token(35);
							s = RelaxedString();
							expr = new Expressions.FieldExpression(expr, s);
						}
						else
						{
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
				}
label_5_continue: ;
			}
label_5_break: ;
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression NestedVarExpression(Env env)
		{
			IExpression expr;
			IExpression fieldExpr;
			string s;
			Token tok;
			int i;
			expr = VarOrRegexVar(env);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 31:
					case 35:
					{
						break;
					}

					default:
					{
						jj_la1[13] = jj_gen;
						goto label_6_break;
					}
				}
				if (Jj_2_17(3))
				{
					i = Index();
					expr = new Expressions.IndexedExpression(expr, i);
				}
				else
				{
					if (Jj_2_18(3))
					{
						Jj_consume_token(31);
						fieldExpr = Expression(env);
						expr = new Expressions.FieldExpression(expr, fieldExpr);
						Jj_consume_token(32);
					}
					else
					{
						if (Jj_2_19(3))
						{
							Jj_consume_token(35);
							expr = MethodCallExpression(env, expr);
						}
						else
						{
							if (Jj_2_20(3))
							{
								Jj_consume_token(35);
								s = RelaxedString();
								expr = new Expressions.FieldExpression(expr, s);
							}
							else
							{
								Jj_consume_token(-1);
								throw new ParseException();
							}
						}
					}
				}
label_6_continue: ;
			}
label_6_break: ;
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression NestedFunctionCallExpression(Env env)
		{
			IExpression expr;
			IExpression fieldExpr;
			string s;
			Token tok;
			int i;
			expr = FunctionCallExpression(env);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 31:
					case 35:
					{
						break;
					}

					default:
					{
						jj_la1[14] = jj_gen;
						goto label_7_break;
					}
				}
				if (Jj_2_21(3))
				{
					i = Index();
					expr = new Expressions.IndexedExpression(expr, i);
				}
				else
				{
					if (Jj_2_22(3))
					{
						Jj_consume_token(31);
						fieldExpr = Expression(env);
						expr = new Expressions.FieldExpression(expr, fieldExpr);
						Jj_consume_token(32);
					}
					else
					{
						if (Jj_2_23(3))
						{
							Jj_consume_token(35);
							expr = MethodCallExpression(env, expr);
						}
						else
						{
							if (Jj_2_24(3))
							{
								Jj_consume_token(35);
								s = RelaxedString();
								expr = new Expressions.FieldExpression(expr, s);
							}
							else
							{
								Jj_consume_token(-1);
								throw new ParseException();
							}
						}
					}
				}
label_7_continue: ;
			}
label_7_break: ;
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression ListExpression(Env env)
		{
			IList<IExpression> exprs = new List<IExpression>();
			IExpression expr;
			Jj_consume_token(25);
			expr = Expression(env);
			exprs.Add(expr);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 33:
					{
						break;
					}

					default:
					{
						jj_la1[15] = jj_gen;
						goto label_8_break;
					}
				}
				Jj_consume_token(33);
				expr = Expression(env);
				exprs.Add(expr);
label_8_continue: ;
			}
label_8_break: ;
			Jj_consume_token(26);
			{
				if (true)
				{
					return new Expressions.ListExpression(Expressions.TypeList, exprs);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression ListExpression2(Env env)
		{
			IList<IExpression> exprs = new List<IExpression>();
			IExpression expr;
			Jj_consume_token(31);
			expr = Expression(env);
			exprs.Add(expr);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 33:
					{
						break;
					}

					default:
					{
						jj_la1[16] = jj_gen;
						goto label_9_break;
					}
				}
				Jj_consume_token(33);
				expr = Expression(env);
				exprs.Add(expr);
label_9_continue: ;
			}
label_9_break: ;
			Jj_consume_token(32);
			{
				if (true)
				{
					return new Expressions.ListExpression(Expressions.TypeList, exprs);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression BasicCondExpression(Env env)
		{
			IExpression expr1 = null;
			IExpression expr2 = null;
			Token op = null;
			if (Jj_2_25(3))
			{
				expr1 = NestedVarExpression(env);
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case TokenSequenceParserConstantsConstants.Numcmp:
					case TokenSequenceParserConstantsConstants.Strregexcmp:
					{
						op = CmpToken();
						expr2 = Expression(env);
						break;
					}

					default:
					{
						jj_la1[17] = jj_gen;
						break;
					}
				}
				if (op == null)
				{
					{
						if (true)
						{
							return new Expressions.ConditionalExpression(expr1);
						}
					}
				}
				else
				{
					{
						if (true)
						{
							return new Expressions.ConditionalExpression(op.image, expr1, expr2);
						}
					}
				}
			}
			else
			{
				if (Jj_2_26(3))
				{
					expr1 = NestedFunctionCallExpression(env);
					{
						if (true)
						{
							return new Expressions.ConditionalExpression(expr1);
						}
					}
				}
				else
				{
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression CondGroup(Env env)
		{
			IExpression expr;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Identifier:
				case TokenSequenceParserConstantsConstants.Regexvar:
				case TokenSequenceParserConstantsConstants.Regexgroup:
				case TokenSequenceParserConstantsConstants.Regexmrvar:
				case TokenSequenceParserConstantsConstants.Regexmrgroup:
				{
					expr = BasicCondExpression(env);
					break;
				}

				case 25:
				{
					Jj_consume_token(25);
					expr = CondExpression(env);
					Jj_consume_token(26);
					break;
				}

				default:
				{
					jj_la1[18] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression CondExpression(Env env)
		{
			IExpression child;
			IList<IExpression> disjChildren = new List<IExpression>();
			IList<IExpression> conjChildren = new List<IExpression>();
			Token op;
			child = CondGroup(env);
			conjChildren.Add(child);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 36:
					case 37:
					{
						break;
					}

					default:
					{
						jj_la1[19] = jj_gen;
						goto label_10_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 36:
					{
						op = Jj_consume_token(36);
						break;
					}

					case 37:
					{
						op = Jj_consume_token(37);
						break;
					}

					default:
					{
						jj_la1[20] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				child = CondGroup(env);
				if ("&&".Equals(op.image))
				{
					conjChildren.Add(child);
				}
				else
				{
					if ("||".Equals(op.image))
					{
						if (conjChildren.Count > 1)
						{
							disjChildren.Add(new Expressions.AndExpression(conjChildren));
						}
						else
						{
							disjChildren.Add(conjChildren[0]);
						}
						conjChildren = new List<IExpression>();
						conjChildren.Add(child);
					}
				}
label_10_continue: ;
			}
label_10_break: ;
			if (conjChildren.Count > 1)
			{
				disjChildren.Add(new Expressions.AndExpression(conjChildren));
			}
			else
			{
				disjChildren.Add(conjChildren[0]);
			}
			if (disjChildren.Count == 1)
			{
				if (true)
				{
					return disjChildren[0];
				}
			}
			else
			{
				if (true)
				{
					return new Expressions.OrExpression(disjChildren);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IExpression CaseExpression(Env env)
		{
			IExpression cond = null;
			IExpression expr = null;
			IList<Pair<IExpression, IExpression>> cases = new List<Pair<IExpression, IExpression>>();
			IExpression elseExpr = null;
			Jj_consume_token(38);
			Jj_consume_token(22);
			while (true)
			{
				cond = CondExpression(env);
				Jj_consume_token(23);
				expr = Expression(env);
				cases.Add(new Pair<IExpression, IExpression>(cond, expr));
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 33:
					{
						Jj_consume_token(33);
						break;
					}

					case 30:
					{
						Jj_consume_token(30);
						break;
					}

					default:
					{
						jj_la1[21] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case TokenSequenceParserConstantsConstants.Identifier:
					case TokenSequenceParserConstantsConstants.Regexvar:
					case TokenSequenceParserConstantsConstants.Regexgroup:
					case TokenSequenceParserConstantsConstants.Regexmrvar:
					case TokenSequenceParserConstantsConstants.Regexmrgroup:
					case 25:
					{
						break;
					}

					default:
					{
						jj_la1[22] = jj_gen;
						goto label_11_break;
					}
				}
label_11_continue: ;
			}
label_11_break: ;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 39:
				{
					Jj_consume_token(39);
					Jj_consume_token(23);
					elseExpr = Expression(env);
					break;
				}

				default:
				{
					jj_la1[23] = jj_gen;
					break;
				}
			}
			Jj_consume_token(24);
			{
				if (true)
				{
					return new Expressions.CaseExpression(cases, elseExpr);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public string StringRegex(Env env)
		{
			Token tok;
			tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Regex);
			{
				if (true)
				{
					return Sharpen.Runtime.Substring(tok.image, 1, tok.image.Length - 1);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqRegex(Env env)
		{
			SequencePattern.PatternExpr expr;
			bool hasStart = false;
			bool hasEnd = false;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 40:
				{
					Jj_consume_token(40);
					hasStart = true;
					break;
				}

				default:
				{
					jj_la1[24] = jj_gen;
					break;
				}
			}
			expr = SeqRegexDisjConj(env);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 41:
				{
					Jj_consume_token(41);
					hasEnd = true;
					break;
				}

				default:
				{
					jj_la1[25] = jj_gen;
					break;
				}
			}
			if (hasStart)
			{
				expr = new SequencePattern.SequencePatternExpr(SequencePattern.SeqBeginPatternExpr, expr);
			}
			if (hasEnd)
			{
				expr = new SequencePattern.SequencePatternExpr(expr, SequencePattern.SeqEndPatternExpr);
			}
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public object StringNumberValue(Env env)
		{
			Token tok = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Str:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Str);
					if (true)
					{
						return ParseQuotedString(tok.image);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Nonnegint:
				case TokenSequenceParserConstantsConstants.Int:
				{
					tok = IntegerToken();
					if (true)
					{
						return ParseInteger(tok.image);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Longint:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Longint);
					if (true)
					{
						return ParseLongInteger(tok.image);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Real:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Real);
					if (true)
					{
						return double.ValueOf(tok.image);
					}
					break;
				}

				default:
				{
					jj_la1[26] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqRegexBasic(Env env)
		{
			IList<SequencePattern.PatternExpr> children = new List<SequencePattern.PatternExpr>();
			NodePattern node;
			Edu.Stanford.Nlp.Ling.Tokensregex.MultiNodePattern multiNode;
			SequencePattern.PatternExpr expr;
			object value = null;
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 31:
					{
						node = BracketedNode(env);
						expr = new SequencePattern.NodePatternExpr(node);
						break;
					}

					case TokenSequenceParserConstantsConstants.Identifier:
					case TokenSequenceParserConstantsConstants.Nonnegint:
					case TokenSequenceParserConstantsConstants.Int:
					case TokenSequenceParserConstantsConstants.Longint:
					case TokenSequenceParserConstantsConstants.Real:
					case TokenSequenceParserConstantsConstants.Regex:
					case TokenSequenceParserConstantsConstants.Str:
					case TokenSequenceParserConstantsConstants.Strsimple:
					{
						node = CoreMapWordPattern(env);
						expr = new SequencePattern.NodePatternExpr(node);
						break;
					}

					case 52:
					{
						multiNode = MultiNodePattern(env);
						expr = new SequencePattern.MultiNodePatternExpr(multiNode);
						break;
					}

					case 25:
					{
						expr = SeqRegexGroup(env);
						break;
					}

					case TokenSequenceParserConstantsConstants.Regexvar:
					{
						expr = SeqVar(env);
						break;
					}

					case TokenSequenceParserConstantsConstants.Backref:
					{
						expr = SeqBackRef(env);
						break;
					}

					default:
					{
						jj_la1[27] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 22:
					case 42:
					case 43:
					case 44:
					{
						expr = SeqRegexRepeatTimes(env, expr);
						break;
					}

					default:
					{
						jj_la1[28] = jj_gen;
						break;
					}
				}
				children.Add(expr);
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case TokenSequenceParserConstantsConstants.Identifier:
					case TokenSequenceParserConstantsConstants.Regexvar:
					case TokenSequenceParserConstantsConstants.Backref:
					case TokenSequenceParserConstantsConstants.Nonnegint:
					case TokenSequenceParserConstantsConstants.Int:
					case TokenSequenceParserConstantsConstants.Longint:
					case TokenSequenceParserConstantsConstants.Real:
					case TokenSequenceParserConstantsConstants.Regex:
					case TokenSequenceParserConstantsConstants.Str:
					case TokenSequenceParserConstantsConstants.Strsimple:
					case 25:
					case 31:
					case 52:
					{
						break;
					}

					default:
					{
						jj_la1[29] = jj_gen;
						goto label_12_break;
					}
				}
label_12_continue: ;
			}
label_12_break: ;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 23:
				{
					Jj_consume_token(23);
					value = Expression(env);
					break;
				}

				default:
				{
					jj_la1[30] = jj_gen;
					break;
				}
			}
			if (children.Count != 1)
			{
				expr = new SequencePattern.SequencePatternExpr(children);
			}
			if (value != null)
			{
				expr = new SequencePattern.ValuePatternExpr(expr, value);
			}
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqRegexRepeatTimes(Env env, SequencePattern.PatternExpr expr)
		{
			Token value;
			Token v2;
			int min = -1;
			int max = -1;
			bool greedy = true;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 42:
				{
					value = Jj_consume_token(42);
					min = 0;
					max = -1;
					break;
				}

				case 43:
				{
					value = Jj_consume_token(43);
					min = 0;
					max = 1;
					break;
				}

				case 44:
				{
					value = Jj_consume_token(44);
					min = 1;
					max = -1;
					break;
				}

				default:
				{
					jj_la1[31] = jj_gen;
					if (Jj_2_27(3))
					{
						Jj_consume_token(22);
						value = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
						Jj_consume_token(24);
						min = System.Convert.ToInt32(value.image);
						max = min;
					}
					else
					{
						if (Jj_2_28(4))
						{
							Jj_consume_token(22);
							value = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
							Jj_consume_token(33);
							Jj_consume_token(24);
							min = System.Convert.ToInt32(value.image);
							max = -1;
						}
						else
						{
							switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
							{
								case 22:
								{
									Jj_consume_token(22);
									value = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
									Jj_consume_token(33);
									v2 = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
									Jj_consume_token(24);
									min = System.Convert.ToInt32(value.image);
									max = System.Convert.ToInt32(v2.image);
									break;
								}

								default:
								{
									jj_la1[32] = jj_gen;
									Jj_consume_token(-1);
									throw new ParseException();
								}
							}
						}
					}
					break;
				}
			}
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 43:
				{
					Jj_consume_token(43);
					greedy = false;
					break;
				}

				default:
				{
					jj_la1[33] = jj_gen;
					break;
				}
			}
			{
				if (true)
				{
					return new SequencePattern.RepeatPatternExpr(expr, min, max, greedy);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqRegexDisj(Env env)
		{
			IList<SequencePattern.PatternExpr> children = new List<SequencePattern.PatternExpr>();
			SequencePattern.PatternExpr expr;
			expr = SeqRegexBasic(env);
			children.Add(expr);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 37:
					case 45:
					{
						break;
					}

					default:
					{
						jj_la1[34] = jj_gen;
						goto label_13_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 45:
					{
						Jj_consume_token(45);
						break;
					}

					case 37:
					{
						Jj_consume_token(37);
						break;
					}

					default:
					{
						jj_la1[35] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				expr = SeqRegexBasic(env);
				children.Add(expr);
label_13_continue: ;
			}
label_13_break: ;
			if (children.Count == 1)
			{
				{
					if (true)
					{
						return children[0];
					}
				}
			}
			else
			{
				{
					if (true)
					{
						return new SequencePattern.OrPatternExpr(children);
					}
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqRegexDisjConj(Env env)
		{
			SequencePattern.PatternExpr child;
			IList<SequencePattern.PatternExpr> disjChildren = new List<SequencePattern.PatternExpr>();
			IList<SequencePattern.PatternExpr> conjChildren = new List<SequencePattern.PatternExpr>();
			Token op;
			child = SeqRegexBasic(env);
			conjChildren.Add(child);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 36:
					case 37:
					case 45:
					case 46:
					{
						break;
					}

					default:
					{
						jj_la1[36] = jj_gen;
						goto label_14_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 46:
					{
						op = Jj_consume_token(46);
						break;
					}

					case 45:
					{
						op = Jj_consume_token(45);
						break;
					}

					case 36:
					{
						op = Jj_consume_token(36);
						break;
					}

					case 37:
					{
						op = Jj_consume_token(37);
						break;
					}

					default:
					{
						jj_la1[37] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				child = SeqRegexBasic(env);
				if ("&".Equals(op.image) || "&&".Equals(op.image))
				{
					conjChildren.Add(child);
				}
				else
				{
					if ("|".Equals(op.image) || "||".Equals(op.image))
					{
						if (conjChildren.Count > 1)
						{
							disjChildren.Add(new SequencePattern.AndPatternExpr(conjChildren));
						}
						else
						{
							disjChildren.Add(conjChildren[0]);
						}
						conjChildren = new List<SequencePattern.PatternExpr>();
						conjChildren.Add(child);
					}
				}
label_14_continue: ;
			}
label_14_break: ;
			if (conjChildren.Count > 1)
			{
				disjChildren.Add(new SequencePattern.AndPatternExpr(conjChildren));
			}
			else
			{
				disjChildren.Add(conjChildren[0]);
			}
			if (disjChildren.Count == 1)
			{
				if (true)
				{
					return disjChildren[0];
				}
			}
			else
			{
				if (true)
				{
					return new SequencePattern.OrPatternExpr(disjChildren);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqRegexGroup(Env env)
		{
			SequencePattern.PatternExpr expr;
			bool capturing = true;
			string varname = null;
			Token var;
			Jj_consume_token(25);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 43:
				case 47:
				{
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case 47:
						{
							Jj_consume_token(47);
							capturing = false;
							break;
						}

						case 43:
						{
							Jj_consume_token(43);
							var = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexvar);
							varname = var.image;
							break;
						}

						default:
						{
							jj_la1[38] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					break;
				}

				default:
				{
					jj_la1[39] = jj_gen;
					break;
				}
			}
			expr = SeqRegex(env);
			Jj_consume_token(26);
			if (varname != null)
			{
				{
					if (true)
					{
						return new SequencePattern.GroupPatternExpr(expr, varname);
					}
				}
			}
			else
			{
				{
					if (true)
					{
						return new SequencePattern.GroupPatternExpr(expr, capturing);
					}
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern BracketedNode(Env env)
		{
			NodePattern node;
			if (Jj_2_29(2))
			{
				Jj_consume_token(31);
				Jj_consume_token(32);
				node = NodePattern.AnyNode;
			}
			else
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 31:
					{
						Jj_consume_token(31);
						node = NodeDisjConj(env);
						Jj_consume_token(32);
						break;
					}

					default:
					{
						jj_la1[40] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
			}
			{
				if (true)
				{
					return node;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqVar(Env env)
		{
			SequencePattern.PatternExpr expr;
			Token name;
			name = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexvar);
			expr = env.GetSequencePatternExpr(name.image, true);
			if (expr == null)
			{
				{
					if (true)
					{
						throw new Exception("Unknown sequence pattern variable " + name.image);
					}
				}
			}
			{
				if (true)
				{
					return expr;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public SequencePattern.PatternExpr SeqBackRef(Env env)
		{
			Token name;
			name = Jj_consume_token(TokenSequenceParserConstantsConstants.Backref);
			int v = System.Convert.ToInt32(Sharpen.Runtime.Substring(name.image, 1));
			{
				if (true)
				{
					return new SequencePattern.BackRefPatternExpr(CoreMapNodePattern.TextAttrEqualChecker, v);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern Node(Env env)
		{
			NodePattern node;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 31:
				{
					node = BracketedNode(env);
					break;
				}

				case TokenSequenceParserConstantsConstants.Identifier:
				case TokenSequenceParserConstantsConstants.Regexvar:
				case TokenSequenceParserConstantsConstants.Regex:
				case TokenSequenceParserConstantsConstants.Str:
				case 22:
				case 25:
				case 48:
				case 49:
				{
					node = NodeGroup(env);
					break;
				}

				default:
				{
					jj_la1[41] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return node;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern NodeDisj(Env env)
		{
			IList<NodePattern> children = new List<NodePattern>();
			NodePattern child;
			child = NodeGroup(env);
			children.Add(child);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 37:
					case 45:
					{
						break;
					}

					default:
					{
						jj_la1[42] = jj_gen;
						goto label_15_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 45:
					{
						Jj_consume_token(45);
						break;
					}

					case 37:
					{
						Jj_consume_token(37);
						break;
					}

					default:
					{
						jj_la1[43] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				child = NodeGroup(env);
				children.Add(child);
label_15_continue: ;
			}
label_15_break: ;
			if (children.Count == 1)
			{
				if (true)
				{
					return child;
				}
			}
			else
			{
				if (true)
				{
					return new NodePattern.DisjNodePattern(children);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern NodeConj(Env env)
		{
			NodePattern child;
			IList children = new ArrayList();
			child = NodeGroup(env);
			children.Add(child);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 36:
					case 46:
					{
						break;
					}

					default:
					{
						jj_la1[44] = jj_gen;
						goto label_16_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 46:
					{
						Jj_consume_token(46);
						break;
					}

					case 36:
					{
						Jj_consume_token(36);
						break;
					}

					default:
					{
						jj_la1[45] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				child = NodeGroup(env);
				children.Add(child);
label_16_continue: ;
			}
label_16_break: ;
			if (children.Count == 1)
			{
				if (true)
				{
					return child;
				}
			}
			else
			{
				if (true)
				{
					return new NodePattern.ConjNodePattern(children);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern NodeDisjConj(Env env)
		{
			NodePattern child;
			IList<NodePattern> disjChildren = new List<NodePattern>();
			IList<NodePattern> conjChildren = new List<NodePattern>();
			Token op;
			child = NodeGroup(env);
			conjChildren.Add(child);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 36:
					case 37:
					case 45:
					case 46:
					{
						break;
					}

					default:
					{
						jj_la1[46] = jj_gen;
						goto label_17_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 46:
					{
						op = Jj_consume_token(46);
						break;
					}

					case 45:
					{
						op = Jj_consume_token(45);
						break;
					}

					case 36:
					{
						op = Jj_consume_token(36);
						break;
					}

					case 37:
					{
						op = Jj_consume_token(37);
						break;
					}

					default:
					{
						jj_la1[47] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				child = NodeGroup(env);
				if ("&".Equals(op.image) || "&&".Equals(op.image))
				{
					conjChildren.Add(child);
				}
				else
				{
					if ("|".Equals(op.image) || ("||".Equals(op.image)))
					{
						if (conjChildren.Count > 1)
						{
							disjChildren.Add(new NodePattern.ConjNodePattern(conjChildren));
						}
						else
						{
							disjChildren.Add(conjChildren[0]);
						}
						conjChildren = new List<NodePattern>();
						conjChildren.Add(child);
					}
				}
label_17_continue: ;
			}
label_17_break: ;
			if (conjChildren.Count > 1)
			{
				disjChildren.Add(new NodePattern.ConjNodePattern(conjChildren));
			}
			else
			{
				disjChildren.Add(conjChildren[0]);
			}
			if (disjChildren.Count == 1)
			{
				if (true)
				{
					return disjChildren[0];
				}
			}
			else
			{
				if (true)
				{
					return new NodePattern.DisjNodePattern(disjChildren);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern NodeGroup(Env env)
		{
			NodePattern node;
			if (Jj_2_30(2))
			{
				node = NodeBasic(env);
			}
			else
			{
				if (Jj_2_31(2))
				{
					Jj_consume_token(25);
					node = NodeDisjConj(env);
					Jj_consume_token(26);
				}
				else
				{
					if (Jj_2_32(2))
					{
						Jj_consume_token(48);
						Jj_consume_token(25);
						node = NodeDisjConj(env);
						Jj_consume_token(26);
						node = new NodePattern.NegateNodePattern(node);
					}
					else
					{
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
			}
			{
				if (true)
				{
					return node;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern NodeBasic(Env env)
		{
			NodePattern child;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 48:
				{
					Jj_consume_token(48);
					child = CoreMapNode(env);
					if (true)
					{
						return new NodePattern.NegateNodePattern(child);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Identifier:
				case TokenSequenceParserConstantsConstants.Regexvar:
				case TokenSequenceParserConstantsConstants.Regex:
				case TokenSequenceParserConstantsConstants.Str:
				case 22:
				case 49:
				{
					child = CoreMapNode(env);
					if (true)
					{
						return child;
					}
					break;
				}

				default:
				{
					jj_la1[48] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern CoreMapNode(Env env)
		{
			IDictionary<string, string> attributes = new ArrayMap<string, string>();
			NodePattern pat;
			Token value = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Identifier:
				case TokenSequenceParserConstantsConstants.Regex:
				case TokenSequenceParserConstantsConstants.Str:
				case 22:
				{
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case 22:
						{
							Jj_consume_token(22);
							AttrValue(env, attributes);
							while (true)
							{
								switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
								{
									case 30:
									case 33:
									{
										break;
									}

									default:
									{
										jj_la1[49] = jj_gen;
										goto label_18_break;
									}
								}
								switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
								{
									case 33:
									{
										Jj_consume_token(33);
										break;
									}

									case 30:
									{
										Jj_consume_token(30);
										break;
									}

									default:
									{
										jj_la1[50] = jj_gen;
										Jj_consume_token(-1);
										throw new ParseException();
									}
								}
								AttrValue(env, attributes);
label_18_continue: ;
							}
label_18_break: ;
							Jj_consume_token(24);
							break;
						}

						default:
						{
							jj_la1[52] = jj_gen;
							if (Jj_2_33(2))
							{
								AttrValue(env, attributes);
							}
							else
							{
								switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
								{
									case TokenSequenceParserConstantsConstants.Identifier:
									case TokenSequenceParserConstantsConstants.Regex:
									case TokenSequenceParserConstantsConstants.Str:
									{
										switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
										{
											case TokenSequenceParserConstantsConstants.Identifier:
											case TokenSequenceParserConstantsConstants.Str:
											{
												value = RelaxedStringToken();
												break;
											}

											case TokenSequenceParserConstantsConstants.Regex:
											{
												value = Jj_consume_token(TokenSequenceParserConstantsConstants.Regex);
												break;
											}

											default:
											{
												jj_la1[51] = jj_gen;
												Jj_consume_token(-1);
												throw new ParseException();
											}
										}
										attributes["word"] = value.image;
										break;
									}

									default:
									{
										jj_la1[53] = jj_gen;
										Jj_consume_token(-1);
										throw new ParseException();
									}
								}
							}
							break;
						}
					}
					pat = CoreMapNodePattern.ValueOf(env, attributes);
					if (true)
					{
						return pat;
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Regexvar:
				{
					pat = CoreMapVarNodePattern(env);
					if (true)
					{
						return pat;
					}
					break;
				}

				case 49:
				{
					Jj_consume_token(49);
					pat = CoreMapExprNodePattern(env);
					Jj_consume_token(50);
					if (true)
					{
						return pat;
					}
					break;
				}

				default:
				{
					jj_la1[54] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IDictionary<string, string> AttrValue(Env env, IDictionary<string, string> attributes)
		{
			Token attr = null;
			Token value = null;
			Token tok = null;
			string str = null;
			attr = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 34:
				{
					Jj_consume_token(34);
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case TokenSequenceParserConstantsConstants.Str:
						{
							value = Jj_consume_token(TokenSequenceParserConstantsConstants.Str);
							break;
						}

						case TokenSequenceParserConstantsConstants.Regex:
						{
							value = Jj_consume_token(TokenSequenceParserConstantsConstants.Regex);
							break;
						}

						case TokenSequenceParserConstantsConstants.Identifier:
						{
							value = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
							break;
						}

						case TokenSequenceParserConstantsConstants.Regexvar:
						{
							str = CoreMapVarValue(env);
							break;
						}

						default:
						{
							jj_la1[55] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					break;
				}

				case 51:
				{
					tok = Jj_consume_token(51);
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
					break;
				}

				case TokenSequenceParserConstantsConstants.Numcmp:
				{
					tok = Jj_consume_token(TokenSequenceParserConstantsConstants.Numcmp);
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case TokenSequenceParserConstantsConstants.Nonnegint:
						case TokenSequenceParserConstantsConstants.Int:
						case TokenSequenceParserConstantsConstants.Real:
						{
							value = NumberToken();
							break;
						}

						case TokenSequenceParserConstantsConstants.Regexvar:
						{
							str = CoreMapVarValue(env);
							break;
						}

						default:
						{
							jj_la1[56] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					break;
				}

				default:
				{
					jj_la1[57] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			if (value != null)
			{
				str = value.image;
			}
			if (tok != null)
			{
				str = tok.image + str;
			}
			if (attr != null && str != null)
			{
				if (attributes.Contains(attr.image))
				{
					{
						if (true)
						{
							throw new Exception("Attribute match already defined: " + attr.image);
						}
					}
				}
				attributes[attr.image] = str;
			}
			{
				if (true)
				{
					return attributes;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern CoreMapWordPattern(Env env)
		{
			IDictionary<string, string> attributes = new ArrayMap<string, string>();
			CoreMapNodePattern pat;
			Token value = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Str:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Str);
					break;
				}

				case TokenSequenceParserConstantsConstants.Regex:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Regex);
					break;
				}

				case TokenSequenceParserConstantsConstants.Identifier:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
					break;
				}

				case TokenSequenceParserConstantsConstants.Nonnegint:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
					break;
				}

				case TokenSequenceParserConstantsConstants.Int:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Int);
					break;
				}

				case TokenSequenceParserConstantsConstants.Longint:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Longint);
					break;
				}

				case TokenSequenceParserConstantsConstants.Real:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Real);
					break;
				}

				case TokenSequenceParserConstantsConstants.Strsimple:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Strsimple);
					break;
				}

				default:
				{
					jj_la1[58] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			attributes["word"] = value.image;
			pat = CoreMapNodePattern.ValueOf(env, attributes);
			{
				if (true)
				{
					return pat;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public Edu.Stanford.Nlp.Ling.Tokensregex.MultiNodePattern MultiNodePattern(Env env)
		{
			NodePattern pat;
			Edu.Stanford.Nlp.Ling.Tokensregex.MultiNodePattern mp;
			Token v1;
			Token v2;
			int min = 1;
			int max = -1;
			bool greedy = true;
			Jj_consume_token(52);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 22:
				{
					if (Jj_2_34(3))
					{
						Jj_consume_token(22);
						v1 = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
						Jj_consume_token(24);
						min = System.Convert.ToInt32(v1.image);
						max = System.Convert.ToInt32(v1.image);
					}
					else
					{
						if (Jj_2_35(4))
						{
							Jj_consume_token(22);
							v1 = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
							Jj_consume_token(33);
							Jj_consume_token(24);
							min = System.Convert.ToInt32(v1.image);
						}
						else
						{
							switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
							{
								case 22:
								{
									Jj_consume_token(22);
									v1 = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
									Jj_consume_token(33);
									v2 = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
									Jj_consume_token(24);
									min = System.Convert.ToInt32(v1.image);
									max = System.Convert.ToInt32(v2.image);
									break;
								}

								default:
								{
									jj_la1[59] = jj_gen;
									Jj_consume_token(-1);
									throw new ParseException();
								}
							}
						}
					}
					break;
				}

				default:
				{
					jj_la1[60] = jj_gen;
					break;
				}
			}
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 43:
				{
					Jj_consume_token(43);
					greedy = false;
					break;
				}

				default:
				{
					jj_la1[61] = jj_gen;
					break;
				}
			}
			pat = CoreMapWordPattern(env);
			mp = new MultiCoreMapNodePattern(pat);
			mp.SetMinNodes(min);
			mp.SetMaxNodes(max);
			mp.SetGreedyMatch(greedy);
			{
				if (true)
				{
					return mp;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public string CoreMapVarValue(Env env)
		{
			Token value = null;
			value = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexvar);
			{
				if (true)
				{
					return (string)env.Get(value.image);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern CoreMapVarNodePattern(Env env)
		{
			Token value = null;
			value = Jj_consume_token(TokenSequenceParserConstantsConstants.Regexvar);
			{
				if (true)
				{
					return env.GetNodePattern(value.image);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public NodePattern CoreMapExprNodePattern(Env env)
		{
			IExpression expr = null;
			expr = CondExpression(env);
			{
				if (true)
				{
					return new CoreMapExpressionNodePattern(env, expr);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public Pair<SequencePattern.PatternExpr, ISequenceMatchAction<ICoreMap>> SeqRegexWithAction(Env env)
		{
			SequencePattern.PatternExpr expr;
			ISequenceMatchAction<ICoreMap> action = null;
			expr = SeqRegex(env);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case 53:
				{
					action = Action(env);
					break;
				}

				default:
				{
					jj_la1[62] = jj_gen;
					break;
				}
			}
			{
				if (true)
				{
					return new Pair<SequencePattern.PatternExpr, ISequenceMatchAction<ICoreMap>>(expr, action);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public ISequenceMatchAction<ICoreMap> Action(Env env)
		{
			ISequenceMatchAction<ICoreMap> action;
			Jj_consume_token(53);
			action = AnnotateAction(env);
			{
				if (true)
				{
					return action;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public ISequenceMatchAction<ICoreMap> AnnotateAction(Env env)
		{
			IDictionary<string, string> attributes;
			Jj_consume_token(54);
			Jj_consume_token(25);
			//  group = <NONNEGINT> ","
			attributes = SetAttrValues(env);
			Jj_consume_token(26);
			{
				if (true)
				{
					return new CoreMapSequenceMatchAction.AnnotateAction<ICoreMap>(attributes);
				}
			}
			/*group,*/
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IDictionary<string, string> SetAttrValues(Env env)
		{
			IDictionary<string, string> attributes = new ArrayMap<string, string>();
			Jj_consume_token(22);
			SetAttrValue(env, attributes);
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 30:
					case 33:
					{
						break;
					}

					default:
					{
						jj_la1[63] = jj_gen;
						goto label_19_break;
					}
				}
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case 33:
					{
						Jj_consume_token(33);
						break;
					}

					case 30:
					{
						Jj_consume_token(30);
						break;
					}

					default:
					{
						jj_la1[64] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
				SetAttrValue(env, attributes);
label_19_continue: ;
			}
label_19_break: ;
			Jj_consume_token(24);
			{
				if (true)
				{
					return attributes;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public IDictionary<string, string> SetAttrValue(Env env, IDictionary<string, string> attributes)
		{
			Token attr = null;
			Token value = null;
			string str = null;
			attr = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
			Jj_consume_token(29);
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Identifier:
				case TokenSequenceParserConstantsConstants.Str:
				{
					value = RelaxedStringToken();
					break;
				}

				case TokenSequenceParserConstantsConstants.Nonnegint:
				case TokenSequenceParserConstantsConstants.Int:
				case TokenSequenceParserConstantsConstants.Real:
				{
					value = NumberToken();
					break;
				}

				default:
				{
					jj_la1[65] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			if (value != null)
			{
				str = value.image;
			}
			if (attr != null && str != null)
			{
				if (attributes.Contains(attr.image))
				{
					{
						if (true)
						{
							throw new Exception("Attribute already defined: " + attr.image);
						}
					}
				}
				attributes[attr.image] = str;
			}
			{
				if (true)
				{
					return attributes;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public Token NumberToken()
		{
			Token value = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Nonnegint:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
					break;
				}

				case TokenSequenceParserConstantsConstants.Int:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Int);
					break;
				}

				case TokenSequenceParserConstantsConstants.Real:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Real);
					break;
				}

				default:
				{
					jj_la1[66] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return value;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public Token IntegerToken()
		{
			Token value = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Nonnegint:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Nonnegint);
					break;
				}

				case TokenSequenceParserConstantsConstants.Int:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Int);
					break;
				}

				default:
				{
					jj_la1[67] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return value;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public Token CmpToken()
		{
			Token value = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Strregexcmp:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Strregexcmp);
					break;
				}

				case TokenSequenceParserConstantsConstants.Numcmp:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Numcmp);
					break;
				}

				default:
				{
					jj_la1[68] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return value;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public Token RelaxedStringToken()
		{
			Token value = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Str:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Str);
					break;
				}

				case TokenSequenceParserConstantsConstants.Identifier:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
					break;
				}

				default:
				{
					jj_la1[69] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return value;
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public string RelaxedString()
		{
			Token value = null;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case TokenSequenceParserConstantsConstants.Str:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Str);
					if (true)
					{
						return ParseQuotedString(value.image);
					}
					break;
				}

				case TokenSequenceParserConstantsConstants.Identifier:
				{
					value = Jj_consume_token(TokenSequenceParserConstantsConstants.Identifier);
					if (true)
					{
						return value.image;
					}
					break;
				}

				default:
				{
					jj_la1[70] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Exception("Missing return statement in function");
		}

		/*
		String VarName() : {
		Token value = null;
		} {
		( value = <IDENTIFIER> )
		{ return value.image; }
		| ( value = <REGEXVAR> )
		{ return value.image; }
		| ( value = <STR> )
		{ return parseQuotedString(value.image); }
		} */
		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		public string RelaxedStringNoIdentifier()
		{
			Token value = null;
			value = Jj_consume_token(TokenSequenceParserConstantsConstants.Str);
			{
				if (true)
				{
					return ParseQuotedString(value.image);
				}
			}
			throw new Exception("Missing return statement in function");
		}

		private bool Jj_2_1(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_1();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(0, xla);
			}
		}

		private bool Jj_2_2(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_2();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(1, xla);
			}
		}

		private bool Jj_2_3(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_3();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(2, xla);
			}
		}

		private bool Jj_2_4(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_4();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(3, xla);
			}
		}

		private bool Jj_2_5(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_5();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(4, xla);
			}
		}

		private bool Jj_2_6(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_6();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(5, xla);
			}
		}

		private bool Jj_2_7(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_7();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(6, xla);
			}
		}

		private bool Jj_2_8(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_8();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(7, xla);
			}
		}

		private bool Jj_2_9(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_9();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(8, xla);
			}
		}

		private bool Jj_2_10(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_10();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(9, xla);
			}
		}

		private bool Jj_2_11(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_11();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(10, xla);
			}
		}

		private bool Jj_2_12(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_12();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(11, xla);
			}
		}

		private bool Jj_2_13(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_13();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(12, xla);
			}
		}

		private bool Jj_2_14(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_14();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(13, xla);
			}
		}

		private bool Jj_2_15(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_15();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(14, xla);
			}
		}

		private bool Jj_2_16(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_16();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(15, xla);
			}
		}

		private bool Jj_2_17(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_17();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(16, xla);
			}
		}

		private bool Jj_2_18(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_18();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(17, xla);
			}
		}

		private bool Jj_2_19(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_19();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(18, xla);
			}
		}

		private bool Jj_2_20(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_20();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(19, xla);
			}
		}

		private bool Jj_2_21(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_21();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(20, xla);
			}
		}

		private bool Jj_2_22(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_22();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(21, xla);
			}
		}

		private bool Jj_2_23(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_23();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(22, xla);
			}
		}

		private bool Jj_2_24(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_24();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(23, xla);
			}
		}

		private bool Jj_2_25(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_25();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(24, xla);
			}
		}

		private bool Jj_2_26(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_26();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(25, xla);
			}
		}

		private bool Jj_2_27(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_27();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(26, xla);
			}
		}

		private bool Jj_2_28(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_28();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(27, xla);
			}
		}

		private bool Jj_2_29(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_29();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(28, xla);
			}
		}

		private bool Jj_2_30(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_30();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(29, xla);
			}
		}

		private bool Jj_2_31(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_31();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(30, xla);
			}
		}

		private bool Jj_2_32(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_32();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(31, xla);
			}
		}

		private bool Jj_2_33(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_33();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(32, xla);
			}
		}

		private bool Jj_2_34(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_34();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(33, xla);
			}
		}

		private bool Jj_2_35(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_35();
			}
			catch (TokenSequenceParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(34, xla);
			}
		}

		private bool Jj_3_14()
		{
			if (Jj_3R_30())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_73()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_14())
			{
				jj_scanpos = xsp;
				if (Jj_3_15())
				{
					jj_scanpos = xsp;
					if (Jj_3_16())
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3R_51()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Identifier))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_129()
		{
			if (Jj_scan_token(43))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexvar))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_50()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Str))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_32()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_50())
			{
				jj_scanpos = xsp;
				if (Jj_3R_51())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_60()
		{
			if (Jj_3R_72())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_73())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3R_128()
		{
			if (Jj_scan_token(47))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_121()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_128())
			{
				jj_scanpos = xsp;
				if (Jj_3R_129())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_112()
		{
			if (Jj_scan_token(25))
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_121())
			{
				jj_scanpos = xsp;
			}
			if (Jj_3R_59())
			{
				return true;
			}
			if (Jj_scan_token(26))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_108()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(18))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(7))
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_90()
		{
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_52()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(20))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(19))
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_33()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Identifier))
			{
				return true;
			}
			if (Jj_scan_token(25))
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_90())
			{
				jj_scanpos = xsp;
			}
			if (Jj_scan_token(26))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_49()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(13))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(14))
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_66()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexmrgroup))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_65()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexmrvar))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_64()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexgroup))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_135()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(13))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(14))
				{
					jj_scanpos = xsp;
					if (Jj_scan_token(16))
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3R_63()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexvar))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_42()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_62())
			{
				jj_scanpos = xsp;
				if (Jj_3R_63())
				{
					jj_scanpos = xsp;
					if (Jj_3R_64())
					{
						jj_scanpos = xsp;
						if (Jj_3R_65())
						{
							jj_scanpos = xsp;
							if (Jj_3R_66())
							{
								return true;
							}
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3R_62()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Identifier))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_107()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(46))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(45))
				{
					jj_scanpos = xsp;
					if (Jj_scan_token(36))
					{
						jj_scanpos = xsp;
						if (Jj_scan_token(37))
						{
							return true;
						}
					}
				}
			}
			if (Jj_3R_87())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_89()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexvar))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_72()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_88())
			{
				jj_scanpos = xsp;
				if (Jj_3R_89())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_88()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Identifier))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_71()
		{
			if (Jj_3R_87())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_107())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3R_80()
		{
			if (Jj_scan_token(25))
			{
				return true;
			}
			if (Jj_3R_59())
			{
				return true;
			}
			if (Jj_scan_token(26))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_79()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Real))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_78()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Longint))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_77()
		{
			if (Jj_3R_49())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_76()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Str))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_67()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_75())
			{
				jj_scanpos = xsp;
				if (Jj_3R_76())
				{
					jj_scanpos = xsp;
					if (Jj_3R_77())
					{
						jj_scanpos = xsp;
						if (Jj_3R_78())
						{
							jj_scanpos = xsp;
							if (Jj_3R_79())
							{
								jj_scanpos = xsp;
								if (Jj_3R_80())
								{
									return true;
								}
							}
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3R_75()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regex))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_126()
		{
			if (Jj_scan_token(43))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_125()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Nonnegint))
			{
				return true;
			}
			if (Jj_scan_token(33))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_81()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(33))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(30))
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_39()
		{
			if (Jj_3R_32())
			{
				return true;
			}
			if (Jj_scan_token(34))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_28()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Nonnegint))
			{
				return true;
			}
			if (Jj_scan_token(33))
			{
				return true;
			}
			if (Jj_scan_token(24))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_124()
		{
			if (Jj_scan_token(44))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_27()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Nonnegint))
			{
				return true;
			}
			if (Jj_scan_token(24))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_123()
		{
			if (Jj_scan_token(43))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_122()
		{
			if (Jj_scan_token(42))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_118()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_122())
			{
				jj_scanpos = xsp;
				if (Jj_3R_123())
				{
					jj_scanpos = xsp;
					if (Jj_3R_124())
					{
						jj_scanpos = xsp;
						if (Jj_3_27())
						{
							jj_scanpos = xsp;
							if (Jj_3_28())
							{
								jj_scanpos = xsp;
								if (Jj_3R_125())
								{
									return true;
								}
							}
						}
					}
				}
			}
			xsp = jj_scanpos;
			if (Jj_3R_126())
			{
				jj_scanpos = xsp;
			}
			return false;
		}

		private bool Jj_3R_22()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_3R_39())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_81())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			if (Jj_scan_token(24))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_96()
		{
			if (Jj_3R_68())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_115()
		{
			if (Jj_scan_token(23))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_95()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexvar))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_117()
		{
			if (Jj_3R_118())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_134()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexvar))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_45()
		{
			if (Jj_3R_22())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_131()
		{
			if (Jj_3R_134())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_106()
		{
			if (Jj_3R_114())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_44()
		{
			if (Jj_3R_67())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_105()
		{
			if (Jj_3R_113())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_26()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_44())
			{
				jj_scanpos = xsp;
				if (Jj_3R_45())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_104()
		{
			if (Jj_3R_112())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_103()
		{
			if (Jj_3R_111())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_74()
		{
			if (Jj_scan_token(33))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_102()
		{
			if (Jj_3R_110())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_101()
		{
			if (Jj_3R_109())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_61()
		{
			if (Jj_3R_31())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_74())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3R_97()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_101())
			{
				jj_scanpos = xsp;
				if (Jj_3R_102())
				{
					jj_scanpos = xsp;
					if (Jj_3R_103())
					{
						jj_scanpos = xsp;
						if (Jj_3R_104())
						{
							jj_scanpos = xsp;
							if (Jj_3R_105())
							{
								jj_scanpos = xsp;
								if (Jj_3R_106())
								{
									return true;
								}
							}
						}
					}
				}
			}
			xsp = jj_scanpos;
			if (Jj_3R_117())
			{
				jj_scanpos = xsp;
			}
			return false;
		}

		private bool Jj_3R_120()
		{
			if (Jj_scan_token(43))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_87()
		{
			Token xsp;
			if (Jj_3R_97())
			{
				return true;
			}
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_97())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			xsp = jj_scanpos;
			if (Jj_3R_115())
			{
				jj_scanpos = xsp;
			}
			return false;
		}

		private bool Jj_3R_40()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Identifier))
			{
				return true;
			}
			if (Jj_scan_token(25))
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_61())
			{
				jj_scanpos = xsp;
			}
			if (Jj_scan_token(26))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_127()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Nonnegint))
			{
				return true;
			}
			if (Jj_scan_token(33))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_35()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Nonnegint))
			{
				return true;
			}
			if (Jj_scan_token(33))
			{
				return true;
			}
			if (Jj_scan_token(24))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_30()
		{
			if (Jj_scan_token(31))
			{
				return true;
			}
			if (Jj_3R_49())
			{
				return true;
			}
			if (Jj_scan_token(32))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_133()
		{
			if (Jj_3R_134())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_119()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_34())
			{
				jj_scanpos = xsp;
				if (Jj_3_35())
				{
					jj_scanpos = xsp;
					if (Jj_3R_127())
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3_34()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Nonnegint))
			{
				return true;
			}
			if (Jj_scan_token(24))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_111()
		{
			if (Jj_scan_token(52))
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_119())
			{
				jj_scanpos = xsp;
			}
			xsp = jj_scanpos;
			if (Jj_3R_120())
			{
				jj_scanpos = xsp;
			}
			if (Jj_3R_110())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_13()
		{
			if (Jj_3R_29())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_12()
		{
			if (Jj_3R_28())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_11()
		{
			if (Jj_3R_27())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_10()
		{
			if (Jj_3R_26())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_9()
		{
			if (Jj_3R_25())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_8()
		{
			if (Jj_3R_24())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_110()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(18))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(17))
				{
					jj_scanpos = xsp;
					if (Jj_scan_token(7))
					{
						jj_scanpos = xsp;
						if (Jj_scan_token(13))
						{
							jj_scanpos = xsp;
							if (Jj_scan_token(14))
							{
								jj_scanpos = xsp;
								if (Jj_scan_token(15))
								{
									jj_scanpos = xsp;
									if (Jj_scan_token(16))
									{
										jj_scanpos = xsp;
										if (Jj_scan_token(21))
										{
											return true;
										}
									}
								}
							}
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3R_98()
		{
			if (Jj_scan_token(41))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_31()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_8())
			{
				jj_scanpos = xsp;
				if (Jj_3_9())
				{
					jj_scanpos = xsp;
					if (Jj_3_10())
					{
						jj_scanpos = xsp;
						if (Jj_3_11())
						{
							jj_scanpos = xsp;
							if (Jj_3_12())
							{
								jj_scanpos = xsp;
								if (Jj_3_13())
								{
									return true;
								}
							}
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3R_70()
		{
			if (Jj_scan_token(40))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_132()
		{
			if (Jj_3R_135())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_59()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_70())
			{
				jj_scanpos = xsp;
			}
			if (Jj_3R_71())
			{
				return true;
			}
			xsp = jj_scanpos;
			if (Jj_3R_98())
			{
				jj_scanpos = xsp;
			}
			return false;
		}

		private bool Jj_3R_38()
		{
			if (Jj_3R_60())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_58()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Numcmp))
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_132())
			{
				jj_scanpos = xsp;
				if (Jj_3R_133())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_57()
		{
			if (Jj_scan_token(51))
			{
				return true;
			}
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Identifier))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_23()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regex))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_56()
		{
			if (Jj_scan_token(34))
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(18))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(17))
				{
					jj_scanpos = xsp;
					if (Jj_scan_token(7))
					{
						jj_scanpos = xsp;
						if (Jj_3R_131())
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3R_21()
		{
			if (Jj_3R_38())
			{
				return true;
			}
			if (Jj_scan_token(29))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_48()
		{
			if (Jj_3R_68())
			{
				return true;
			}
			if (Jj_scan_token(23))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_37()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Identifier))
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_56())
			{
				jj_scanpos = xsp;
				if (Jj_3R_57())
				{
					jj_scanpos = xsp;
					if (Jj_3R_58())
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3_7()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(28))
			{
				return true;
			}
			if (Jj_3R_23())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_6()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(27))
			{
				return true;
			}
			if (Jj_scan_token(25))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_29()
		{
			if (Jj_scan_token(38))
			{
				return true;
			}
			if (Jj_scan_token(22))
			{
				return true;
			}
			Token xsp;
			if (Jj_3R_48())
			{
				return true;
			}
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_48())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3_5()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_scan_token(25))
			{
				return true;
			}
			if (Jj_3R_59())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_100()
		{
			if (Jj_3R_108())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_20()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_4())
			{
				jj_scanpos = xsp;
				if (Jj_3_5())
				{
					jj_scanpos = xsp;
					if (Jj_3_6())
					{
						jj_scanpos = xsp;
						if (Jj_3_7())
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3_4()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_3R_23())
			{
				return true;
			}
			if (Jj_scan_token(23))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_94()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_100())
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(17))
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3_33()
		{
			if (Jj_3R_37())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_86()
		{
			if (Jj_scan_token(49))
			{
				return true;
			}
			if (Jj_3R_96())
			{
				return true;
			}
			if (Jj_scan_token(50))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_85()
		{
			if (Jj_3R_95())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_3()
		{
			if (Jj_3R_22())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_2()
		{
			if (Jj_3R_21())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_1()
		{
			if (Jj_3R_20())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_93()
		{
			if (Jj_scan_token(22))
			{
				return true;
			}
			if (Jj_3R_37())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_83()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(36))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(37))
				{
					return true;
				}
			}
			if (Jj_3R_82())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_69()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_84())
			{
				jj_scanpos = xsp;
				if (Jj_3R_85())
				{
					jj_scanpos = xsp;
					if (Jj_3R_86())
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3R_84()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_93())
			{
				jj_scanpos = xsp;
				if (Jj_3_33())
				{
					jj_scanpos = xsp;
					if (Jj_3R_94())
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3R_68()
		{
			if (Jj_3R_82())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_83())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3R_54()
		{
			if (Jj_3R_69())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_53()
		{
			if (Jj_scan_token(48))
			{
				return true;
			}
			if (Jj_3R_69())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_35()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_53())
			{
				jj_scanpos = xsp;
				if (Jj_3R_54())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_92()
		{
			if (Jj_scan_token(25))
			{
				return true;
			}
			if (Jj_3R_68())
			{
				return true;
			}
			if (Jj_scan_token(26))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_91()
		{
			if (Jj_3R_99())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_82()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_91())
			{
				jj_scanpos = xsp;
				if (Jj_3R_92())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3_32()
		{
			if (Jj_scan_token(48))
			{
				return true;
			}
			if (Jj_scan_token(25))
			{
				return true;
			}
			if (Jj_3R_36())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_26()
		{
			if (Jj_3R_24())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_31()
		{
			if (Jj_scan_token(25))
			{
				return true;
			}
			if (Jj_3R_36())
			{
				return true;
			}
			if (Jj_scan_token(26))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_30()
		{
			if (Jj_3R_35())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_34()
		{
			if (Jj_3R_52())
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_55()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_30())
			{
				jj_scanpos = xsp;
				if (Jj_3_31())
				{
					jj_scanpos = xsp;
					if (Jj_3_32())
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool Jj_3_25()
		{
			if (Jj_3R_25())
			{
				return true;
			}
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_34())
			{
				jj_scanpos = xsp;
			}
			return false;
		}

		private bool Jj_3R_99()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_25())
			{
				jj_scanpos = xsp;
				if (Jj_3_26())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_47()
		{
			if (Jj_scan_token(33))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_130()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_scan_token(46))
			{
				jj_scanpos = xsp;
				if (Jj_scan_token(45))
				{
					jj_scanpos = xsp;
					if (Jj_scan_token(36))
					{
						jj_scanpos = xsp;
						if (Jj_scan_token(37))
						{
							return true;
						}
					}
				}
			}
			if (Jj_3R_55())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_28()
		{
			if (Jj_scan_token(31))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_47())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			if (Jj_scan_token(32))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_36()
		{
			if (Jj_3R_55())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_130())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3R_46()
		{
			if (Jj_scan_token(33))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_27()
		{
			if (Jj_scan_token(25))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_46())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			if (Jj_scan_token(26))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_24()
		{
			if (Jj_scan_token(35))
			{
				return true;
			}
			if (Jj_3R_32())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_23()
		{
			if (Jj_scan_token(35))
			{
				return true;
			}
			if (Jj_3R_33())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_22()
		{
			if (Jj_scan_token(31))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			if (Jj_scan_token(32))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_41()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_21())
			{
				jj_scanpos = xsp;
				if (Jj_3_22())
				{
					jj_scanpos = xsp;
					if (Jj_3_23())
					{
						jj_scanpos = xsp;
						if (Jj_3_24())
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3_21()
		{
			if (Jj_3R_30())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_24()
		{
			if (Jj_3R_40())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_41())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3_20()
		{
			if (Jj_scan_token(35))
			{
				return true;
			}
			if (Jj_3R_32())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_114()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Backref))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_19()
		{
			if (Jj_scan_token(35))
			{
				return true;
			}
			if (Jj_3R_33())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_18()
		{
			if (Jj_scan_token(31))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			if (Jj_scan_token(32))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_43()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_17())
			{
				jj_scanpos = xsp;
				if (Jj_3_18())
				{
					jj_scanpos = xsp;
					if (Jj_3_19())
					{
						jj_scanpos = xsp;
						if (Jj_3_20())
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		private bool Jj_3_17()
		{
			if (Jj_3R_30())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_113()
		{
			if (Jj_scan_token(TokenSequenceParserConstantsConstants.Regexvar))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_25()
		{
			if (Jj_3R_42())
			{
				return true;
			}
			Token xsp;
			while (true)
			{
				xsp = jj_scanpos;
				if (Jj_3R_43())
				{
					jj_scanpos = xsp;
					break;
				}
			}
			return false;
		}

		private bool Jj_3R_116()
		{
			if (Jj_scan_token(31))
			{
				return true;
			}
			if (Jj_3R_36())
			{
				return true;
			}
			if (Jj_scan_token(32))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_29()
		{
			if (Jj_scan_token(31))
			{
				return true;
			}
			if (Jj_scan_token(32))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_16()
		{
			if (Jj_scan_token(35))
			{
				return true;
			}
			if (Jj_3R_32())
			{
				return true;
			}
			return false;
		}

		private bool Jj_3R_109()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3_29())
			{
				jj_scanpos = xsp;
				if (Jj_3R_116())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3_15()
		{
			if (Jj_scan_token(31))
			{
				return true;
			}
			if (Jj_3R_31())
			{
				return true;
			}
			return false;
		}

		/// <summary>Generated Token Manager.</summary>
		public TokenSequenceParserTokenManager token_source;

		internal SimpleCharStream jj_input_stream;

		/// <summary>Current token.</summary>
		public Token token;

		/// <summary>Next token.</summary>
		public Token jj_nt;

		private int jj_ntk;

		private Token jj_scanpos;

		private Token jj_lastpos;

		private int jj_la;

		private int jj_gen;

		private readonly int[] jj_la1 = new int[71];

		private static int[] jj_la1_0;

		private static int[] jj_la1_1;

		static TokenSequenceParser()
		{
			Jj_la1_init_0();
			Jj_la1_init_1();
		}

		private static void Jj_la1_init_0()
		{
			jj_la1_0 = new int[] { unchecked((int)(0x400180)), unchecked((int)(0x40000000)), unchecked((int)(0x0)), unchecked((int)(0x8247ef80)), unchecked((int)(0x247e000)), unchecked((int)(0x40000000)), unchecked((int)(0x40000000)), unchecked((int)(0x207e000
				)), unchecked((int)(0x180)), unchecked((int)(0xf80)), unchecked((int)(0x0)), unchecked((int)(0x8247ef80)), unchecked((int)(0x80000000)), unchecked((int)(0x80000000)), unchecked((int)(0x80000000)), unchecked((int)(0x0)), unchecked((int)(0x0)
				), unchecked((int)(0x180000)), unchecked((int)(0x2000f80)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x40000000)), unchecked((int)(0x2000f80)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked(
				(int)(0x5e000)), unchecked((int)(0x8227f180)), unchecked((int)(0x400000)), unchecked((int)(0x8227f180)), unchecked((int)(0x800000)), unchecked((int)(0x0)), unchecked((int)(0x400000)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked(
				(int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x80000000)), unchecked((int)(0x82460180)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked(
				(int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x460180)), unchecked((int)(0x40000000)), unchecked((int)(0x40000000)), unchecked((int)(0x60080)), unchecked((int)(0x400000)), unchecked((int)(0x60080)), unchecked((
				int)(0x460180)), unchecked((int)(0x60180)), unchecked((int)(0x16100)), unchecked((int)(0x80000)), unchecked((int)(0x27e080)), unchecked((int)(0x400000)), unchecked((int)(0x400000)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int
				)(0x40000000)), unchecked((int)(0x40000000)), unchecked((int)(0x56080)), unchecked((int)(0x16000)), unchecked((int)(0x6000)), unchecked((int)(0x180000)), unchecked((int)(0x40080)), unchecked((int)(0x40080)) };
		}

		private static void Jj_la1_init_1()
		{
			jj_la1_1 = new int[] { unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x2)), unchecked((int)(0x40)), unchecked((int)(0x0)), unchecked((int)(0x2)), unchecked((int)(0x2)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked(
				(int)(0x0)), unchecked((int)(0x2)), unchecked((int)(0x40)), unchecked((int)(0x8)), unchecked((int)(0x8)), unchecked((int)(0x8)), unchecked((int)(0x2)), unchecked((int)(0x2)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x30
				)), unchecked((int)(0x30)), unchecked((int)(0x2)), unchecked((int)(0x0)), unchecked((int)(0x80)), unchecked((int)(0x100)), unchecked((int)(0x200)), unchecked((int)(0x0)), unchecked((int)(0x100000)), unchecked((int)(0x1c00)), unchecked((int)
				(0x100000)), unchecked((int)(0x0)), unchecked((int)(0x1c00)), unchecked((int)(0x0)), unchecked((int)(0x800)), unchecked((int)(0x2020)), unchecked((int)(0x2020)), unchecked((int)(0x6030)), unchecked((int)(0x6030)), unchecked((int)(0x8800)), 
				unchecked((int)(0x8800)), unchecked((int)(0x0)), unchecked((int)(0x30000)), unchecked((int)(0x2020)), unchecked((int)(0x2020)), unchecked((int)(0x4010)), unchecked((int)(0x4010)), unchecked((int)(0x6030)), unchecked((int)(0x6030)), unchecked(
				(int)(0x30000)), unchecked((int)(0x2)), unchecked((int)(0x2)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x20000)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x80004)), unchecked(
				(int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x800)), unchecked((int)(0x200000)), unchecked((int)(0x2)), unchecked((int)(0x2)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int
				)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)) };
		}

		private readonly TokenSequenceParser.JJCalls[] jj_2_rtns = new TokenSequenceParser.JJCalls[35];

		private bool jj_rescan = false;

		private int jj_gc = 0;

		/// <summary>Constructor with InputStream.</summary>
		public TokenSequenceParser(InputStream stream)
			: this(stream, null)
		{
		}

		/// <summary>Constructor with InputStream and supplied encoding</summary>
		public TokenSequenceParser(InputStream stream, string encoding)
		{
			try
			{
				jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
			}
			catch (UnsupportedEncodingException e)
			{
				throw new Exception(e);
			}
			token_source = new TokenSequenceParserTokenManager(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 71; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TokenSequenceParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(InputStream stream)
		{
			ReInit(stream, null);
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(InputStream stream, string encoding)
		{
			try
			{
				jj_input_stream.ReInit(stream, encoding, 1, 1);
			}
			catch (UnsupportedEncodingException e)
			{
				throw new Exception(e);
			}
			token_source.ReInit(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 71; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TokenSequenceParser.JJCalls();
			}
		}

		/// <summary>Constructor.</summary>
		public TokenSequenceParser(Reader stream)
		{
			jj_input_stream = new SimpleCharStream(stream, 1, 1);
			token_source = new TokenSequenceParserTokenManager(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 71; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TokenSequenceParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(Reader stream)
		{
			jj_input_stream.ReInit(stream, 1, 1);
			token_source.ReInit(jj_input_stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 71; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TokenSequenceParser.JJCalls();
			}
		}

		/// <summary>Constructor with generated Token Manager.</summary>
		public TokenSequenceParser(TokenSequenceParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 71; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TokenSequenceParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		public virtual void ReInit(TokenSequenceParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 71; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new TokenSequenceParser.JJCalls();
			}
		}

		/// <exception cref="Edu.Stanford.Nlp.Ling.Tokensregex.Parser.ParseException"/>
		private Token Jj_consume_token(int kind)
		{
			Token oldToken;
			if ((oldToken = token).next != null)
			{
				token = token.next;
			}
			else
			{
				token = token.next = token_source.GetNextToken();
			}
			jj_ntk = -1;
			if (token.kind == kind)
			{
				jj_gen++;
				if (++jj_gc > 100)
				{
					jj_gc = 0;
					foreach (TokenSequenceParser.JJCalls jj_2_rtn in jj_2_rtns)
					{
						TokenSequenceParser.JJCalls c = jj_2_rtn;
						while (c != null)
						{
							if (c.gen < jj_gen)
							{
								c.first = null;
							}
							c = c.next;
						}
					}
				}
				return token;
			}
			token = oldToken;
			jj_kind = kind;
			throw GenerateParseException();
		}

		[System.Serializable]
		private sealed class LookaheadSuccess : Exception
		{
		}

		private readonly TokenSequenceParser.LookaheadSuccess jj_ls = new TokenSequenceParser.LookaheadSuccess();

		private bool Jj_scan_token(int kind)
		{
			if (jj_scanpos == jj_lastpos)
			{
				jj_la--;
				if (jj_scanpos.next == null)
				{
					jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.GetNextToken();
				}
				else
				{
					jj_lastpos = jj_scanpos = jj_scanpos.next;
				}
			}
			else
			{
				jj_scanpos = jj_scanpos.next;
			}
			if (jj_rescan)
			{
				int i = 0;
				Token tok = token;
				while (tok != null && tok != jj_scanpos)
				{
					i++;
					tok = tok.next;
				}
				if (tok != null)
				{
					Jj_add_error_token(kind, i);
				}
			}
			if (jj_scanpos.kind != kind)
			{
				return true;
			}
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
			{
				throw jj_ls;
			}
			return false;
		}

		/// <summary>Get the next Token.</summary>
		public Token GetNextToken()
		{
			if (token.next != null)
			{
				token = token.next;
			}
			else
			{
				token = token.next = token_source.GetNextToken();
			}
			jj_ntk = -1;
			jj_gen++;
			return token;
		}

		/// <summary>Get the specific Token.</summary>
		public Token GetToken(int index)
		{
			Token t = token;
			for (int i = 0; i < index; i++)
			{
				if (t.next != null)
				{
					t = t.next;
				}
				else
				{
					t = t.next = token_source.GetNextToken();
				}
			}
			return t;
		}

		private int Jj_ntk()
		{
			if ((jj_nt = token.next) == null)
			{
				return (jj_ntk = (token.next = token_source.GetNextToken()).kind);
			}
			else
			{
				return (jj_ntk = jj_nt.kind);
			}
		}

		private IList<int[]> jj_expentries = new List<int[]>();

		private int[] jj_expentry;

		private int jj_kind = -1;

		private int[] jj_lasttokens = new int[100];

		private int jj_endpos;

		private void Jj_add_error_token(int kind, int pos)
		{
			if (pos >= 100)
			{
				return;
			}
			if (pos == jj_endpos + 1)
			{
				jj_lasttokens[jj_endpos++] = kind;
			}
			else
			{
				if (jj_endpos != 0)
				{
					jj_expentry = new int[jj_endpos];
					for (int i = 0; i < jj_endpos; i++)
					{
						jj_expentry[i] = jj_lasttokens[i];
					}
					foreach (int[] jj_expentry1 in jj_expentries)
					{
						int[] oldentry = (int[])(jj_expentry1);
						if (oldentry.Length == jj_expentry.Length)
						{
							for (int i_1 = 0; i_1 < jj_expentry.Length; i_1++)
							{
								if (oldentry[i_1] != jj_expentry[i_1])
								{
									goto jj_entries_loop_continue;
								}
							}
							jj_expentries.Add(jj_expentry);
							goto jj_entries_loop_break;
						}
					}
jj_entries_loop_break: ;
					if (pos != 0)
					{
						jj_lasttokens[(jj_endpos = pos) - 1] = kind;
					}
				}
			}
		}

		/// <summary>Generate ParseException.</summary>
		public virtual ParseException GenerateParseException()
		{
			jj_expentries.Clear();
			bool[] la1tokens = new bool[55];
			if (jj_kind >= 0)
			{
				la1tokens[jj_kind] = true;
				jj_kind = -1;
			}
			for (int i = 0; i < 71; i++)
			{
				if (jj_la1[i] == jj_gen)
				{
					for (int j = 0; j < 32; j++)
					{
						if ((jj_la1_0[i] & (1 << j)) != 0)
						{
							la1tokens[j] = true;
						}
						if ((jj_la1_1[i] & (1 << j)) != 0)
						{
							la1tokens[32 + j] = true;
						}
					}
				}
			}
			for (int i_1 = 0; i_1 < 55; i_1++)
			{
				if (la1tokens[i_1])
				{
					jj_expentry = new int[1];
					jj_expentry[0] = i_1;
					jj_expentries.Add(jj_expentry);
				}
			}
			jj_endpos = 0;
			Jj_rescan_token();
			Jj_add_error_token(0, 0);
			int[][] exptokseq = new int[jj_expentries.Count][];
			for (int i_2 = 0; i_2 < jj_expentries.Count; i_2++)
			{
				exptokseq[i_2] = jj_expentries[i_2];
			}
			return new ParseException(token, exptokseq, TokenSequenceParserConstantsConstants.tokenImage);
		}

		/// <summary>Enable tracing.</summary>
		public void Enable_tracing()
		{
		}

		/// <summary>Disable tracing.</summary>
		public void Disable_tracing()
		{
		}

		private void Jj_rescan_token()
		{
			jj_rescan = true;
			for (int i = 0; i < 35; i++)
			{
				try
				{
					TokenSequenceParser.JJCalls p = jj_2_rtns[i];
					do
					{
						if (p.gen > jj_gen)
						{
							jj_la = p.arg;
							jj_lastpos = jj_scanpos = p.first;
							switch (i)
							{
								case 0:
								{
									Jj_3_1();
									break;
								}

								case 1:
								{
									Jj_3_2();
									break;
								}

								case 2:
								{
									Jj_3_3();
									break;
								}

								case 3:
								{
									Jj_3_4();
									break;
								}

								case 4:
								{
									Jj_3_5();
									break;
								}

								case 5:
								{
									Jj_3_6();
									break;
								}

								case 6:
								{
									Jj_3_7();
									break;
								}

								case 7:
								{
									Jj_3_8();
									break;
								}

								case 8:
								{
									Jj_3_9();
									break;
								}

								case 9:
								{
									Jj_3_10();
									break;
								}

								case 10:
								{
									Jj_3_11();
									break;
								}

								case 11:
								{
									Jj_3_12();
									break;
								}

								case 12:
								{
									Jj_3_13();
									break;
								}

								case 13:
								{
									Jj_3_14();
									break;
								}

								case 14:
								{
									Jj_3_15();
									break;
								}

								case 15:
								{
									Jj_3_16();
									break;
								}

								case 16:
								{
									Jj_3_17();
									break;
								}

								case 17:
								{
									Jj_3_18();
									break;
								}

								case 18:
								{
									Jj_3_19();
									break;
								}

								case 19:
								{
									Jj_3_20();
									break;
								}

								case 20:
								{
									Jj_3_21();
									break;
								}

								case 21:
								{
									Jj_3_22();
									break;
								}

								case 22:
								{
									Jj_3_23();
									break;
								}

								case 23:
								{
									Jj_3_24();
									break;
								}

								case 24:
								{
									Jj_3_25();
									break;
								}

								case 25:
								{
									Jj_3_26();
									break;
								}

								case 26:
								{
									Jj_3_27();
									break;
								}

								case 27:
								{
									Jj_3_28();
									break;
								}

								case 28:
								{
									Jj_3_29();
									break;
								}

								case 29:
								{
									Jj_3_30();
									break;
								}

								case 30:
								{
									Jj_3_31();
									break;
								}

								case 31:
								{
									Jj_3_32();
									break;
								}

								case 32:
								{
									Jj_3_33();
									break;
								}

								case 33:
								{
									Jj_3_34();
									break;
								}

								case 34:
								{
									Jj_3_35();
									break;
								}
							}
						}
						p = p.next;
					}
					while (p != null);
				}
				catch (TokenSequenceParser.LookaheadSuccess)
				{
				}
			}
			jj_rescan = false;
		}

		private void Jj_save(int index, int xla)
		{
			TokenSequenceParser.JJCalls p = jj_2_rtns[index];
			while (p.gen > jj_gen)
			{
				if (p.next == null)
				{
					p = p.next = new TokenSequenceParser.JJCalls();
					break;
				}
				p = p.next;
			}
			p.gen = jj_gen + xla - jj_la;
			p.first = token;
			p.arg = xla;
		}

		internal sealed class JJCalls
		{
			internal int gen;

			internal Token first;

			internal int arg;

			internal TokenSequenceParser.JJCalls next;
		}
	}
}
